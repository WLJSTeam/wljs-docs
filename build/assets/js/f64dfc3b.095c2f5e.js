"use strict";(self.webpackChunkwlx_docs=self.webpackChunkwlx_docs||[]).push([[92901],{28453:(e,n,o)=>{o.d(n,{R:()=>s,x:()=>a});var t=o(96540);const r={},d=t.createContext(r);function s(e){const n=t.useContext(d);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),t.createElement(d.Provider,{value:n},e.children)}},61814:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>u,frontMatter:()=>d,metadata:()=>a,toc:()=>i});var t=o(74848),r=o(28453);const d={draft:!1},s=void 0,a={id:"frontend/Advanced/Dynamics/Scoping",title:"Scoping",description:"Since Module adds the Temporal attribute to your symbols, it is unclear when and how your dynamic symbols will be purged from the Kernel. Therefore, use LeakyModule to scope all dynamic symbols.",source:"@site/docs/frontend/Advanced/Dynamics/Scoping.md",sourceDirName:"frontend/Advanced/Dynamics",slug:"/frontend/Advanced/Dynamics/Scoping",permalink:"/frontend/Advanced/Dynamics/Scoping",draft:!1,unlisted:!1,tags:[],version:"current",lastUpdatedAt:1743582564e3,frontMatter:{draft:!1},sidebar:"tutorialSidebar",previous:{title:"Raster animation",permalink:"/frontend/Advanced/Dynamics/Raster animation"},next:{title:"Sound",permalink:"/frontend/Advanced/Dynamics/Sound"}},c={},i=[];function l(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",p:"p",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.p,{children:["Since ",(0,t.jsx)(n.code,{children:"Module"})," adds the ",(0,t.jsx)(n.code,{children:"Temporal"})," attribute to your symbols, it is unclear when and how your dynamic symbols will be purged from the Kernel. Therefore, use ",(0,t.jsx)(n.a,{href:"/frontend/Reference/Misc/Language#%60LeakyModule%60",children:(0,t.jsx)(n.code,{children:"LeakyModule"})})," to scope all dynamic symbols."]}),"\n",(0,t.jsxs)(n.p,{children:["You can clean them up using ",(0,t.jsx)(n.code,{children:"ClearAll"})," after a notebook has been closed or a cell has been destroyed. ",(0,t.jsx)(n.a,{href:"/frontend/Reference/Misc/Events#%60EventHandler%60",children:(0,t.jsx)(n.code,{children:"EventHandler"})})," methods are applicable to ",(0,t.jsx)(n.a,{href:"/frontend/Reference/Cells%20and%20Notebook/ResultCell",children:"ResultCell"}),", ",(0,t.jsx)(n.a,{href:"/frontend/Reference/Cells%20and%20Notebook/EvaluationNotebook",children:"EvaluationNotebook"}),", or even ",(0,t.jsx)(n.a,{href:"/frontend/Reference/Frontend%20IO/WindowObj",children:"WindowObj"}),"."]}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsxs)(n.p,{children:["Since ",(0,t.jsx)(n.em,{children:"WL 14.2"})," using ",(0,t.jsx)(n.code,{children:"LeakyModule"})," is unnecessary. The native ",(0,t.jsx)(n.code,{children:"Module"})," will do the job."]})})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}}}]);