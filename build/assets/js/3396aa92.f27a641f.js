"use strict";(self.webpackChunkwlx_docs=self.webpackChunkwlx_docs||[]).push([[26128],{25176:n=>{n.exports=JSON.parse('{"archive":{"blogPosts":[{"id":"/2025/01/06/MusicScales","metadata":{"permalink":"/wljs-docs/widgets/2025/01/06/MusicScales","source":"@site/widgets/2025-01-06-MusicScales/index.md","title":"Musical scales and chords maker","description":"A multi-window app for deriving chords based on provided key and musical scale. The whole purpose is to quickly show on piano or guitar fingerboard all positions for the given combination of two. Charts are interactive - click to hear the sound","date":"2025-01-06T00:00:00.000Z","tags":[],"readingTime":8.855,"hasTruncateMarker":true,"authors":[],"frontMatter":{},"unlisted":false,"nextItem":{"title":"Optics units converter","permalink":"/wljs-docs/widgets/2024/12/19/Units"}},"content":"A multi-window app for deriving chords based on provided key and musical scale. The whole purpose is to quickly show on piano or guitar fingerboard all positions for the given combination of two. Charts are interactive - click to hear the sound\\n\\n![](./../Screenshot%202025-01-06%20at%2014.29.47.png)\\n\\n__Features__\\n\\n- Support for custom strings tuning\\n- Circle of Fifth generation\\n- Piano & Guitar fingerboard view\\n- Sound preview\\n- Pentatonics & normal scales\\n\\n<a\\n  href={ require(\'./Scales and chords.wlw\').default }\\n  className=\\"p-2 text-sm w-full flex ring-1 ring-inset text-gray-600 font-medium shadow ring-gray-300 bg-gray-300 my-2\\"\\n>\\n  Download App v.01\\n  <svg\\n    xmlns=\\"http://www.w3.org/2000/svg\\"\\n    fill=\\"none\\"\\n    className=\\"w-5 h-5 ml-auto\\"\\n    viewBox=\\"0 0 24 24\\"\\n  >\\n    <path\\n      stroke=\\"currentColor\\"\\n      strokeLinecap=\\"round\\"\\n      strokeLinejoin=\\"round\\"\\n      d=\\"M17 17h.01m.39-3h.6c.932 0 1.398 0 1.765.152a2 2 0 0 1 1.083 1.083C21 15.602 21 16.068 21 17s0 1.398-.152 1.765a2 2 0 0 1-1.083 1.083C19.398 20 18.932 20 18 20H6c-.932 0-1.398 0-1.765-.152a2 2 0 0 1-1.083-1.083C3 18.398 3 17.932 3 17s0-1.398.152-1.765a2 2 0 0 1 1.083-1.083C4.602 14 5.068 14 6 14h.6m5.4 1V4m0 11-3-3m3 3 3-3\\"\\n    ></path>\\n  </svg>\\n</a>\\n\\n\\n\\n\x3c!--truncate--\x3e\\n\\n\\n## How it works\\n### Music theory\\nThis app itself consists of small framework to work with `SoundNote`, which helps to make chords and mess with notes combinations. Here is a part of it\\n\\n```mathematica\\nconvertToSemitones[s_String] := With[{c = StringCases[s, {a__~~b:DigitCharacter :> {a,ToExpression[b]}, a__ :> {a,4}}]//First},\\n  semitone[c[[1]]] + (c[[2]] - 4) 12\\n]\\nconvertToSemitones[s_] := s;\\n\\nconvertToSemitones[l_List] := convertToSemitones /@ l\\n\\nsemitone[0] = \\"C\\";\\nsemitone[1] = \\"C#\\";\\nsemitone[2] = \\"D\\";\\nsemitone[3] = \\"D#\\";\\nsemitone[3] = \\"Eb\\";\\nsemitone[4] = \\"E\\";\\nsemitone[5] = \\"F\\";\\nsemitone[6] = \\"F#\\";\\nsemitone[6] = \\"Gb\\";\\nsemitone[7] = \\"G\\";\\nsemitone[8] = \\"Ab\\";\\nsemitone[8] = \\"G#\\";\\nsemitone[9] = \\"A\\";\\nsemitone[10] = \\"Bb\\";\\nsemitone[11] = \\"B\\";\\n\\nsemitone[n_Integer] :=  semitone[Mod[n, 12]] /; n>11 \\n\\nsemitone[\\"C\\"] = 0;\\nsemitone[\\"C#\\"] = 1;\\nsemitone[\\"D\\"] = 2;\\nsemitone[\\"D#\\"] = 3;\\nsemitone[\\"Eb\\"] = 3;\\nsemitone[\\"E\\"] = 4;\\nsemitone[\\"F\\"] = 5;\\nsemitone[\\"F#\\"] = 6;\\nsemitone[\\"Gb\\"] = 6;\\nsemitone[\\"G\\"] = 7;\\nsemitone[\\"Ab\\"] = 8;\\nsemitone[\\"G#\\"] = 8;\\nsemitone[\\"A\\"] = 9;\\nsemitone[\\"Bb\\"] = 10;\\nsemitone[\\"B\\"] = 11;\\n\\nscale[\\"Major\\"] = {2,2,1,2,2,2,1};\\nmood[\\"Major\\"] = \\"Bright and upbeat feeling\\";\\nscale[\\"Major Pentatonic\\"] = {2, 2, 3, 2, 3};\\nmood[\\"Major Pentatonic\\"] = \\"Joyful and open feeling\\";\\nscale[\\"Minor\\"] = {2,1,2,2,1,2,2};\\nmood[\\"Minor\\"] = \\"Sad and reflective feeling\\";\\nscale[\\"Minor Pentatonic\\"] = {3, 2, 2, 3, 2};\\nmood[\\"Minor Pentatonic\\"] = \\"Bluesy and soulful feeling\\";\\nscale[\\"Dorian\\"] = {2,1,2,2,2,1,2};\\nmood[\\"Dorian\\"] = \\"Mellow and jazzy feeling\\";\\nscale[\\"Lydian\\"] = {2,2,2,1,2,2,1};\\nmood[\\"Lydian\\"] = \\"Dreamy and mystical feeling\\";\\nscale[\\"Mixolydian\\"] = {2,2,1,2,2,1,2};\\nmood[\\"Mixolydian\\"] = \\"Bluesy and relaxed feeling\\";\\nscale[\\"Phrygian\\"] = {1,2,2,2,1,2,2};\\nmood[\\"Phrygian\\"] = \\"Exotic and tense feeling\\";\\n\\nmajorQ[SoundNote[n_List]] := With[{notes = Sort[convertToSemitones @ n]},\\n  notes[[2]] - notes[[1]] > 3\\n]\\n\\nmakeScale[root_Integer, scale_List] := With[{base = Accumulate[Join[{root}, scale]]},\\n  (base[[Mod[#-1, Length[base]-1] + 1]] + 12 Floor[# / Length[base]]) &\\n]\\n\\nmakeScale[root_String, scale_List] := makeScale[convertToSemitones[root], scale]\\n\\nmakeChord[root_, scalename_String, ext_Integer:3] := With[{s = makeScale[root, scale[scalename]]},\\n  chordObject[s, ext]\\n]\\n\\nNoteTranspose[SoundNote[l_List], i_Integer] := With[{c = convertToSemitones[l]}, \\n  SoundNote[Map[(# + i)&, c]]\\n]\\n\\nNoteTranspose[SoundNote[l_Integer], i_Integer] := With[{c = convertToSemitones[l]}, \\n  SoundNote[c + i]\\n]\\n\\nNoteMerge[s:(SoundNote[_List]..)] := SoundNote[DeleteDuplicates[convertToSemitones[Join @@ ({s}[[All,1]])]]]\\n\\n\\nmakeChord[root_, scalename_String, ext_String];\\nmakeChord[root_, scalename_String, ext_Integer, mod_Rule];\\nmakeChord[root_, scalename_String, ext_Integer, mod:{__Rule}];\\n\\nchordObject[s_, ext_][offset_String] := chordObject[s, ext][FromRomanNumeral[offset]-1]\\n\\nchordObject[s_, ext_][offset_Integer] := SoundNote @ Table[  s[i + offset], {i, 1, 2 ext, 2}] \\n\\nNoteNormalize[SoundNote[l_List], {min_, max_}] := With[{notes = convertToSemitones @ l},\\n  SoundNote[With[{mod = Mod[#, max]}, If[mod < min, mod + min, mod]] &/@ notes // DeleteDuplicates]\\n]\\n```\\n\\nUsing that one can create tonic chord in given scale by simply calling\\n\\n```mathematica\\nmakeChord[\\"C\\", \\"Major\\", 3][0]\\n```\\n\\nand extend it \\n\\n```mathematica\\nmakeChord[\\"C\\", \\"Major\\", 5][0]\\n```\\n\\n### Search bar\\nIt is 100% based on the default input element `InputAutocomplete` with a search function made using `StringMatchQ`. Firstly the string is broken into words and then we count number of matches with the following pattern\\n\\n```mathematica\\nStringMatchQ[scaleWord, ___~~inputWord~~___]\\n```\\n\\n### Circle of Fifth\\nWe built chords from scales and then categorize each using a function `majorQ`. Circle consists of multiple lines and filled clickable pads with polygons made in a funny way\\n\\n```mathematica\\npad2 = With[{\\nc2 = {Cos[ Pi/2 - Pi/12], Sin[ Pi/2 - Pi/12]} // N,\\nc3 = {Cos[1 2Pi/12 + Pi/2 - Pi/12], Sin[1 2Pi/12 + Pi/2 - Pi/12]} //N \\n},\\n  RegionIntersection[RegionDifference[Polygon[{c2 0.1, 1.5 c2, 1.5 c3, c3 0.1}], Disk[{0,0}, 0.25]],\\n    Disk[{0,0}, (0.75+0.5)/2]\\n  ]\\n] // BoundaryDiscretizeRegion // MeshCoordinates // Polygon;\\n\\npad1 = With[{\\nc2 = {Cos[ Pi/2 - Pi/12], Sin[ Pi/2 - Pi/12]} // N,\\nc3 = {Cos[1 2Pi/12 + Pi/2 - Pi/12], Sin[1 2Pi/12 + Pi/2 - Pi/12]} //N \\n},\\n  RegionIntersection[RegionDifference[Polygon[{c2 0.1, 1.5 c2, 1.5 c3, c3 0.1}], Disk[{0,0}, (0.75+0.5)/2]],\\n    Disk[{0,0}, (((0.75 + 1)/2.0) + 1)/2.0]\\n  ]\\n] // BoundaryDiscretizeRegion // MeshCoordinates // Polygon;\\n```\\n\\nthen it is assembled into a circle\\n\\n```mathematica\\ncircleFifth[key_, scale_] := Graphics[{Table[With[{\\n  c1 = {Cos[-i 2Pi/12 + Pi/2], Sin[-i 2Pi/12 + Pi/2]},\\n  c2 = {Cos[-i 2Pi/12 + Pi/2 - Pi/12], Sin[-i 2Pi/12 + Pi/2 - Pi/12]} //N,\\n  chord = makeChord[key, scale, 3][i]\\n}, {\\n\\n  Line[{0.25 c2, c2}],\\n  Text[RomanNumeral[i+1], c1, {0,0}],\\n  \\n  {Opacity[0.3], ColorData[35][i+6], Rotate[If[majorQ[chord], {\\n    EventHandler[pad1, {\\"click\\" -> Function[Null, NoteNormalize[NoteMerge[chord, NoteTranspose[chord, 12]], {12,24+12}] // Sound // EmitSound]}],\\n    Opacity[1], Directive[FontSize->12], Text[semitone[chord[[1,1]]], pad1 // RegionCentroid, {0,0}]\\n  }, {\\n    EventHandler[pad2, {\\"click\\" -> Function[Null, NoteNormalize[NoteMerge[chord, NoteTranspose[chord, 12]], {12, 24+12}] // Sound // EmitSound]}],\\n    Opacity[1], Directive[FontSize->12], Text[semitone[chord[[1,1]]] <> \\"m\\", pad2 // RegionCentroid, {0,0}]\\n  }], i 2 Pi/12, {0,0}]}\\n}], {i, 0,11}],\\n\\nCircle[{0,0}, 0.25],\\nCircle[{0,0}, (0.75+0.5)/2]\\n\\n}, \\"Controls\\"->False, ImageSize->{250,250}]\\n```\\n\\nHere we assigned to each pad a handler, which emits sound on click. For example\\n\\n```mathematica\\ncircleFifth[\\"F\\", \\"Major\\"]\\n```\\n\\n### Piano view\\nThis is bunch of white and black rectangles\\n\\n```mathematica\\nkeyLevels = {0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0};\\ngenerateKeys[keyCount_] := Module[\\n  {index = 1, position = 1, keyWidth, keyOffset},\\n  Table[\\n    With[\\n      {\\n        cycleIndex = Mod[index - 1, 12] + 1,\\n        level = keyLevels[[Mod[index - 1, 12] + 1]]\\n      },\\n      keyWidth = 0.5 - 0.2 level;\\n      keyOffset = 0.5 level;\\n      position += 1 - level;\\n      index++;\\n      Rectangle[\\n        {position - keyWidth + keyOffset, keyOffset},\\n        {position + keyWidth + keyOffset, 1}\\n      ]\\n    ],\\n    {keyCount}\\n  ]\\n];\\n\\nannotateKeys[keys_] := MapIndexed[\\n  Annotation[#, keyLevels[[Mod[#2[[1]] - 1, 12] + 1]], #2[[1]]] &,\\n  keys\\n];\\n\\nhighlightNotes[skeys_, indexes_] := Map[Function[key,\\n  If[MemberQ[indexes, key[[3]]], \\n    {(*VB[*)(RGBColor[1., 0.6862745098039216, 0.47843137254901963])(*,*)(*\\"1:eJxTTMoPSmNkYGAoZgESHvk5KRCeGJAIcndyzs/JLwouTyxJzghJzS3ISSxJTWMGyXMgyRcxgMEH+6JvX0HgqX3R/HkgcM8eAIGmHxI=\\"*)(*]VB*), key}\\n  ,\\n    key\\n  ]\\n], skeys]\\n\\nseparateKeys[keys_] := Module[\\n  {annotatedKeys = annotateKeys[keys]},\\n  {\\n    Cases[annotatedKeys, Annotation[_, 0, _]],\\n    Cases[annotatedKeys, Annotation[_, 1, _]]\\n  }\\n];\\n\\n\\nclicker[scene_, separated_, keys_, additional_:{}, notes_, scale_:False][xy_] := With[{\\n  whiteMatch = SelectFirst[separated[[1]], RegionMember[#[[1]], xy]  &],\\n  blackMatch = SelectFirst[separated[[2]], RegionMember[#[[1]], xy]  &]\\n},\\n\\n  With[{\\n    key = If[!MissingQ[blackMatch], blackMatch[[3]], whiteMatch[[3]]]\\n  },\\n  \\n    If[scale === False, With[{group = FrontInstanceGroup[]}, \\n      \\n      FrontSubmit[NoteTranspose[SoundNote[Join[additional, {key-1}]//DeleteDuplicates], 12] // Sound];\\n      FrontSubmit[{\\n        Red, Text[notes[[Mod[# - 1, 12] + 1]], \\n        Mean[List @@ (keys[[#]])] - {0,0.2}, {0,0}] &/@ Join[(Mod[#, Length[keys]-1] &/@ additional)+1, {key}], \\n        Opacity[0.3], keys[[Join[((Mod[#, Length[keys]-1]) &/@ additional)+1, {key}]]]\\n      } // group, scene];\\n    \\n      SetTimeout[Delete[group], 200];\\n      Return[]\\n    ]];\\n\\n    With[{sorted = Join[additional, {key-1}]//DeleteDuplicates // Sort},\\n      Do[With[{note = sorted[[i]], window = CurrentWindow[]},\\n        SetTimeout[\\n          FrontSubmit[NoteTranspose[SoundNote[note], 12] // Sound, \\"Window\\"->window];\\n          With[{group = FrontInstanceGroup[]},\\n            FrontSubmit[{\\n                    Red, Text[notes[[Mod[# - 1, 12] + 1]], \\n                    Mean[List @@ (keys[[#]])] - {0,0.2}, {0,0}] &/@ Join[(Mod[#, Length[keys]-1] &/@ {note})+1, {key}], \\n                    Opacity[0.3], keys[[Join[((Mod[#, Length[keys]-1]) &/@ {note})+1, {key}]]]\\n            } // group, scene, \\"Window\\"->window];   \\n            SetTimeout[Delete[group], 400];\\n          ];\\n        , (i-1)400 + 10];\\n      ], {i, Length[sorted]}]\\n    ];\\n\\n    \\n  ]\\n]\\n\\n\\nClearAll[PianoView];\\nPianoView[] := PianoView[SoundNote[{}]]\\nPianoView[SoundNote[rawNotes_List], OptionsPattern[]] := Module[{\\n  keys, separated, scene, scaleMode = False,\\n  highlighted, names = {\\"C\\", \\"C#\\", \\"D\\", \\"Eb\\", \\"E\\", \\"F\\", \\"F#\\", \\"G\\", \\"Ab\\", \\"A\\", \\"Bb\\", \\"B\\", \\"C\\"}, annotations,\\n  notes = convertToSemitones @ rawNotes\\n},\\n  keys = generateKeys[OptionValue[\\"Size\\"]];\\n\\n  separated = separateKeys[keys];\\n\\n  scene = FrontInstanceReference[];\\n\\n  highlighted = Mod[#, Length[keys]] + 1 &/@ notes;\\n  annotations = Text[names[[Mod[#, 12]+1]], Mean @ (\\n    List @@ keys[[Mod[#, Length[keys]] + 1]]\\n  ) + {0.,-0.1}, {0,0}] &/@ notes;\\n\\n  notes = Switch[OptionValue[\\"Mode\\"],\\n    \\"Play\\",\\n      notes,\\n\\n    \\"Show\\",\\n      {},\\n\\n    \\"Scale\\",\\n      scaleMode = True; notes,\\n    _,\\n      notes\\n  ];\\n\\n  Graphics[{scene,\\n    {White, EdgeForm[Gray], highlightNotes[separated[[1]], highlighted], Black//Lighter, highlightNotes[separated[[2]],highlighted]},\\n    {Yellow, Opacity[0.3]}, {Black, annotations},\\n  EventHandler[Graphics`Canvas[], {\\"click\\" -> clicker[scene, separated, keys, notes, names, scaleMode]}]\\n  }, ImageSize->OptionValue[ImageSize], \\"Controls\\"->False]\\n]\\n\\nOptions[PianoView] = {ImageSize->{500,200}, \\"Size\\"->25, \\"Mode\\"->\\"Play\\"};\\n```\\n\\nHeres as one can see, we don\'t assign event handlers to individual key, but report the exact coordinates of a click to `clicker`. Then it finds intersections with rectangles and emits sound.\\n\\nFor example\\n\\n```mathematica\\nPianoView[SoundNote[{\\"G5\\", \\"A5\\", \\"B\\" }], \\"Mode\\"->\\"Scale\\"]\\n```\\n\\n### Guitar view\\nThis is a bit tricky, since we have to support custom tunings as well as highlighting all possible ways of making the same note using different positions on the fingerboard\\n\\n```mathematica\\nplucker[scene_, board_, highlighted_, additional_, scaleQ_][xy_] := With[{\\n  match = SelectFirst[board//Values//Flatten, With[{reg = Disk[#[[1,1]], #[[1,2]] * 2] },\\n    RegionMember[reg, xy]\\n  ]&]\\n},\\n  If[MissingQ[match], Return[]];\\n  With[{\\n    notes = Sort[Join[additional, {match[[2]]}]//DeleteDuplicates],\\n    client = CurrentWindow[]\\n  },\\n\\n    If[scaleQ,\\n      MapIndexed[Function[{val, index},\\n        SetTimeout[With[{group = FrontInstanceGroup[]},\\n        \\n          FrontSubmit[SoundNote[val, \\"8n\\"] // Sound, \\"Window\\"->client];\\n          FrontSubmit[{\\n            Opacity[0.7], highlighted[{val}, Red]\\n          } // group, scene, \\"Window\\"->client];\\n  \\n          SetTimeout[Delete[group], 450]; \\n          \\n        ], 450 * (index[[1]]-1) + 1]\\n      ], notes];   \\n    ,\\n      With[{group = FrontInstanceGroup[]},\\n        FrontSubmit[SoundNote[notes] // Sound];\\n        FrontSubmit[{\\n          Opacity[0.7], highlighted[notes]\\n        } // group, scene];\\n  \\n        SetTimeout[Delete[group], 200];   \\n      ]\\n    ]\\n  ]  \\n]\\n\\n\\nGuitarView[SoundNote[rawNotes_List], OptionsPattern[]] := Module[{\\n  tuning = convertToSemitones @ OptionValue[\\"Tuning\\"],\\n  scene = FrontInstanceReference[],\\n  scaleQ = False,\\n names = {\\"C\\", \\"C#\\", \\"D\\", \\"Eb\\", \\"E\\", \\"F\\", \\"F#\\", \\"G\\", \\"Ab\\", \\"A\\", \\"Bb\\", \\"B\\", \\"C\\"}, annotations,\\n  notes = convertToSemitones @ rawNotes,\\n  board, highlighted,\\n  semitoneTuning = Reverse[convertToSemitones @ OptionValue[\\"Tuning\\"]]\\n},\\n\\nnotes = Switch[OptionValue[\\"Mode\\"],\\n    \\"Play\\",\\n      notes,\\n\\n    \\"Show\\",\\n      {},\\n\\n    \\"Scale\\",\\n      scaleQ = True;\\n      notes,\\n\\n    _,\\n      notes\\n  ];\\n\\nnotes = With[{c = Mod[#, convertToSemitones @ (semitoneTuning[[-1]] + 12)]},\\n  If[c < semitoneTuning[[1]],\\n    c + 12\\n  ,\\n    c\\n  ]\\n] &/@ notes;\\n\\nboard = GroupBy[Flatten[\\n  Table[With[{note = semitoneTuning[[y]] + x},\\n    Annotation[Disk[{x,y}, {0.15, 0.15 2.8 }], note, names[[Mod[note, 12]+1]]]\\n  ], {x, 0, 12}, {y, Length[tuning]}]\\n], #[[2]] &];\\n\\nhighlighted[notes_, color_:Automatic] := {\\n  If[color === Automatic, ColorData[97], color&] /@ Range[notes // Length],\\n  Map[Function[place, \\n    If[place[[1,1,1]] > 0.5,\\n      {place, White, Text[place[[3]] , place[[1,1]]- {0,0.16}, {0,-1}]}\\n    ,\\n      place\\n    ]\\n  ], board[#]] &/@ notes\\n}//Transpose;\\n\\nGraphics[{\\n  scene, EventHandler[Graphics`Canvas[], {\\"click\\"->plucker[scene, board, highlighted, notes, scaleQ]}],\\n  Table[Line[{{0, string}, {12, string}}], {string, Length[tuning]}],\\n  Table[Line[{{i - 0.5, 1 - 0.2 }, {i - 0.5, Length[tuning] + 0.2}}], {i, 12}],\\n  Table[Text[semitone[tuning[[Length[tuning] + 1 - string]]], {-0.4, string - 0.2}, {-1,-1}], {string, Length[tuning]}],\\n  {\\n    AbsoluteThickness[4], Line[{{0.5, 1}, {0.5, Length[tuning]}}], \\n    Gray, Table[Disk[{0.5 + 2.5 + k, 0.3}, {0.15, 0.15 2.8 }/2], {k, 0, 6, 2}],\\n    Disk[{0.5 + 2.5 + 8.9, 0.3}, {0.15, 0.15 2.8 }/2], Disk[{0.5 + 2.5 + 9.1, 0.3}, {0.15, 0.15 2.8 }/2]\\n  },\\n  \\n  highlighted[notes]\\n  \\n}, ImageSize->OptionValue[ImageSize], \\"Controls\\"->False, ImagePadding->None, PlotRange->{{0 - 0.5, 12 + 0.5}, {0, Length[tuning] + .5}}]\\n]\\n\\nOptions[GuitarView] = {\\"Tuning\\"->({\\"E4\\", \\"A4\\", \\"D5\\", \\"G5\\", \\"B5\\", \\"E6\\"}//Reverse), \\"Mode\\"->\\"Play\\", ImageSize->(1.2 {500,100})}\\n```\\n\\nThe idea with emitting sound is the same as for piano. For example\\n\\n```mathematica\\nGuitarView[SoundNote[{\\"E4\\", \\"G5\\", \\"B4\\"}], \\"Mode\\"->\\"Scale\\"]\\n```\\n\\n### Navigation between windows\\nIt is done in the most basic way - by calling `CellPrint` with target `_`. To give more freedom to the customization of UI look we mostly use WLX to make a layout we pass the generated template directly to `CellPrint` and call it an option `\\"Display\\"->\\"wlx\\"`. In this way it bypasses all cell-specific decorations and renders a raw HTML in the window (no blinking cursor or other attributes of the notebook cells)."},{"id":"/2024/12/19/Units","metadata":{"permalink":"/wljs-docs/widgets/2024/12/19/Units","source":"@site/widgets/2024-12-19-Units/index.md","title":"Optics units converter","description":"There are many physical units converters on the internet. Here we made one for our optics THz lab in University of Augsburg \ud83c\udde9\ud83c\uddea","date":"2024-12-19T00:00:00.000Z","tags":[],"readingTime":2.665,"hasTruncateMarker":true,"authors":[],"frontMatter":{},"unlisted":false,"prevItem":{"title":"Musical scales and chords maker","permalink":"/wljs-docs/widgets/2025/01/06/MusicScales"}},"content":"There are many physical units converters on the internet. Here we made one for our optics THz lab in University of Augsburg \ud83c\udde9\ud83c\uddea\\n\\n![](./../Pasted%20image%2020250106142127.png)\\n\\n__Features__\\nBidirectional convertion between\\n\\n- Energy units (ev, cm, Hartree...)\\n- Wavelengths\\n- Frequency\\n- Temperature\\n- Magnetic fields\\n\\n<a\\n  href={ require(\'./Units Converter.wlw\').default }\\n  className=\\"p-2 text-sm font-medium w-full flex ring-1 ring-inset text-gray-600 shadow ring-gray-300 bg-gray-300 my-2\\"\\n>\\n  Download App v.02\\n  <svg\\n    xmlns=\\"http://www.w3.org/2000/svg\\"\\n    fill=\\"none\\"\\n    className=\\"w-5 h-5 ml-auto\\"\\n    viewBox=\\"0 0 24 24\\"\\n  >\\n    <path\\n      stroke=\\"currentColor\\"\\n      strokeLinecap=\\"round\\"\\n      strokeLinejoin=\\"round\\"\\n      d=\\"M17 17h.01m.39-3h.6c.932 0 1.398 0 1.765.152a2 2 0 0 1 1.083 1.083C21 15.602 21 16.068 21 17s0 1.398-.152 1.765a2 2 0 0 1-1.083 1.083C19.398 20 18.932 20 18 20H6c-.932 0-1.398 0-1.765-.152a2 2 0 0 1-1.083-1.083C3 18.398 3 17.932 3 17s0-1.398.152-1.765a2 2 0 0 1 1.083-1.083C4.602 14 5.068 14 6 14h.6m5.4 1V4m0 11-3-3m3 3 3-3\\"\\n    ></path>\\n  </svg>\\n</a>\\n\\n\x3c!--truncate--\x3e\\n\\n:::note\\nFor magnetic field units we assume spin 1/2\\n:::\\n\\n## How it works\\nAs a base we define a general transformation rules for units as follows\\n\\n```mathematica @\\nrules = {\\n  \\"Centimeters\\" -> \\"Centimeters\\",\\n  \\"eV\\" -> \\"Centimeters\\" / 8065.6,\\n  \\"meV\\" -> 1000 \\"Centimeters\\" / 8065.6,\\n  \\"Micrometers\\" -> 10000 / \\"Centimeters\\",\\n  \\"Nanometers\\" -> (*SpB[*)Power[10(*|*),(*|*)7](*]SpB*) / \\"Centimeters\\",\\n  \\"Angstrem\\" -> (*SpB[*)Power[10(*|*),(*|*)8](*]SpB*) / \\"Centimeters\\",\\n  \\"MHz\\" -> (*SpB[*)Power[10(*|*),(*|*)4](*]SpB*) 2.9979 \\"Centimeters\\",\\n  \\"GHz\\" -> (*SpB[*)Power[10(*|*),(*|*)4](*]SpB*) 2.9979 \\"Centimeters\\" 0.001,\\n  \\"THz\\" -> (*SpB[*)Power[10(*|*),(*|*)4](*]SpB*) 2.9979 \\"Centimeters\\" 0.001 0.001,\\n  \\"K\\" -> 1.428 \\"Centimeters\\",\\n\\n  \\"ps\\" -> 0.004136 / (\\"Centimeters\\" / 8065.6),\\n\\n  \\n  \\"T\\" -> 4.26602  \\"Centimeters\\",\\n  \\"Oe\\" -> 10000 4.26602  \\"Centimeters\\",\\n  \\n  \\"kJ/Mol\\" -> 0.0120 \\"Centimeters\\",\\n  \\"Hartree\\" ->   \\"Centimeters\\" / (27.2114 8065.6)\\n};\\n```\\n\\nThen one can naturally use `NSolve` to get this or that unit. \\n\\n:::tip\\nChange the extension to `wln` to see the source code\\n:::\\n\\nFor the inputs we designed a custom input element using WLX and JS following [this guide](https://jerryi.github.io/wljs-docs/frontend/Advanced/Javascript/Communication#using-wlx--2-ways-binding)\\n\\n```jsx\\n.wlx\\n\\nCustomInput[sym_, OptionsPattern[]] := Module[{\\n  Label = OptionValue[\\"Label\\"],\\n  Ev = OptionValue[\\"Event\\"],\\n  Pattern = OptionValue[\\"Pattern\\"],\\n  Handler\\n},\\n\\n  With[{Template = \\n    <div class=\\"mt-2 flex\\">\\n      <div style=\\"width: 7rem\\" class=\\"flex shrink-0 items-center rounded-l-md bg-white px-3 text-base text-gray-500 outline outline-1 -outline-offset-1 outline-gray-300 sm:text-sm/6\\"><Label/></div>\\n      <input type=\\"number\\" step=\\"1\\" class=\\"-ml-px block w-full grow rounded-r-md bg-white px-3 py-1.5 text-base text-gray-900 outline outline-1 -outline-offset-1 outline-gray-300 placeholder:text-gray-400 focus:outline focus:outline-2 focus:-outline-offset-2 focus:outline-indigo-600 sm:text-sm/6\\" placeholder=\\"0.0\\"/>\\n    <script type=\\"module\\">\\n      core[\'<Handler/>\'] = async (args, env) => {\\n        const input = env.element.getElementsByTagName(\'input\')[0];\\n\\n\\n        const data = await interpretate(args[0], env);\\n        input.value = +data.toFixed(4);\\n        env.local.input = input;\\n\\n        input.addEventListener(\'change\', () => {\\n          \\n          console.warn(input.value);\\n          env.local.skip = true;\\n          server.kernel.emitt(\'<Ev/>\', input.value, \'<Pattern/>\');\\n        });        \\n      }\\n\\n      core[\'<Handler/>\'].update = async (args, env) => {\\n        if (env.local.skip) {\\n          env.local.skip = false;\\n          return;\\n        }\\n        \\n        console.log(\'Update\');\\n        env.local.input.value = +(await interpretate(args[0], env)).toFixed(4);\\n      }\\n\\n      core[\'<Handler/>\'].destroy = () => {\\n        delete core[\'<Handler/>\'];\\n      }\\n\\n      core[\'<Handler/>\'].virtual = true;\\n    <\/script>\\n  </div>\\n  },\\n    HTMLView[Template, Epilog->(Handler[sym])]\\n  ]\\n]\\n\\nOptions[CustomInput] = {\\"Label\\"->\\"\\", \\"Event\\"->\\"\\", \\"Pattern\\"->\\"Default\\"};\\n```\\nwhat happens here:\\n\\n1. we define a template for our custom input field\\n2. we define a support script with a generated\xa0`Handler`\xa0function, which reads and updates this input field\\n3. we pack in into\xa0[HTMLView](https://jerryi.github.io/wljs-docs/frontend/Reference/GUI/HTMLView), which calls our\xa0`Handler`\xa0on a provided argument after this component has been mounted\\n\\nFor example\\n\\n```mathematica @\\nvalues = {1,1};\\n\\nevent = CreateUUID[];\\n\\nEventHandler[event, {\\n  \\"x\\" -> Function[val,\\n    values = {val, (*SpB[*)Power[val(*|*),(*|*)2](*]SpB*)} // N;\\n  ],\\n\\n  \\"x2\\" -> Function[val,\\n    values = {(*SqB[*)Sqrt[val](*]SqB*), val} // N // Re;\\n  ]\\n}]\\n\\n{\\n  CustomInput[values[[1]] // Offload, \\"Event\\"->event, \\"Pattern\\"->\\"x\\", \\"Label\\"->\\"x\\"],\\n  CustomInput[values[[2]] // Offload, \\"Event\\"->event, \\"Pattern\\"->\\"x2\\", \\"Label\\"->\\"x<sup>2</sup>\\"]\\n} // Column\\n```\\n\\n![](./../fields-ezgif.com-video-to-gif-converter-553959e2d416c2aa4cc82261b90aa3f0.gif)"}]}}')}}]);