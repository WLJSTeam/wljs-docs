"use strict";(self.webpackChunkwlx_docs=self.webpackChunkwlx_docs||[]).push([[9073],{28453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>s});var a=t(96540);const r={},i=a.createContext(r);function o(e){const n=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),a.createElement(i.Provider,{value:n},e.children)}},30082:(e,n,t)=>{t.d(n,{A:()=>a});const a=t.p+"assets/images/Screenshot 2025-02-12 at 19.25.50-62f0274caa243e81daf804ab2031b7f4.png"},85594:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var a=t(74848),r=t(28453);const i={sidebar_position:3},o=void 0,s={id:"frontend/Development/Plugins/Examples/New cell type and Kernel evaluation",title:"New cell type and Kernel evaluation",description:"A ready to-go example is in this repository, Clone it to /wljs-notebook/wljs_packages",source:"@site/docs/frontend/Development/Plugins/Examples/New cell type and Kernel evaluation.md",sourceDirName:"frontend/Development/Plugins/Examples",slug:"/frontend/Development/Plugins/Examples/New cell type and Kernel evaluation",permalink:"/frontend/Development/Plugins/Examples/New cell type and Kernel evaluation",draft:!1,unlisted:!1,tags:[],version:"current",lastUpdatedAt:173971315e4,sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Action Button in UI and Cell Evaluation",permalink:"/frontend/Development/Plugins/Examples/Action Button in UI and Cell Evaluation"},next:{title:"Rendering Composition",permalink:"/frontend/Development/Rendering composition"}},l={},c=[{value:"Preparations",id:"preparations",level:2},{value:"Main kernel package",id:"main-kernel-package",level:2},{value:"Evaluation kernel package",id:"evaluation-kernel-package",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(n.admonition,{type:"info",children:[(0,a.jsxs)(n.p,{children:["A ready to-go example is in ",(0,a.jsx)(n.a,{href:"https://github.com/JerryI/wljs-plugin-example-3",children:"this repository"}),", Clone it to ",(0,a.jsx)(n.code,{children:"<AppData>/wljs-notebook/wljs_packages"})]}),(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"git clone https://github.com/JerryI/wljs-plugin-example-3\n"})}),(0,a.jsx)(n.p,{children:"and restart WLJS Notebook"})]}),"\n",(0,a.jsxs)(n.p,{children:["In this tutorial we will add new cell type, which implements basic Wolfram expression evaluation and returns the result in ",(0,a.jsx)(n.a,{href:"/frontend/Reference/Formatting/InputForm",children:"InputForm"}),". Our new cell type will start from a simple"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-mathematica",children:".m\nRed\n"})}),"\n",(0,a.jsx)(n.p,{children:"to avoid conflicts with a default wolfram language input."}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Summary"})," what will be done"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["package for ",(0,a.jsx)(n.em,{children:"main kernel"}),", which implement a new evaluator"]}),"\n",(0,a.jsx)(n.li,{children:"working with kernel transactions"}),"\n",(0,a.jsxs)(n.li,{children:["loading packages on-demand to ",(0,a.jsx)(n.em,{children:"evaluation kernel"})]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"preparations",children:"Preparations"}),"\n",(0,a.jsxs)(n.p,{children:["Use ",(0,a.jsx)(n.a,{href:"https://github.com/JerryI/wljs-plugin-template",children:"wljs-plugin-template"})," template and create a new repository. Then clone new repository to ",(0,a.jsx)(n.code,{children:"<AppData>/wljs-notebook/wljs_packages"})," folder. For example"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"git clone https://github.com/JerryI/wljs-plugin-example-3\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Then edit the content of ",(0,a.jsx)(n.code,{children:"package.json"})]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-json",metastring:'title="package.json"',children:'{\n    "name": "wljs-plugin-example-3",\n    "version": "0.0.1",\n    "description": "An example plugin for WLJS Notebook",\n    "wljs-meta": {\n        "frontend": [\n            "src/Frontend.wl"\n        ],\n        "priority": 5000,\n        "category": "Notebook Extensions"\n    },\n    "repository": {\n        "type": "git",\n        "url": "https://github.com/JerryI/wljs-plugin-example-3"\n    }\n}\n'})}),"\n",(0,a.jsxs)(n.p,{children:["In principle we need ",(0,a.jsx)(n.code,{children:".wl"})," files for both ",(0,a.jsx)(n.em,{children:"main kernel"})," and ",(0,a.jsx)(n.em,{children:"evaluation kernel"}),". However, the last one we can defer and load only when a user firstly evaluates our new cell type. This will reduce the total loading time of a new evaluation kernel."]}),"\n",(0,a.jsx)(n.h2,{id:"main-kernel-package",children:"Main kernel package"}),"\n",(0,a.jsx)(n.p,{children:"Let's define our package and include the necessary libraries"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-mathematica",metastring:'title="src/Frontend.wl"',children:'BeginPackage["CoffeeLiqueur`Extensions`BasicEval`", {\n    "CoffeeLiqueur`Notebook`Transactions`",\n    "CodeParser`"\n}]\n\nNeeds["CoffeeLiqueur`Notebook`Kernel`" -> "GenericKernel`"];\nNeeds["CoffeeLiqueur`Notebook`Evaluator`" -> "StandardEvaluator`"];\n\nBegin["`Private`"]\n\n\n\nEnd[]\nEndPackage[]\n'})}),"\n",(0,a.jsx)(n.p,{children:"Here we import a few important contexts"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-mathematica",children:"CoffeeLiqueur`Notebook`Transactions`\n"})}),"\n",(0,a.jsxs)(n.p,{children:["provides ",(0,a.jsx)(n.code,{children:"Transaction[]"})," constructor. Evaluation of any content is done via such objects, which contain the evaluation data and meta-data and abstracted from the actual cells. ",(0,a.jsx)(n.code,{children:"CodeParser"})," we need for syntax check of our expressions before the evaluation."]}),"\n",(0,a.jsx)(n.p,{children:"The rest two"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-mathematica",children:"CoffeeLiqueur`Notebook`Kernel`\nCoffeeLiqueur`Notebook`Evaluator`\n"})}),"\n",(0,a.jsxs)(n.p,{children:["we need for submitting transactions to evaluation kernels, while the last one defines an abstract class for ",(0,a.jsx)(n.em,{children:"evaluator"}),". For each cell type one can define an ",(0,a.jsx)(n.em,{children:"evaluator"}),", which is applied and perform the evaluation of the transaction based on the pattern matching."]}),"\n",(0,a.jsxs)(n.p,{children:["Here is how we can do that for our ",(0,a.jsx)(n.code,{children:".m"})," cells"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-mathematica",children:'Q[t_Transaction] := StringMatchQ[t["Data"], ".m\\n"~~___]\n\nevaluator  = StandardEvaluator`StandardEvaluator["Name" -> "Basic InputForm Evaluator", "Pattern" -> (_?Q), "Priority"->(2)];\n'})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"Q"})," function simply checks the content of the transaction for our notation. Now we can define the necessary methods for our ",(0,a.jsx)(n.code,{children:"evaluator"})]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-mathematica",children:'StandardEvaluator`ReadyQ[evaluator, k_] := (\n    If[! TrueQ[k["ReadyQ"] ] || ! TrueQ[k["ContainerReadyQ"] ],\n        EventFire[t, "Error", "Kernel is not ready"];\n        Print[evaluator, "Kernel is not ready"];\n        False\n    ,\n        True\n    ]\n);\n'})}),"\n",(0,a.jsxs)(n.p,{children:["This one checks if kernel is ready. The evaluation itself is abstracted from kernels. Some of cell types do not involve ",(0,a.jsx)(n.em,{children:"evaluation kernel"})," at all: ",(0,a.jsx)(n.a,{href:"/frontend/Cell%20types/Javascript",children:"Javascript"}),", ",(0,a.jsx)(n.a,{href:"/frontend/Cell%20types/Many%20more#Shell",children:"Shell"}),", ",(0,a.jsx)(n.a,{href:"/frontend/Cell%20types/Many%20more#Mermaid",children:"Mermaid"}),". That is the reason, we have those checks on the level of evaluators."]}),"\n",(0,a.jsx)(n.p,{children:"The second mandatory method is actual evaluation"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-mathematica",children:'StandardEvaluator`EvaluateTransaction[evaluator, k_, t_] := Module[{list},\n     t["Data"] = StringDrop[t["Data"], 3];\n\n     If[StringLength[StringTrim[t["Data"] ] ] === 0,\n        EventFire[t, "Error", "No input"];\n        Echo["Syntax Error!"];\n        Return[$Failed];\n     ];\n\n     With[{check = CheckSyntax[t["Data"] ]},\n        If[! TrueQ[check],\n            EventFire[t, "Error", check];\n            Echo["Syntax Error!"];\n            Return[$Failed];\n        ];\n\n        list = SplitExpression[t["Data"] ];\n        \n        MapIndexed[\n            With[{message = StringTrim[#1], index = #2[[1]], transaction = Transaction[]},\n                If[StringTake[message, -1] === ";", \n                    transaction["Nooutput"] = True;\n                    transaction["Data"] = StringDrop[message, -1];\n                ,\n                    transaction["Data"] = message;\n                ];\n                \n                transaction["Evaluator"] = Internal`Kernel`BasicEval;\n                \n                (* check if it is the last one *)\n                If[index === Length[list],\n                    EventHandler[transaction, {\n                        (* capture successfull event of the last transaction to end the process *)  \n                        "Result" -> Function[data, \n                            EventFire[t, "Result", data];\n                            EventFire[t, "Finished", True];\n                        ],\n                        (* fwd the rest *)\n                        name_ :> Function[data, EventFire[t, name, data] ]\n                    }];          \n                ,\n                    EventHandler[transaction, {\n                        name_ :> Function[data, EventFire[t, name, data] ]\n                    }];                \n                ];\n\n                Print[evaluator, "Submit transaction!"];\n                GenericKernel`SubmitTransaction[k, transaction];\n            ]&\n        ,  list];\n    ];      \n];  \n'})}),"\n",(0,a.jsx)(n.p,{children:"Many things happen. First we check the syntax of the provided transaction data, then split a multiple lines of expressions to separate transactions aka"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-wolfram",children:"1+1\n(* <- break *)\n2+2\n"})}),"\n",(0,a.jsx)(n.p,{children:"We assign for each new transaction an evaluation function"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-mathematica",children:"Internal`Kernel`BasicEval\n"})}),"\n",(0,a.jsxs)(n.p,{children:["that will be called on the ",(0,a.jsx)(n.em,{children:"evaluation kernel"})," on the given transaction. We will define it later. Transaction objects have defined up-values for event-system methods. It means you can listen and fire events on them. After the line"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"GenericKernel`SubmitTransaction[k, transaction];\n"})}),"\n",(0,a.jsxs)(n.p,{children:["a transaction goes to ",(0,a.jsx)(n.em,{children:"evaluation kernel"})," and depending on evaluation function and the content 2 event patterns can usually be emitted"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:'"Result"'})," evaluation has been finished and the result is provided in payload"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:'"Error"'})," an error occurred"]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["However your initial transaction object you receive as a method's argument ",(0,a.jsx)(n.code,{children:"t"})," has ",(0,a.jsx)(n.strong,{children:"one more pattern"})]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:'"Finished"'})," indicates that the evaluation is fully complete. Must be fired after all possible ",(0,a.jsx)(n.code,{children:'"Result"'})," events"]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["This one ensures, that all extra steps are done (if the expression was split into multiple transactions) and a cell or other handler can change its state to ",(0,a.jsx)(n.code,{children:"idle"}),"."]}),"\n",(0,a.jsx)(n.p,{children:"The remaining functions for syntax check and splitting are"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-mathematica",children:'SplitExpression[str_] := With[{},\n  Select[Select[(StringTake[str, Partition[Join[{1}, #, {StringLength[str]}], 2]] &@\n   Flatten[{#1 - 1, #2 + 1} & @@@ \n     Sort@\n      Cases[\n       CodeParser`CodeConcreteParse[str, \n         CodeParser`SourceConvention -> "SourceCharacterIndex"][[2]], \n       LeafNode[Token`Newline, _, a_] :> Lookup[a, Source, Nothing]]]), StringQ], (StringLength[#]>0) &]\n];\n\nCheckSyntax[str_String] := \n    Module[{syntaxErrors = Cases[CodeParser`CodeParse[str],(ErrorNode|AbstractSyntaxErrorNode|UnterminatedGroupNode|UnterminatedCallNode)[___],Infinity]},\n        If[Length[syntaxErrors]=!=0 ,\n            \n\n            Return[StringRiffle[\n                TemplateApply["Syntax error `` at line `` column ``",\n                    {ToString[#1],Sequence@@#3[CodeParser`Source][[1]]}\n                ]&@@@syntaxErrors\n\n            , "\\n"], Module];\n        ];\n        Return[True, Module];\n    ];\n'})}),"\n",(0,a.jsx)(n.h2,{id:"evaluation-kernel-package",children:"Evaluation kernel package"}),"\n",(0,a.jsx)(n.p,{children:"This package file implements the missing evaluation function"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-mathematica",metastring:'title="src/Preload.wl"',children:'BeginPackage["CoffeeLiqueur`Extensions`BasicEval`", {\n    "JerryI`Misc`Events`"\n}]\n\nBegin["`Private`"]\n\nInternal`Kernel`BasicEval = Function[t, \n    With[{hash = CreateUUID[]},\n        With[{result = (ToExpression[ t["Data"], InputForm, Hold]) // ReleaseHold },\n            If[KeyExistsQ[t, "Nooutput"],\n                EventFire[Internal`Kernel`Stdout[ t["Hash"] ], "Result", <|"Data" -> Null |> ];\n            ,   \n                With[{string = ToString[result, InputForm]},\n                    EventFire[Internal`Kernel`Stdout[ t["Hash"] ], "Result", <|"Data" -> string, "Display"->"codemirror", "Meta"->Sequence["Hash"->hash] |> ];\n                ]\n            ];\n        ];\n    ] \n];\n\nEnd[]\nEndPackage[]\n'})}),"\n",(0,a.jsxs)(n.p,{children:["There is nothing special here. We accept the transaction in a form of ",(0,a.jsx)(n.code,{children:"Association"})," (the serialization of transaction object) and apply ",(0,a.jsx)(n.code,{children:"ToExpression"})," almost directly."]}),"\n",(0,a.jsxs)(n.p,{children:["The result is then sent using event interface with an additional wrapper symbol ",(0,a.jsx)(n.code,{children:"Stdout"})," which indicates, that the it has to be fired to a remote Wolfram Kernel. In the payload a meta data regarding the output cell type and display function is shared.  Display functions are pre-defined on Javascript side."]}),"\n",(0,a.jsxs)(n.p,{children:["As a rule, if it is possible to defer the loading of some package, you shout do it. This exactly this case, we can load ",(0,a.jsx)(n.code,{children:"src/Preload.wl"})," only when our cell is about to be sent for the evaluation. For that reason we can extend ",(0,a.jsx)(n.code,{children:"ReadyQ"})," method, which is called before the evaluation"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-mathematica",children:'rootFolder = $InputFileName // DirectoryName // ParentDirectory;\npreload = Import[FileNameJoin[{rootFolder, "src", "Preload.wl"}], "Text"];\n\nStandardEvaluator`ReadyQ[evaluator, k_] := (\n    If[! TrueQ[k["ReadyQ"] ] || ! TrueQ[k["ContainerReadyQ"] ],\n        EventFire[t, "Error", "Kernel is not ready"];\n        Print[evaluator, "Kernel is not ready"];\n        False\n    ,\n\n        Print[evaluator, "Preload"];\n\n        With[{preload = preload},\n            GenericKernel`Init[k, \n                ImportString[preload, "WL"]\n            , "Once"->True];\n        ];\n\n        True\n    ]\n);\n'})}),"\n",(0,a.jsx)(n.admonition,{type:"note",children:(0,a.jsx)(n.p,{children:"It is also possible to define a custom display function in Javascript for your new cell type (both: input and output), but this is a topic for the next tutorial."})}),"\n",(0,a.jsxs)(n.p,{children:["Now restart WLJS Notebook and enjoy pure ",(0,a.jsx)(n.a,{href:"/frontend/Reference/Formatting/InputForm",children:"InputForm"})]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{src:t(30082).A+"",width:"1588",height:"598"})}),"\n",(0,a.jsx)(n.admonition,{type:"tip",children:(0,a.jsxs)(n.p,{children:["Full source code can be found in ",(0,a.jsx)(n.a,{href:"https://github.com/JerryI/wljs-plugin-example-3",children:"this repository"})]})})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}}}]);