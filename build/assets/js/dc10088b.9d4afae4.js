"use strict";(self.webpackChunkwlx_docs=self.webpackChunkwlx_docs||[]).push([[37017],{28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>a});var i=t(96540);const s={},o=i.createContext(s);function r(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(o.Provider,{value:n},e.children)}},50698:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/Screenshot 2024-09-25 at 15.37.02-1f3e50579733f2a8543b3a9180612cc2.png"},78773:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>a,toc:()=>d});var i=t(74848),s=t(28453);const o={draft:!1,sidebar_position:1},r="Components",a={id:"frontend/Advanced/Slides/Building components",title:"Components",description:"See the collection of components in the Components library",source:"@site/docs/frontend/Advanced/Slides/Building components.md",sourceDirName:"frontend/Advanced/Slides",slug:"/frontend/Advanced/Slides/Building components",permalink:"/frontend/Advanced/Slides/Building components",draft:!1,unlisted:!1,tags:[],version:"current",lastUpdatedAt:1743612956e3,sidebarPosition:1,frontMatter:{draft:!1,sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Slides",permalink:"/frontend/Advanced/Slides/"},next:{title:"Widgets on slides",permalink:"/frontend/Advanced/Slides/Widgets on slides"}},l={},d=[{value:"Decorators",id:"decorators",level:2},{value:"Layout Helpers",id:"layout-helpers",level:2}];function c(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",img:"img",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"components",children:"Components"}),"\n",(0,i.jsx)(n.admonition,{type:"info",children:(0,i.jsxs)(n.p,{children:["See the collection of components in the ",(0,i.jsx)(n.a,{href:"/frontend/Advanced/Components%20library/QR%20Code",children:"Components library"})]})}),"\n",(0,i.jsx)(n.p,{children:"Creating presentations is a repetitive process. It is quite common to have some elements shared between different slides."}),"\n",(0,i.jsxs)(n.p,{children:["To overcome this small issue, one can use the ",(0,i.jsx)(n.a,{href:"/frontend/Cell%20types/WLX",children:"WLX"})," language to define a heading, for instance:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:'.wlx\nHeading[OptionsPattern[]] := With[{Title = OptionValue["Title"]},\n  <dummy>\n    <h1><Title/></h1>\n    Some repetitive text you need\n  </dummy>\n] \n\nOptions[Heading] = {"Title" -> "Nope"}\n'})}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.a,{href:"/frontend/Cell%20types/WLX",children:"WLX"})," always requires a single parent element if you define a function using XML tags. Use ",(0,i.jsx)(n.code,{children:"<dummy>"})," or ",(0,i.jsx)(n.code,{children:"<div>"})," to wrap them."]})}),"\n",(0,i.jsx)(n.p,{children:"You can then use it on your slides as if it were a normal tag:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:'.slide\n\n<Heading title={"Some title"}/>\n\n<br/><br/>\n\nThe actual content\n\nMaybe some equations $m \\\\mathbf{a} = \\\\mathbf{F}$\n'})}),"\n",(0,i.jsx)(n.p,{children:"Unfortunately, it is tricky to use standard Markdown inside components, because it requires carriage returns between XML/HTML and Markdown tags, which are trimmed by default. However, for equations, it still works:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:'.wlx\n\nHeading[OptionsPattern[]] := With[{Title = OptionValue["Title"]},\n  <dummy>\n    <h1><Title/></h1>\n    Some repetitive text you need\n    Here is a random equation $x^2 + y^2 + z^2 = r^2$\n  </dummy>\n] \n\nOptions[Heading] = {"Title" -> "Nope"}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"decorators",children:"Decorators"}),"\n",(0,i.jsxs)(n.p,{children:["Decorators with ",(0,i.jsx)(n.a,{href:"/frontend/Reference/Formatting/WLXForm",children:"WLXForm"}),", such as ",(0,i.jsx)(n.a,{href:"frontend/Reference/Formatting/Row",children:"Row"})," and ",(0,i.jsx)(n.a,{href:"/frontend/Reference/Formatting/Column",children:"Column"}),", can be used on slides natively. ",(0,i.jsx)(n.a,{href:"/frontend/Reference/Plotting%20Functions/ManipulatePlot",children:"ManipulatePlot"})," is also a combination of those, which makes it possible to output it directly without using ",(0,i.jsx)(n.a,{href:"/frontend/Reference/GUI/EditorView",children:"EditorView"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-mathematica",metastring:'title="cell 1"',children:'Figure = Plot[x, {x, 0, 1}];\nEditor = EditorView["Plot[x, {x, 0, 1}] -> "];\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-html",metastring:'title="cell 2"',children:".slide\n\n<Row>\n\t<Editor/>\n\t<Figure/>\n</Row>\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{src:t(50698).A+"",width:"1144",height:"486"})}),"\n",(0,i.jsx)(n.h2,{id:"layout-helpers",children:"Layout Helpers"}),"\n",(0,i.jsx)(n.p,{children:"This is a common case where components come in handy. Imagine a typical situation where we need to organize columns in a presentation:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:'.wlx\n\nColumns[cols__] := With[{width = 99 / (List[cols] // Length) // Floor},\n\n  With[{Layout = Table[\n    <div style="width: {width}%">\n      <Col/>\n    </div>  \n   , {Col, List[cols]}]\n  },\n\n    <div style="display:flex">\n      <Layout/> \n    </div>\n  ]\n  \n]\n'})}),"\n",(0,i.jsx)(n.p,{children:"Here we first calculate the width of each column based on their number, and then use standard HTML with CSS to style them."}),"\n",(0,i.jsxs)(n.p,{children:["Since the input argument is not typed, you can use nested tags or WL expressions as content for each column. Here's one of the slides from ",(0,i.jsx)(n.a,{href:"https://github.com/JerryI",children:"@JerryI"}),"'s presentation at a recent 2023 talk:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:'.slide\n\n# Different ways of calculating properties for magnetic materials\n\n<br/><br/>\n\n<Columns>\n  <p style="text-align:left">\n\n## DFT+U\nDFT with Coulomb repulsion between sites allows modeling of localized magnetic moments\n    \n- lacks ~1 cm$^{-1}$ accuracy\n- slow and time-consuming\n- hard to control intermediate steps\n- feels like working with a "black box"\n    \n  </p>\n  <p style="text-align:left">\n\n## Effective Hamiltonians\nSpin Hamiltonian, Heisenberg, etc... randomly picked\n    \n- not consistent (completely different from compound to compound)\n- overparameterized\n    \n  </p>\n  <p style="text-align:left">\n\n## Microscopic theory \x3c!-- .element: class="fragment highlight-red" data-fragment-index="1" --\x3e\nBuilds energy levels step-by-step from the isolated ion, considering crystal structure and interactions \x3c!-- .element: class="fragment highlight-red" data-fragment-index="1" --\x3e\n    \n- considered outdated\n- ~~requires a lot of calculations~~\n- hard to treat collective excitations\n\n<span style="color:red">Use Computer Algebra!</span> \x3c!-- .element: class="fragment" data-fragment-index="1" --\x3e\n    \n  </p>\n</Columns>\n'})}),"\n",(0,i.jsxs)(n.p,{children:["As you can see, this is again a mixture of HTML/XML and Markdown. Each tag inside ",(0,i.jsx)(n.code,{children:"<Columns>"})," is treated as a separate argument."]}),"\n",(0,i.jsx)(n.p,{children:"But nothing stops you from using plain text:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:".slide\n\n<Columns>\n\n# Title\nFirst column\n  \n<Identity>\n\n# Other title\nSecond one\n    \n</Identity>\n\n</Columns>\n"})}),"\n",(0,i.jsx)(n.admonition,{type:"info",children:(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"Identity"}),", ",(0,i.jsx)(n.code,{children:"dummy"}),", ",(0,i.jsx)(n.code,{children:"p"}),", or ",(0,i.jsx)(n.code,{children:"div"})," help WLX differentiate between the first and second arguments. It's similar to how the ",(0,i.jsx)(n.code,{children:"li"})," tag is used in the ",(0,i.jsx)(n.code,{children:"ul"})," HTML tag for lists."]})}),"\n",(0,i.jsx)(n.p,{children:"You can use the full power of modern CSS to style it however you like."})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}}}]);