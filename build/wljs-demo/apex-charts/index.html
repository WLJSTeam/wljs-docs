<!doctype html>
<html lang="en" dir="ltr" class="mdx-wrapper mdx-page plugin-pages plugin-id-default" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.3.2">
<title data-rh="true">Integrating ApexCharts | WLJS Notebook</title><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://wljs.io/wljs-demo/apex-charts/"><meta data-rh="true" property="og:locale" content="en"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docusaurus_tag" content="default"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docsearch:docusaurus_tag" content="default"><meta data-rh="true" name="msvalidate.01" content="558ACAAD3C892A685EC4981186E3711D"><meta data-rh="true" name="google-site-verification" content="EfqZCis7_qdi7v5e_xZFG-q1I2nGROZLaqCDsVDlt0Y"><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0"><meta data-rh="true" property="og:title" content="Integrating ApexCharts | WLJS Notebook"><meta data-rh="true" name="description" content="In this notebook we explore ApexCharts.js library and intergrate it with Wolfram Language"><meta data-rh="true" property="og:description" content="In this notebook we explore ApexCharts.js library and intergrate it with Wolfram Language"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://wljs.io/wljs-demo/apex-charts/"><link data-rh="true" rel="alternate" href="https://wljs.io/wljs-demo/apex-charts/" hreflang="en"><link data-rh="true" rel="alternate" href="https://wljs.io/wljs-demo/apex-charts/" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="WLJS Notebook RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="WLJS Notebook Atom Feed">



<link rel="alternate" type="application/rss+xml" href="/releases/rss.xml" title="WLJS Notebook RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/releases/atom.xml" title="WLJS Notebook Atom Feed">
<link rel="alternate" type="application/rss+xml" href="/widgets/rss.xml" title="WLJS Notebook RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/widgets/atom.xml" title="WLJS Notebook Atom Feed">



<script type="module" src="https://cdn.jsdelivr.net/gh/JerryI/wljs-interpreter@base/dist/interpreter.js"></script>
<script type="module" src="https://cdn.jsdelivr.net/gh/JerryI/wljs-interpreter@base/src/core.js"></script>
<script type="module" src="https://cdn.jsdelivr.net/gh/JerryI/wljs-cells@base/src/module.js"></script>
<script type="module" src="https://cdn.jsdelivr.net/gh/JerryI/wljs-editor@base/dist/kernel.js"></script>
<script type="module" src="https://cdn.jsdelivr.net/gh/JerryI/wljs-editor@base/src/boxes.js"></script>
<script type="module" src="https://cdn.jsdelivr.net/gh/JerryI/wljs-editor@base/src/metamarkers.js"></script>
<script type="module" src="https://cdn.jsdelivr.net/gh/JerryI/wljs-editor@base/src/objects.js"></script>
<script type="module" src="https://cdn.jsdelivr.net/gh/JerryI/wljs-editor@base/src/frontsubmit.js"></script>
<script type="module" src="https://cdn.jsdelivr.net/gh/JerryI/wljs-js-support@base/src/kernel.js"></script>
<script type="module" src="https://cdn.jsdelivr.net/gh/JerryI/wljs-magic-support@base/src/kernel.js"></script>
<script type="module" src="https://cdn.jsdelivr.net/gh/JerryI/wljs-mermaid-support@base/dist/kernel.js"></script>
<script type="module" src="https://cdn.jsdelivr.net/gh/JerryI/wljs-sound@master/dist/kernel.js"></script>
<script type="module" src="https://cdn.jsdelivr.net/gh/JerryI/wljs-inputs@base/dist/kernel.js"></script>
<script type="module" src="https://cdn.jsdelivr.net/gh/JerryI/wljs-html-support@base/src/kernel.js"></script>
<script type="module" src="https://cdn.jsdelivr.net/gh/JerryI/wljs-wlx-support@base/src/kernel.js"></script>
<script type="module" src="https://cdn.jsdelivr.net/gh/JerryI/wljs-sharedlib-mk@base/dist/kernel.js"></script>
<script type="module" src="https://cdn.jsdelivr.net/gh/JerryI/wljs-sharedlib-d3@base/dist/kernel.js"></script>
<script type="module" src="https://cdn.jsdelivr.net/gh/JerryI/wljs-sharedlib-three@base/dist/kernel.js"></script>
<script type="module" src="https://cdn.jsdelivr.net/gh/JerryI/wljs-manipulate@base/kernel.js"></script>
<script type="module" src="https://cdn.jsdelivr.net/gh/JerryI/wljs-revealjs@base/dist/kernel.js"></script>
<script type="module" src="https://cdn.jsdelivr.net/gh/JerryI/wljs-graphics-d3@base/dist/kernel.js"></script>
<script type="module" src="https://cdn.jsdelivr.net/gh/JerryI/wljs-plotly@base/dist/kernel.js"></script>
<script type="module" src="https://cdn.jsdelivr.net/gh/JerryI/Mathematica-ThreeJS-graphics-engine@base/dist/kernel.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/styles.545b1a7a.css">
<script src="/assets/js/runtime~main.b675be4c.js" defer="defer"></script>
<script src="/assets/js/main.dbeb18ab.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo3.svg" alt="WLJS Notebook" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/img/logo2.svg" alt="WLJS Notebook" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">WLJS</b></a><a class="navbar__item navbar__link" href="/setup">Documentation</a><a class="navbar__item navbar__link" href="/blog">Blog</a><a class="navbar__item navbar__link" href="/releases">Release notes</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" style="border:0;border-radius:6px" href="/wljs-demo">Demonstration Project</a><a class="navbar__item navbar__link" href="/widgets">Mini apps</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/JerryI/wolfram-js-frontend/discussions" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link" style="border:0;border-radius:6px">Discuss</a><a class="navbar__item navbar__link" style="border:0;border-radius:6px" href="/sponsorship">Support us</a><a href="https://github.com/JerryI/wolfram-js-frontend" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"><div class="navbar__search"><span aria-label="expand searchbar" role="button" class="search-icon" tabindex="0"></span><input id="search_input_react" type="search" placeholder="Loading..." aria-label="Search" class="navbar__search-input search-bar" disabled=""></div></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><main class="container container--fluid margin-vert--lg"><div class="row mdxPageWrapper_j9I6"><div class="col col--8"><article><h1>Integrating ApexCharts</h1>
<p>In this notebook we explore <a href="https://apexcharts.com" target="_blank" rel="noopener noreferrer">ApexCharts.js</a> library and intergrate it with <em>Wolfram Language</em></p>
<div><br></div>
<div><br></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="how-to-install-and-build">How to install and build<a href="#how-to-install-and-build" class="hash-link" aria-label="Direct link to How to install and build" title="Direct link to How to install and build">â€‹</a></h2>
<div class="theme-admonition theme-admonition-tip admonition_xJq3 alert alert--success"><div class="admonitionHeading_Gvgb"><span class="admonitionIcon_Rf37"><svg viewBox="0 0 12 16"><path fill-rule="evenodd" d="M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"></path></svg></span>tip</div><div class="admonitionContent_BuS1"><p>You do not need to redo these steps, since <strong>all JS dependencies are cached in the output cells</strong> and it is ready to go!</p></div></div>
<!-- -->
<a href="/861c21fcc2ed3cd5f9272a2f0cac9635.wln" class="p-2 text-xs w-full flex ring-1 ring-inset text-gray-600 shadow ring-gray-300 bg-gray-300 my-2">Download original notebook <svg xmlns="http://www.w3.org/2000/svg" fill="none" class="w-5 h-5 ml-auto" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M17 17h.01m.39-3h.6c.932 0 1.398 0 1.765.152a2 2 0 0 1 1.083 1.083C21 15.602 21 16.068 21 17s0 1.398-.152 1.765a2 2 0 0 1-1.083 1.083C19.398 20 18.932 20 18 20H6c-.932 0-1.398 0-1.765-.152a2 2 0 0 1-1.083-1.083C3 18.398 3 17.932 3 17s0-1.398.152-1.765a2 2 0 0 1 1.083-1.083C4.602 14 5.068 14 6 14h.6m5.4 1V4m0 11-3-3m3 3 3-3"></path></svg></a>
<p>Install locally npm package</p>
<div style="filter:none" class="language-mathematica codeBlockContainer_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Container-styles-module theme-code-block"><div class="codeBlockContent_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Content-styles-module"><pre tabindex="0" class="prism-code language-mathematica codeBlock_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Content-styles-module thin-scrollbar" style="color:rgb(57, 58, 52);background-color:rgb(246, 248, 250)"><code style="white-space:pre-wrap" class="codeBlockLines_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Content-styles-module">.sh
npm i apexcharts --prefix .</code><code class="codeBlockLines_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Content-styles-module"></code></pre></div></div>
<div style="filter:none" class="language-mathematica codeBlockContainer_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Container-styles-module theme-code-block"><div class="codeBlockContent_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Content-styles-module"><pre tabindex="0" class="prism-code language-mathematica codeBlock_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Content-styles-module thin-scrollbar" style="color:rgb(57, 58, 52);background-color:rgb(246, 248, 250)"><code style="white-space:pre-wrap" class="codeBlockLines_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Content-styles-module">
up to date, audited 11 packages in 3s

1 package is looking for funding
  run `npm fund` for details

found 0 vulnerabilities
</code><code class="codeBlockLines_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Content-styles-module"></code></pre></div></div>
<p>Define WLJS function and bundle it</p>
<div style="filter:none" class="language-mathematica codeBlockContainer_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Container-styles-module theme-code-block"><div class="codeBlockContent_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Content-styles-module"><pre tabindex="0" class="prism-code language-mathematica codeBlock_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Content-styles-module thin-scrollbar" style="color:rgb(57, 58, 52);background-color:rgb(246, 248, 250)"><code style="white-space:pre-wrap" class="codeBlockLines_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Content-styles-module">.esm

import ApexCharts from &#x27;apexcharts&#x27;

const whenVisible = (ele, cbk) =&gt; {
  let observer = new IntersectionObserver(function(entries) {
    if(entries[0].isIntersecting === true) {
      observer.unobserve(ele);
      cbk();
      return;
    }
        
  }, { threshold: [0] });

  observer.observe(ele);
};

core.ApexCharts = async (args, env) =&gt; {
    const options = await interpretate(args[0], env);
    const chart = new ApexCharts(env.element, options);

    whenVisible(env.element, () =&gt; chart.render())
}</code><code class="codeBlockLines_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Content-styles-module"></code></pre></div></div>
<div style="filter:none" class="language-mathematica codeBlockContainer_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Container-styles-module theme-code-block"><div class="codeBlockContent_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Content-styles-module"><pre tabindex="0" class="prism-code language-mathematica codeBlock_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Content-styles-module thin-scrollbar" style="color:rgb(57, 58, 52);background-color:rgb(246, 248, 250)"><code style="white-space:pre-wrap" class="codeBlockLines_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Content-styles-module">// node_modules/apexcharts/dist/apexcharts.esm.js
function t(t2, e2) {
  (null == e2 || e2 &gt; t2.length) &amp;&amp; (e2 = t2.length);
  for (var i2 = 0, a2 = Array(e2); i2 &lt; e2; i2++) a2[i2] = t2[i2];
  return a2;
}
function e(t2) {
  if (void 0 === t2) throw new ReferenceError(&quot;this hasn&#x27;t been initialised - super() hasn&#x27;t been called&quot;);
  return t2;
}
function i(t2, e2) {
  if (!(t2 instanceof e2)) throw new TypeError(&quot;Cannot call a class as a function&quot;);
}
function a(t2, e2) {
  for (var i2 = 0; i2 &lt; e2.length; i2++) {
    var a2 = e2[i2];
    a2.enumerable = a2.enumerable || false, a2.configurable = true, &quot;value&quot; in a2 &amp;&amp; (a2.writable = true), Object.defineProperty(t2, x(a2.key), a2);
  }
}
function s(t2, e2, i2) {
  return e2 &amp;&amp; a(t2.prototype, e2), i2 &amp;&amp; a(t2, i2), Object.defineProperty(t2, &quot;prototype&quot;, { writable: false }), t2;
}
function r(t2, e2) {
  var i2 = &quot;undefined&quot; != typeof Symbol &amp;&amp; t2[Symbol.iterator] || t2[&quot;@@iterator&quot;];
  if (!i2) {
    if (Array.isArray(t2) || (i2 = m(t2)) || e2 &amp;&amp; t2 &amp;&amp; &quot;number&quot; == typeof t2.length) {
      i2 &amp;&amp; (t2 = i2);
      var a2 = 0, s2 = function() {
      };
      return { s: s2, n: function() {
        return a2 &gt;= t2.length ? { done: true } : { done: false, value: t2[a2++] };
      }, e: function(t3) {
        throw t3;
      }, f: s2 };
    }
    throw new TypeError(&quot;Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.&quot;);
  }
  var r2, n2 = true, o2 = false;
  return { s: function() {
    i2 = i2.call(t2);
  }, n: function() {
    var t3 = i2.next();
    return n2 = t3.done, t3;
  }, e: function(t3) {
    o2 = true, r2 = t3;
  }, f: function() {
    try {
      n2 || null == i2.return || i2.return();
    } finally {
      if (o2) throw r2;
    }
  } };
}
function n(t2) {
  var i2 = c();
  return function() {
    var a2, s2 = l(t2);
    if (i2) {
      var r2 = l(this).constructor;
      a2 = Reflect.construct(s2, arguments, r2);
    } else a2 = s2.apply(this, arguments);
    return function(t3, i3) {
      if (i3 &amp;&amp; (&quot;object&quot; == typeof i3 || &quot;function&quot; == typeof i3)) return i3;
      if (void 0 !== i3) throw new TypeError(&quot;Derived constructors may only return object or undefined&quot;);
      return e(t3);
    }(this, a2);
  };
}
function o(t2, e2, i2) {
  return (e2 = x(e2)) in t2 ? Object.defineProperty(t2, e2, { value: i2, enumerable: true, configurable: true, writable: true }) : t2[e2] = i2, t2;
}
function l(t2) {
  return l = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t3) {
    return t3.__proto__ || Object.getPrototypeOf(t3);
  }, l(t2);
}
function h(t2, e2) {
  if (&quot;function&quot; != typeof e2 &amp;&amp; null !== e2) throw new TypeError(&quot;Super expression must either be null or a function&quot;);
  t2.prototype = Object.create(e2 &amp;&amp; e2.prototype, { constructor: { value: t2, writable: true, configurable: true } }), Object.defineProperty(t2, &quot;prototype&quot;, { writable: false }), e2 &amp;&amp; g(t2, e2);
}
function c() {
  try {
    var t2 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t3) {
  }
  return (c = function() {
    return !!t2;
  })();
}
function d(t2, e2) {
  var i2 = Object.keys(t2);
  if (Object.getOwnPropertySymbols) {
    var a2 = Object.getOwnPropertySymbols(t2);
    e2 &amp;&amp; (a2 = a2.filter(function(e3) {
      return Object.getOwnPropertyDescriptor(t2, e3).enumerable;
    })), i2.push.apply(i2, a2);
  }
  return i2;
}
function u(t2) {
  for (var e2 = 1; e2 &lt; arguments.length; e2++) {
    var i2 = null != arguments[e2] ? arguments[e2] : {};
    e2 % 2 ? d(Object(i2), true).forEach(function(e3) {
      o(t2, e3, i2[e3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t2, Object.getOwnPropertyDescriptors(i2)) : d(Object(i2)).forEach(function(e3) {
      Object.defineProperty(t2, e3, Object.getOwnPropertyDescriptor(i2, e3));
    });
  }
  return t2;
}
function g(t2, e2) {
  return g = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t3, e3) {
    return t3.__proto__ = e3, t3;
  }, g(t2, e2);
}
function p(t2, e2) {
  return function(t3) {
    if (Array.isArray(t3)) return t3;
  }(t2) || function(t3, e3) {
    var i2 = null == t3 ? null : &quot;undefined&quot; != typeof Symbol &amp;&amp; t3[Symbol.iterator] || t3[&quot;@@iterator&quot;];
    if (null != i2) {
      var a2, s2, r2, n2, o2 = [], l2 = true, h2 = false;
      try {
        if (r2 = (i2 = i2.call(t3)).next, 0 === e3) {
          if (Object(i2) !== i2) return;
          l2 = false;
        } else for (; !(l2 = (a2 = r2.call(i2)).done) &amp;&amp; (o2.push(a2.value), o2.length !== e3); l2 = true) ;
      } catch (t4) {
        h2 = true, s2 = t4;
      } finally {
        try {
          if (!l2 &amp;&amp; null != i2.return &amp;&amp; (n2 = i2.return(), Object(n2) !== n2)) return;
        } finally {
          if (h2) throw s2;
        }
      }
      return o2;
    }
  }(t2, e2) || m(t2, e2) || function() {
    throw new TypeError(&quot;Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.&quot;);
  }();
}
function f(e2) {
  return function(e3) {
    if (Array.isArray(e3)) return t(e3);
  }(e2) || function(t2) {
    if (&quot;undefined&quot; != typeof Symbol &amp;&amp; null != t2[Symbol.iterator] || null != t2[&quot;@@iterator&quot;]) return Array.from(t2);
  }(e2) || m(e2) || function() {
    throw new TypeError(&quot;Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.&quot;);
  }();
}
function x(t2) {
  var e2 = function(t3, e3) {
    if (&quot;object&quot; != typeof t3 || !t3) return t3;
    var i2 = t3[Symbol.toPrimitive];
    if (void 0 !== i2) {
      var a2 = i2.call(t3, e3 || &quot;default&quot;);
      if (&quot;object&quot; != typeof a2) return a2;
      throw new TypeError(&quot;@@toPrimitive must return a primitive value.&quot;);
    }
    return (&quot;string&quot; === e3 ? String : Number)(t3);
  }(t2, &quot;string&quot;);
  return &quot;symbol&quot; == typeof e2 ? e2 : e2 + &quot;&quot;;
}
function b(t2) {
  return b = &quot;function&quot; == typeof Symbol &amp;&amp; &quot;symbol&quot; == typeof Symbol.iterator ? function(t3) {
    return typeof t3;
  } : function(t3) {
    return t3 &amp;&amp; &quot;function&quot; == typeof Symbol &amp;&amp; t3.constructor === Symbol &amp;&amp; t3 !== Symbol.prototype ? &quot;symbol&quot; : typeof t3;
  }, b(t2);
}
function m(e2, i2) {
  if (e2) {
    if (&quot;string&quot; == typeof e2) return t(e2, i2);
    var a2 = {}.toString.call(e2).slice(8, -1);
    return &quot;Object&quot; === a2 &amp;&amp; e2.constructor &amp;&amp; (a2 = e2.constructor.name), &quot;Map&quot; === a2 || &quot;Set&quot; === a2 ? Array.from(e2) : &quot;Arguments&quot; === a2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a2) ? t(e2, i2) : void 0;
  }
}
var v = function() {
  function t2() {
    i(this, t2);
  }
  return s(t2, [{ key: &quot;shadeRGBColor&quot;, value: function(t3, e2) {
    var i2 = e2.split(&quot;,&quot;), a2 = t3 &lt; 0 ? 0 : 255, s2 = t3 &lt; 0 ? -1 * t3 : t3, r2 = parseInt(i2[0].slice(4), 10), n2 = parseInt(i2[1], 10), o2 = parseInt(i2[2], 10);
    return &quot;rgb(&quot; + (Math.round((a2 - r2) * s2) + r2) + &quot;,&quot; + (Math.round((a2 - n2) * s2) + n2) + &quot;,&quot; + (Math.round((a2 - o2) * s2) + o2) + &quot;)&quot;;
  } }, { key: &quot;shadeHexColor&quot;, value: function(t3, e2) {
    var i2 = parseInt(e2.slice(1), 16), a2 = t3 &lt; 0 ? 0 : 255, s2 = t3 &lt; 0 ? -1 * t3 : t3, r2 = i2 &gt;&gt; 16, n2 = i2 &gt;&gt; 8 &amp; 255, o2 = 255 &amp; i2;
    return &quot;#&quot; + (16777216 + 65536 * (Math.round((a2 - r2) * s2) + r2) + 256 * (Math.round((a2 - n2) * s2) + n2) + (Math.round((a2 - o2) * s2) + o2)).toString(16).slice(1);
  } }, { key: &quot;shadeColor&quot;, value: function(e2, i2) {
    return t2.isColorHex(i2) ? this.shadeHexColor(e2, i2) : this.shadeRGBColor(e2, i2);
  } }], [{ key: &quot;bind&quot;, value: function(t3, e2) {
    return function() {
      return t3.apply(e2, arguments);
    };
  } }, { key: &quot;isObject&quot;, value: function(t3) {
    return t3 &amp;&amp; &quot;object&quot; === b(t3) &amp;&amp; !Array.isArray(t3) &amp;&amp; null != t3;
  } }, { key: &quot;is&quot;, value: function(t3, e2) {
    return Object.prototype.toString.call(e2) === &quot;[object &quot; + t3 + &quot;]&quot;;
  } }, { key: &quot;listToArray&quot;, value: function(t3) {
    var e2, i2 = [];
    for (e2 = 0; e2 &lt; t3.length; e2++) i2[e2] = t3[e2];
    return i2;
  } }, { key: &quot;extend&quot;, value: function(t3, e2) {
    var i2 = this;
    &quot;function&quot; != typeof Object.assign &amp;&amp; (Object.assign = function(t4) {
      if (null == t4) throw new TypeError(&quot;Cannot convert undefined or null to object&quot;);
      for (var e3 = Object(t4), i3 = 1; i3 &lt; arguments.length; i3++) {
        var a3 = arguments[i3];
        if (null != a3) for (var s2 in a3) a3.hasOwnProperty(s2) &amp;&amp; (e3[s2] = a3[s2]);
      }
      return e3;
    });
    var a2 = Object.assign({}, t3);
    return this.isObject(t3) &amp;&amp; this.isObject(e2) &amp;&amp; Object.keys(e2).forEach(function(s2) {
      i2.isObject(e2[s2]) &amp;&amp; s2 in t3 ? a2[s2] = i2.extend(t3[s2], e2[s2]) : Object.assign(a2, o({}, s2, e2[s2]));
    }), a2;
  } }, { key: &quot;extendArray&quot;, value: function(e2, i2) {
    var a2 = [];
    return e2.map(function(e3) {
      a2.push(t2.extend(i2, e3));
    }), e2 = a2;
  } }, { key: &quot;monthMod&quot;, value: function(t3) {
    return t3 % 12;
  } }, { key: &quot;clone&quot;, value: function(t3) {
    var e2, i2 = arguments.length &gt; 1 &amp;&amp; void 0 !== arguments[1] ? arguments[1] : /* @__PURE__ */ new WeakMap();
    if (null === t3 || &quot;object&quot; !== b(t3)) return t3;
    if (i2.has(t3)) return i2.get(t3);
    if (Array.isArray(t3)) {
      e2 = [], i2.set(t3, e2);
      for (var a2 = 0; a2 &lt; t3.length; a2++) e2[a2] = this.clone(t3[a2], i2);
    } else if (t3 instanceof Date) e2 = new Date(t3.getTime());
    else for (var s2 in e2 = {}, i2.set(t3, e2), t3) t3.hasOwnProperty(s2) &amp;&amp; (e2[s2] = this.clone(t3[s2], i2));
    return e2;
  } }, { key: &quot;log10&quot;, value: function(t3) {
    return Math.log(t3) / Math.LN10;
  } }, { key: &quot;roundToBase10&quot;, value: function(t3) {
    return Math.pow(10, Math.floor(Math.log10(t3)));
  } }, { key: &quot;roundToBase&quot;, value: function(t3, e2) {
    return Math.pow(e2, Math.floor(Math.log(t3) / Math.log(e2)));
  } }, { key: &quot;parseNumber&quot;, value: function(t3) {
    return null === t3 ? t3 : parseFloat(t3);
  } }, { key: &quot;stripNumber&quot;, value: function(t3) {
    var e2 = arguments.length &gt; 1 &amp;&amp; void 0 !== arguments[1] ? arguments[1] : 2;
    return Number.isInteger(t3) ? t3 : parseFloat(t3.toPrecision(e2));
  } }, { key: &quot;randomId&quot;, value: function() {
    return (Math.random() + 1).toString(36).substring(4);
  } }, { key: &quot;noExponents&quot;, value: function(t3) {
    return t3.toString().includes(&quot;e&quot;) ? Math.round(t3) : t3;
  } }, { key: &quot;elementExists&quot;, value: function(t3) {
    return !(!t3 || !t3.isConnected);
  } }, { key: &quot;getDimensions&quot;, value: function(t3) {
    var e2 = getComputedStyle(t3, null), i2 = t3.clientHeight, a2 = t3.clientWidth;
    return i2 -= parseFloat(e2.paddingTop) + parseFloat(e2.paddingBottom), [a2 -= parseFloat(e2.paddingLeft) + parseFloat(e2.paddingRight), i2];
  } }, { key: &quot;getBoundingClientRect&quot;, value: function(t3) {
    var e2 = t3.getBoundingClientRect();
    return { top: e2.top, right: e2.right, bottom: e2.bottom, left: e2.left, width: t3.clientWidth, height: t3.clientHeight, x: e2.left, y: e2.top };
  } }, { key: &quot;getLargestStringFromArr&quot;, value: function(t3) {
    return t3.reduce(function(t4, e2) {
      return Array.isArray(e2) &amp;&amp; (e2 = e2.reduce(function(t5, e3) {
        return t5.length &gt; e3.length ? t5 : e3;
      })), t4.length &gt; e2.length ? t4 : e2;
    }, 0);
  } }, { key: &quot;hexToRgba&quot;, value: function() {
    var t3 = arguments.length &gt; 0 &amp;&amp; void 0 !== arguments[0] ? arguments[0] : &quot;#999999&quot;, e2 = arguments.length &gt; 1 &amp;&amp; void 0 !== arguments[1] ? arguments[1] : 0.6;
    &quot;#&quot; !== t3.substring(0, 1) &amp;&amp; (t3 = &quot;#999999&quot;);
    var i2 = t3.replace(&quot;#&quot;, &quot;&quot;);
    i2 = i2.match(new RegExp(&quot;(.{&quot; + i2.length / 3 + &quot;})&quot;, &quot;g&quot;));
    for (var a2 = 0; a2 &lt; i2.length; a2++) i2[a2] = parseInt(1 === i2[a2].length ? i2[a2] + i2[a2] : i2[a2], 16);
    return void 0 !== e2 &amp;&amp; i2.push(e2), &quot;rgba(&quot; + i2.join(&quot;,&quot;) + &quot;)&quot;;
  } }, { key: &quot;getOpacityFromRGBA&quot;, value: function(t3) {
    return parseFloat(t3.replace(/^.*,(.+)\)/, &quot;$1&quot;));
  } }, { key: &quot;rgb2hex&quot;, value: function(t3) {
    return (t3 = t3.match(/^rgba?[\s+]?\([\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?/i)) &amp;&amp; 4 === t3.length ? &quot;#&quot; + (&quot;0&quot; + parseInt(t3[1], 10).toString(16)).slice(-2) + (&quot;0&quot; + parseInt(t3[2], 10).toString(16)).slice(-2) + (&quot;0&quot; + parseInt(t3[3], 10).toString(16)).slice(-2) : &quot;&quot;;
  } }, { key: &quot;isColorHex&quot;, value: function(t3) {
    return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)|(^#[0-9A-F]{8}$)/i.test(t3);
  } }, { key: &quot;getPolygonPos&quot;, value: function(t3, e2) {
    for (var i2 = [], a2 = 2 * Math.PI / e2, s2 = 0; s2 &lt; e2; s2++) {
      var r2 = {};
      r2.x = t3 * Math.sin(s2 * a2), r2.y = -t3 * Math.cos(s2 * a2), i2.push(r2);
    }
    return i2;
  } }, { key: &quot;polarToCartesian&quot;, value: function(t3, e2, i2, a2) {
    var s2 = (a2 - 90) * Math.PI / 180;
    return { x: t3 + i2 * Math.cos(s2), y: e2 + i2 * Math.sin(s2) };
  } }, { key: &quot;escapeString&quot;, value: function(t3) {
    var e2 = arguments.length &gt; 1 &amp;&amp; void 0 !== arguments[1] ? arguments[1] : &quot;x&quot;, i2 = t3.toString().slice();
    return i2 = i2.replace(/[` ~!@#$%^&amp;*()|+\=?;:&#x27;&quot;,.&lt;&gt;{}[\]\\/]/gi, e2);
  } }, { key: &quot;negToZero&quot;, value: function(t3) {
    return t3 &lt; 0 ? 0 : t3;
  } }, { key: &quot;moveIndexInArray&quot;, value: function(t3, e2, i2) {
    if (i2 &gt;= t3.length) for (var a2 = i2 - t3.length + 1; a2--; ) t3.push(void 0);
    return t3.splice(i2, 0, t3.splice(e2, 1)[0]), t3;
  } }, { key: &quot;extractNumber&quot;, value: function(t3) {
    return parseFloat(t3.replace(/[^\d.]*/g, &quot;&quot;));
  } }, { key: &quot;findAncestor&quot;, value: function(t3, e2) {
    for (; (t3 = t3.parentElement) &amp;&amp; !t3.classList.contains(e2); ) ;
    return t3;
  } }, { key: &quot;setELstyles&quot;, value: function(t3, e2) {
    for (var i2 in e2) e2.hasOwnProperty(i2) &amp;&amp; (t3.style.key = e2[i2]);
  } }, { key: &quot;preciseAddition&quot;, value: function(t3, e2) {
    var i2 = (String(t3).split(&quot;.&quot;)[1] || &quot;&quot;).length, a2 = (String(e2).split(&quot;.&quot;)[1] || &quot;&quot;).length, s2 = Math.pow(10, Math.max(i2, a2));
    return (Math.round(t3 * s2) + Math.round(e2 * s2)) / s2;
  } }, { key: &quot;isNumber&quot;, value: function(t3) {
    return !isNaN(t3) &amp;&amp; parseFloat(Number(t3)) === t3 &amp;&amp; !isNaN(parseInt(t3, 10));
  } }, { key: &quot;isFloat&quot;, value: function(t3) {
    return Number(t3) === t3 &amp;&amp; t3 % 1 != 0;
  } }, { key: &quot;isMsEdge&quot;, value: function() {
    var t3 = window.navigator.userAgent, e2 = t3.indexOf(&quot;Edge/&quot;);
    return e2 &gt; 0 &amp;&amp; parseInt(t3.substring(e2 + 5, t3.indexOf(&quot;.&quot;, e2)), 10);
  } }, { key: &quot;getGCD&quot;, value: function(t3, e2) {
    var i2 = arguments.length &gt; 2 &amp;&amp; void 0 !== arguments[2] ? arguments[2] : 7, a2 = Math.pow(10, i2 - Math.floor(Math.log10(Math.max(t3, e2))));
    for (t3 = Math.round(Math.abs(t3) * a2), e2 = Math.round(Math.abs(e2) * a2); e2; ) {
      var s2 = e2;
      e2 = t3 % e2, t3 = s2;
    }
    return t3 / a2;
  } }, { key: &quot;getPrimeFactors&quot;, value: function(t3) {
    for (var e2 = [], i2 = 2; t3 &gt;= 2; ) t3 % i2 == 0 ? (e2.push(i2), t3 /= i2) : i2++;
    return e2;
  } }, { key: &quot;mod&quot;, value: function(t3, e2) {
    var i2 = arguments.length &gt; 2 &amp;&amp; void 0 !== arguments[2] ? arguments[2] : 7, a2 = Math.pow(10, i2 - Math.floor(Math.log10(Math.max(t3, e2))));
    return (t3 = Math.round(Math.abs(t3) * a2)) % (e2 = Math.round(Math.abs(e2) * a2)) / a2;
  } }]), t2;
}();
var y = function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w;
  }
  return s(t2, [{ key: &quot;animateLine&quot;, value: function(t3, e2, i2, a2) {
    t3.attr(e2).animate(a2).attr(i2);
  } }, { key: &quot;animateMarker&quot;, value: function(t3, e2, i2, a2) {
    t3.attr({ opacity: 0 }).animate(e2).attr({ opacity: 1 }).after(function() {
      a2();
    });
  } }, { key: &quot;animateRect&quot;, value: function(t3, e2, i2, a2, s2) {
    t3.attr(e2).animate(a2).attr(i2).after(function() {
      return s2();
    });
  } }, { key: &quot;animatePathsGradually&quot;, value: function(t3) {
    var e2 = t3.el, i2 = t3.realIndex, a2 = t3.j, s2 = t3.fill, r2 = t3.pathFrom, n2 = t3.pathTo, o2 = t3.speed, l2 = t3.delay, h2 = this.w, c2 = 0;
    h2.config.chart.animations.animateGradually.enabled &amp;&amp; (c2 = h2.config.chart.animations.animateGradually.delay), h2.config.chart.animations.dynamicAnimation.enabled &amp;&amp; h2.globals.dataChanged &amp;&amp; &quot;bar&quot; !== h2.config.chart.type &amp;&amp; (c2 = 0), this.morphSVG(e2, i2, a2, &quot;line&quot; !== h2.config.chart.type || h2.globals.comboCharts ? s2 : &quot;stroke&quot;, r2, n2, o2, l2 * c2);
  } }, { key: &quot;showDelayedElements&quot;, value: function() {
    this.w.globals.delayedElements.forEach(function(t3) {
      var e2 = t3.el;
      e2.classList.remove(&quot;apexcharts-element-hidden&quot;), e2.classList.add(&quot;apexcharts-hidden-element-shown&quot;);
    });
  } }, { key: &quot;animationCompleted&quot;, value: function(t3) {
    var e2 = this.w;
    e2.globals.animationEnded || (e2.globals.animationEnded = true, this.showDelayedElements(), &quot;function&quot; == typeof e2.config.chart.events.animationEnd &amp;&amp; e2.config.chart.events.animationEnd(this.ctx, { el: t3, w: e2 }));
  } }, { key: &quot;morphSVG&quot;, value: function(t3, e2, i2, a2, s2, r2, n2, o2) {
    var l2 = this, h2 = this.w;
    s2 || (s2 = t3.attr(&quot;pathFrom&quot;)), r2 || (r2 = t3.attr(&quot;pathTo&quot;));
    var c2 = function(t4) {
      return &quot;radar&quot; === h2.config.chart.type &amp;&amp; (n2 = 1), &quot;M 0 &quot;.concat(h2.globals.gridHeight);
    };
    (!s2 || s2.indexOf(&quot;undefined&quot;) &gt; -1 || s2.indexOf(&quot;NaN&quot;) &gt; -1) &amp;&amp; (s2 = c2()), (!r2.trim() || r2.indexOf(&quot;undefined&quot;) &gt; -1 || r2.indexOf(&quot;NaN&quot;) &gt; -1) &amp;&amp; (r2 = c2()), h2.globals.shouldAnimate || (n2 = 1), t3.plot(s2).animate(1, o2).plot(s2).animate(n2, o2).plot(r2).after(function() {
      v.isNumber(i2) ? i2 === h2.globals.series[h2.globals.maxValsInArrayIndex].length - 2 &amp;&amp; h2.globals.shouldAnimate &amp;&amp; l2.animationCompleted(t3) : &quot;none&quot; !== a2 &amp;&amp; h2.globals.shouldAnimate &amp;&amp; (!h2.globals.comboCharts &amp;&amp; e2 === h2.globals.series.length - 1 || h2.globals.comboCharts) &amp;&amp; l2.animationCompleted(t3), l2.showDelayedElements();
    });
  } }]), t2;
}();
var w = {};
var k = [];
function A(t2, e2) {
  if (Array.isArray(t2)) for (const i2 of t2) A(i2, e2);
  else if (&quot;object&quot; != typeof t2) S(Object.getOwnPropertyNames(e2)), w[t2] = Object.assign(w[t2] || {}, e2);
  else for (const e3 in t2) A(e3, t2[e3]);
}
function C(t2) {
  return w[t2] || {};
}
function S(t2) {
  k.push(...t2);
}
function L(t2, e2) {
  let i2;
  const a2 = t2.length, s2 = [];
  for (i2 = 0; i2 &lt; a2; i2++) s2.push(e2(t2[i2]));
  return s2;
}
function M(t2) {
  return t2 % 360 * Math.PI / 180;
}
function P(t2) {
  return t2.charAt(0).toUpperCase() + t2.slice(1);
}
function I(t2, e2, i2, a2) {
  return null != e2 &amp;&amp; null != i2 || (a2 = a2 || t2.bbox(), null == e2 ? e2 = a2.width / a2.height * i2 : null == i2 &amp;&amp; (i2 = a2.height / a2.width * e2)), { width: e2, height: i2 };
}
function T(t2, e2) {
  const i2 = t2.origin;
  let a2 = null != t2.ox ? t2.ox : null != t2.originX ? t2.originX : &quot;center&quot;, s2 = null != t2.oy ? t2.oy : null != t2.originY ? t2.originY : &quot;center&quot;;
  null != i2 &amp;&amp; ([a2, s2] = Array.isArray(i2) ? i2 : &quot;object&quot; == typeof i2 ? [i2.x, i2.y] : [i2, i2]);
  const r2 = &quot;string&quot; == typeof a2, n2 = &quot;string&quot; == typeof s2;
  if (r2 || n2) {
    const { height: t3, width: i3, x: o2, y: l2 } = e2.bbox();
    r2 &amp;&amp; (a2 = a2.includes(&quot;left&quot;) ? o2 : a2.includes(&quot;right&quot;) ? o2 + i3 : o2 + i3 / 2), n2 &amp;&amp; (s2 = s2.includes(&quot;top&quot;) ? l2 : s2.includes(&quot;bottom&quot;) ? l2 + t3 : l2 + t3 / 2);
  }
  return [a2, s2];
}
var z = /* @__PURE__ */ new Set([&quot;desc&quot;, &quot;metadata&quot;, &quot;title&quot;]);
var X = (t2) =&gt; z.has(t2.nodeName);
var R = (t2, e2, i2 = {}) =&gt; {
  const a2 = { ...e2 };
  for (const t3 in a2) a2[t3].valueOf() === i2[t3] &amp;&amp; delete a2[t3];
  Object.keys(a2).length ? t2.node.setAttribute(&quot;data-svgjs&quot;, JSON.stringify(a2)) : (t2.node.removeAttribute(&quot;data-svgjs&quot;), t2.node.removeAttribute(&quot;svgjs:data&quot;));
};
var E = &quot;http://www.w3.org/2000/svg&quot;;
var Y = &quot;http://www.w3.org/2000/xmlns/&quot;;
var H = &quot;http://www.w3.org/1999/xlink&quot;;
var O = { window: &quot;undefined&quot; == typeof window ? null : window, document: &quot;undefined&quot; == typeof document ? null : document };
function F() {
  return O.window;
}
var D = class {
};
var _ = {};
var N = &quot;___SYMBOL___ROOT___&quot;;
function W(t2, e2 = E) {
  return O.document.createElementNS(e2, t2);
}
function B(t2, e2 = false) {
  if (t2 instanceof D) return t2;
  if (&quot;object&quot; == typeof t2) return U(t2);
  if (null == t2) return new _[N]();
  if (&quot;string&quot; == typeof t2 &amp;&amp; &quot;&lt;&quot; !== t2.charAt(0)) return U(O.document.querySelector(t2));
  const i2 = e2 ? O.document.createElement(&quot;div&quot;) : W(&quot;svg&quot;);
  return i2.innerHTML = t2, t2 = U(i2.firstChild), i2.removeChild(i2.firstChild), t2;
}
function G(t2, e2) {
  return e2 &amp;&amp; (e2 instanceof O.window.Node || e2.ownerDocument &amp;&amp; e2 instanceof e2.ownerDocument.defaultView.Node) ? e2 : W(t2);
}
function V(t2) {
  if (!t2) return null;
  if (t2.instance instanceof D) return t2.instance;
  if (&quot;#document-fragment&quot; === t2.nodeName) return new _.Fragment(t2);
  let e2 = P(t2.nodeName || &quot;Dom&quot;);
  return &quot;LinearGradient&quot; === e2 || &quot;RadialGradient&quot; === e2 ? e2 = &quot;Gradient&quot; : _[e2] || (e2 = &quot;Dom&quot;), new _[e2](t2);
}
var U = V;
function q(t2, e2 = t2.name, i2 = false) {
  return _[e2] = t2, i2 &amp;&amp; (_[N] = t2), S(Object.getOwnPropertyNames(t2.prototype)), t2;
}
var Z = 1e3;
function $(t2) {
  return &quot;Svgjs&quot; + P(t2) + Z++;
}
function J(t2) {
  for (let e2 = t2.children.length - 1; e2 &gt;= 0; e2--) J(t2.children[e2]);
  return t2.id ? (t2.id = $(t2.nodeName), t2) : t2;
}
function Q(t2, e2) {
  let i2, a2;
  for (a2 = (t2 = Array.isArray(t2) ? t2 : [t2]).length - 1; a2 &gt;= 0; a2--) for (i2 in e2) t2[a2].prototype[i2] = e2[i2];
}
function K(t2) {
  return function(...e2) {
    const i2 = e2[e2.length - 1];
    return !i2 || i2.constructor !== Object || i2 instanceof Array ? t2.apply(this, e2) : t2.apply(this, e2.slice(0, -1)).attr(i2);
  };
}
A(&quot;Dom&quot;, { siblings: function() {
  return this.parent().children();
}, position: function() {
  return this.parent().index(this);
}, next: function() {
  return this.siblings()[this.position() + 1];
}, prev: function() {
  return this.siblings()[this.position() - 1];
}, forward: function() {
  const t2 = this.position();
  return this.parent().add(this.remove(), t2 + 1), this;
}, backward: function() {
  const t2 = this.position();
  return this.parent().add(this.remove(), t2 ? t2 - 1 : 0), this;
}, front: function() {
  return this.parent().add(this.remove()), this;
}, back: function() {
  return this.parent().add(this.remove(), 0), this;
}, before: function(t2) {
  (t2 = B(t2)).remove();
  const e2 = this.position();
  return this.parent().add(t2, e2), this;
}, after: function(t2) {
  (t2 = B(t2)).remove();
  const e2 = this.position();
  return this.parent().add(t2, e2 + 1), this;
}, insertBefore: function(t2) {
  return (t2 = B(t2)).before(this), this;
}, insertAfter: function(t2) {
  return (t2 = B(t2)).after(this), this;
} });
var tt = /^([+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?)([a-z%]*)$/i;
var et = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i;
var it = /rgb\((\d+),(\d+),(\d+)\)/;
var at = /(#[a-z_][a-z0-9\-_]*)/i;
var st = /\)\s*,?\s*/;
var rt = /\s/g;
var nt = /^#[a-f0-9]{3}$|^#[a-f0-9]{6}$/i;
var ot = /^rgb\(/;
var lt = /^(\s+)?$/;
var ht = /^[+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;
var ct = /\.(jpg|jpeg|png|gif|svg)(\?[^=]+.*)?/i;
var dt = /[\s,]+/;
var ut = /[MLHVCSQTAZ]/i;
function gt(t2) {
  const e2 = Math.round(t2), i2 = Math.max(0, Math.min(255, e2)).toString(16);
  return 1 === i2.length ? &quot;0&quot; + i2 : i2;
}
function pt(t2, e2) {
  for (let i2 = e2.length; i2--; ) if (null == t2[e2[i2]]) return false;
  return true;
}
function ft(t2, e2, i2) {
  return i2 &lt; 0 &amp;&amp; (i2 += 1), i2 &gt; 1 &amp;&amp; (i2 -= 1), i2 &lt; 1 / 6 ? t2 + 6 * (e2 - t2) * i2 : i2 &lt; 0.5 ? e2 : i2 &lt; 2 / 3 ? t2 + (e2 - t2) * (2 / 3 - i2) * 6 : t2;
}
A(&quot;Dom&quot;, { classes: function() {
  const t2 = this.attr(&quot;class&quot;);
  return null == t2 ? [] : t2.trim().split(dt);
}, hasClass: function(t2) {
  return -1 !== this.classes().indexOf(t2);
}, addClass: function(t2) {
  if (!this.hasClass(t2)) {
    const e2 = this.classes();
    e2.push(t2), this.attr(&quot;class&quot;, e2.join(&quot; &quot;));
  }
  return this;
}, removeClass: function(t2) {
  return this.hasClass(t2) &amp;&amp; this.attr(&quot;class&quot;, this.classes().filter(function(e2) {
    return e2 !== t2;
  }).join(&quot; &quot;)), this;
}, toggleClass: function(t2) {
  return this.hasClass(t2) ? this.removeClass(t2) : this.addClass(t2);
} }), A(&quot;Dom&quot;, { css: function(t2, e2) {
  const i2 = {};
  if (0 === arguments.length) return this.node.style.cssText.split(/\s*;\s*/).filter(function(t3) {
    return !!t3.length;
  }).forEach(function(t3) {
    const e3 = t3.split(/\s*:\s*/);
    i2[e3[0]] = e3[1];
  }), i2;
  if (arguments.length &lt; 2) {
    if (Array.isArray(t2)) {
      for (const e3 of t2) {
        const t3 = e3;
        i2[e3] = this.node.style.getPropertyValue(t3);
      }
      return i2;
    }
    if (&quot;string&quot; == typeof t2) return this.node.style.getPropertyValue(t2);
    if (&quot;object&quot; == typeof t2) for (const e3 in t2) this.node.style.setProperty(e3, null == t2[e3] || lt.test(t2[e3]) ? &quot;&quot; : t2[e3]);
  }
  return 2 === arguments.length &amp;&amp; this.node.style.setProperty(t2, null == e2 || lt.test(e2) ? &quot;&quot; : e2), this;
}, show: function() {
  return this.css(&quot;display&quot;, &quot;&quot;);
}, hide: function() {
  return this.css(&quot;display&quot;, &quot;none&quot;);
}, visible: function() {
  return &quot;none&quot; !== this.css(&quot;display&quot;);
} }), A(&quot;Dom&quot;, { data: function(t2, e2, i2) {
  if (null == t2) return this.data(L(function(t3, e3) {
    let i3;
    const a2 = t3.length, s2 = [];
    for (i3 = 0; i3 &lt; a2; i3++) e3(t3[i3]) &amp;&amp; s2.push(t3[i3]);
    return s2;
  }(this.node.attributes, (t3) =&gt; 0 === t3.nodeName.indexOf(&quot;data-&quot;)), (t3) =&gt; t3.nodeName.slice(5)));
  if (t2 instanceof Array) {
    const e3 = {};
    for (const i3 of t2) e3[i3] = this.data(i3);
    return e3;
  }
  if (&quot;object&quot; == typeof t2) for (e2 in t2) this.data(e2, t2[e2]);
  else if (arguments.length &lt; 2) try {
    return JSON.parse(this.attr(&quot;data-&quot; + t2));
  } catch (e3) {
    return this.attr(&quot;data-&quot; + t2);
  }
  else this.attr(&quot;data-&quot; + t2, null === e2 ? null : true === i2 || &quot;string&quot; == typeof e2 || &quot;number&quot; == typeof e2 ? e2 : JSON.stringify(e2));
  return this;
} }), A(&quot;Dom&quot;, { remember: function(t2, e2) {
  if (&quot;object&quot; == typeof arguments[0]) for (const e3 in t2) this.remember(e3, t2[e3]);
  else {
    if (1 === arguments.length) return this.memory()[t2];
    this.memory()[t2] = e2;
  }
  return this;
}, forget: function() {
  if (0 === arguments.length) this._memory = {};
  else for (let t2 = arguments.length - 1; t2 &gt;= 0; t2--) delete this.memory()[arguments[t2]];
  return this;
}, memory: function() {
  return this._memory = this._memory || {};
} });
var xt = class _xt {
  constructor(...t2) {
    this.init(...t2);
  }
  static isColor(t2) {
    return t2 &amp;&amp; (t2 instanceof _xt || this.isRgb(t2) || this.test(t2));
  }
  static isRgb(t2) {
    return t2 &amp;&amp; &quot;number&quot; == typeof t2.r &amp;&amp; &quot;number&quot; == typeof t2.g &amp;&amp; &quot;number&quot; == typeof t2.b;
  }
  static random(t2 = &quot;vibrant&quot;, e2) {
    const { random: i2, round: a2, sin: s2, PI: r2 } = Math;
    if (&quot;vibrant&quot; === t2) {
      const t3 = 24 * i2() + 57, e3 = 38 * i2() + 45, a3 = 360 * i2();
      return new _xt(t3, e3, a3, &quot;lch&quot;);
    }
    if (&quot;sine&quot; === t2) {
      const t3 = a2(80 * s2(2 * r2 * (e2 = null == e2 ? i2() : e2) / 0.5 + 0.01) + 150), n2 = a2(50 * s2(2 * r2 * e2 / 0.5 + 4.6) + 200), o2 = a2(100 * s2(2 * r2 * e2 / 0.5 + 2.3) + 150);
      return new _xt(t3, n2, o2);
    }
    if (&quot;pastel&quot; === t2) {
      const t3 = 8 * i2() + 86, e3 = 17 * i2() + 9, a3 = 360 * i2();
      return new _xt(t3, e3, a3, &quot;lch&quot;);
    }
    if (&quot;dark&quot; === t2) {
      const t3 = 10 + 10 * i2(), e3 = 50 * i2() + 86, a3 = 360 * i2();
      return new _xt(t3, e3, a3, &quot;lch&quot;);
    }
    if (&quot;rgb&quot; === t2) {
      const t3 = 255 * i2(), e3 = 255 * i2(), a3 = 255 * i2();
      return new _xt(t3, e3, a3);
    }
    if (&quot;lab&quot; === t2) {
      const t3 = 100 * i2(), e3 = 256 * i2() - 128, a3 = 256 * i2() - 128;
      return new _xt(t3, e3, a3, &quot;lab&quot;);
    }
    if (&quot;grey&quot; === t2) {
      const t3 = 255 * i2();
      return new _xt(t3, t3, t3);
    }
    throw new Error(&quot;Unsupported random color mode&quot;);
  }
  static test(t2) {
    return &quot;string&quot; == typeof t2 &amp;&amp; (nt.test(t2) || ot.test(t2));
  }
  cmyk() {
    const { _a: t2, _b: e2, _c: i2 } = this.rgb(), [a2, s2, r2] = [t2, e2, i2].map((t3) =&gt; t3 / 255), n2 = Math.min(1 - a2, 1 - s2, 1 - r2);
    if (1 === n2) return new _xt(0, 0, 0, 1, &quot;cmyk&quot;);
    return new _xt((1 - a2 - n2) / (1 - n2), (1 - s2 - n2) / (1 - n2), (1 - r2 - n2) / (1 - n2), n2, &quot;cmyk&quot;);
  }
  hsl() {
    const { _a: t2, _b: e2, _c: i2 } = this.rgb(), [a2, s2, r2] = [t2, e2, i2].map((t3) =&gt; t3 / 255), n2 = Math.max(a2, s2, r2), o2 = Math.min(a2, s2, r2), l2 = (n2 + o2) / 2, h2 = n2 === o2, c2 = n2 - o2;
    return new _xt(360 * (h2 ? 0 : n2 === a2 ? ((s2 - r2) / c2 + (s2 &lt; r2 ? 6 : 0)) / 6 : n2 === s2 ? ((r2 - a2) / c2 + 2) / 6 : n2 === r2 ? ((a2 - s2) / c2 + 4) / 6 : 0), 100 * (h2 ? 0 : l2 &gt; 0.5 ? c2 / (2 - n2 - o2) : c2 / (n2 + o2)), 100 * l2, &quot;hsl&quot;);
  }
  init(t2 = 0, e2 = 0, i2 = 0, a2 = 0, s2 = &quot;rgb&quot;) {
    if (t2 = t2 || 0, this.space) for (const t3 in this.space) delete this[this.space[t3]];
    if (&quot;number&quot; == typeof t2) s2 = &quot;string&quot; == typeof a2 ? a2 : s2, a2 = &quot;string&quot; == typeof a2 ? 0 : a2, Object.assign(this, { _a: t2, _b: e2, _c: i2, _d: a2, space: s2 });
    else if (t2 instanceof Array) this.space = e2 || (&quot;string&quot; == typeof t2[3] ? t2[3] : t2[4]) || &quot;rgb&quot;, Object.assign(this, { _a: t2[0], _b: t2[1], _c: t2[2], _d: t2[3] || 0 });
    else if (t2 instanceof Object) {
      const i3 = function(t3, e3) {
        const i4 = pt(t3, &quot;rgb&quot;) ? { _a: t3.r, _b: t3.g, _c: t3.b, _d: 0, space: &quot;rgb&quot; } : pt(t3, &quot;xyz&quot;) ? { _a: t3.x, _b: t3.y, _c: t3.z, _d: 0, space: &quot;xyz&quot; } : pt(t3, &quot;hsl&quot;) ? { _a: t3.h, _b: t3.s, _c: t3.l, _d: 0, space: &quot;hsl&quot; } : pt(t3, &quot;lab&quot;) ? { _a: t3.l, _b: t3.a, _c: t3.b, _d: 0, space: &quot;lab&quot; } : pt(t3, &quot;lch&quot;) ? { _a: t3.l, _b: t3.c, _c: t3.h, _d: 0, space: &quot;lch&quot; } : pt(t3, &quot;cmyk&quot;) ? { _a: t3.c, _b: t3.m, _c: t3.y, _d: t3.k, space: &quot;cmyk&quot; } : { _a: 0, _b: 0, _c: 0, space: &quot;rgb&quot; };
        return i4.space = e3 || i4.space, i4;
      }(t2, e2);
      Object.assign(this, i3);
    } else if (&quot;string&quot; == typeof t2) if (ot.test(t2)) {
      const e3 = t2.replace(rt, &quot;&quot;), [i3, a3, s3] = it.exec(e3).slice(1, 4).map((t3) =&gt; parseInt(t3));
      Object.assign(this, { _a: i3, _b: a3, _c: s3, _d: 0, space: &quot;rgb&quot; });
    } else {
      if (!nt.test(t2)) throw Error(&quot;Unsupported string format, can&#x27;t construct Color&quot;);
      {
        const e3 = (t3) =&gt; parseInt(t3, 16), [, i3, a3, s3] = et.exec(function(t3) {
          return 4 === t3.length ? [&quot;#&quot;, t3.substring(1, 2), t3.substring(1, 2), t3.substring(2, 3), t3.substring(2, 3), t3.substring(3, 4), t3.substring(3, 4)].join(&quot;&quot;) : t3;
        }(t2)).map(e3);
        Object.assign(this, { _a: i3, _b: a3, _c: s3, _d: 0, space: &quot;rgb&quot; });
      }
    }
    const { _a: r2, _b: n2, _c: o2, _d: l2 } = this, h2 = &quot;rgb&quot; === this.space ? { r: r2, g: n2, b: o2 } : &quot;xyz&quot; === this.space ? { x: r2, y: n2, z: o2 } : &quot;hsl&quot; === this.space ? { h: r2, s: n2, l: o2 } : &quot;lab&quot; === this.space ? { l: r2, a: n2, b: o2 } : &quot;lch&quot; === this.space ? { l: r2, c: n2, h: o2 } : &quot;cmyk&quot; === this.space ? { c: r2, m: n2, y: o2, k: l2 } : {};
    Object.assign(this, h2);
  }
  lab() {
    const { x: t2, y: e2, z: i2 } = this.xyz();
    return new _xt(116 * e2 - 16, 500 * (t2 - e2), 200 * (e2 - i2), &quot;lab&quot;);
  }
  lch() {
    const { l: t2, a: e2, b: i2 } = this.lab(), a2 = Math.sqrt(e2 ** 2 + i2 ** 2);
    let s2 = 180 * Math.atan2(i2, e2) / Math.PI;
    s2 &lt; 0 &amp;&amp; (s2 *= -1, s2 = 360 - s2);
    return new _xt(t2, a2, s2, &quot;lch&quot;);
  }
  rgb() {
    if (&quot;rgb&quot; === this.space) return this;
    if (&quot;lab&quot; === (t2 = this.space) || &quot;xyz&quot; === t2 || &quot;lch&quot; === t2) {
      let { x: t3, y: e2, z: i2 } = this;
      if (&quot;lab&quot; === this.space || &quot;lch&quot; === this.space) {
        let { l: a3, a: s3, b: r3 } = this;
        if (&quot;lch&quot; === this.space) {
          const { c: t4, h: e3 } = this, i3 = Math.PI / 180;
          s3 = t4 * Math.cos(i3 * e3), r3 = t4 * Math.sin(i3 * e3);
        }
        const n3 = (a3 + 16) / 116, o3 = s3 / 500 + n3, l3 = n3 - r3 / 200, h3 = 16 / 116, c3 = 8856e-6, d2 = 7.787;
        t3 = 0.95047 * (o3 ** 3 &gt; c3 ? o3 ** 3 : (o3 - h3) / d2), e2 = 1 * (n3 ** 3 &gt; c3 ? n3 ** 3 : (n3 - h3) / d2), i2 = 1.08883 * (l3 ** 3 &gt; c3 ? l3 ** 3 : (l3 - h3) / d2);
      }
      const a2 = 3.2406 * t3 + -1.5372 * e2 + -0.4986 * i2, s2 = -0.9689 * t3 + 1.8758 * e2 + 0.0415 * i2, r2 = 0.0557 * t3 + -0.204 * e2 + 1.057 * i2, n2 = Math.pow, o2 = 31308e-7, l2 = a2 &gt; o2 ? 1.055 * n2(a2, 1 / 2.4) - 0.055 : 12.92 * a2, h2 = s2 &gt; o2 ? 1.055 * n2(s2, 1 / 2.4) - 0.055 : 12.92 * s2, c2 = r2 &gt; o2 ? 1.055 * n2(r2, 1 / 2.4) - 0.055 : 12.92 * r2;
      return new _xt(255 * l2, 255 * h2, 255 * c2);
    }
    if (&quot;hsl&quot; === this.space) {
      let { h: t3, s: e2, l: i2 } = this;
      if (t3 /= 360, e2 /= 100, i2 /= 100, 0 === e2) {
        i2 *= 255;
        return new _xt(i2, i2, i2);
      }
      const a2 = i2 &lt; 0.5 ? i2 * (1 + e2) : i2 + e2 - i2 * e2, s2 = 2 * i2 - a2, r2 = 255 * ft(s2, a2, t3 + 1 / 3), n2 = 255 * ft(s2, a2, t3), o2 = 255 * ft(s2, a2, t3 - 1 / 3);
      return new _xt(r2, n2, o2);
    }
    if (&quot;cmyk&quot; === this.space) {
      const { c: t3, m: e2, y: i2, k: a2 } = this, s2 = 255 * (1 - Math.min(1, t3 * (1 - a2) + a2)), r2 = 255 * (1 - Math.min(1, e2 * (1 - a2) + a2)), n2 = 255 * (1 - Math.min(1, i2 * (1 - a2) + a2));
      return new _xt(s2, r2, n2);
    }
    return this;
    var t2;
  }
  toArray() {
    const { _a: t2, _b: e2, _c: i2, _d: a2, space: s2 } = this;
    return [t2, e2, i2, a2, s2];
  }
  toHex() {
    const [t2, e2, i2] = this._clamped().map(gt);
    return `#${t2}${e2}${i2}`;
  }
  toRgb() {
    const [t2, e2, i2] = this._clamped();
    return `rgb(${t2},${e2},${i2})`;
  }
  toString() {
    return this.toHex();
  }
  xyz() {
    const { _a: t2, _b: e2, _c: i2 } = this.rgb(), [a2, s2, r2] = [t2, e2, i2].map((t3) =&gt; t3 / 255), n2 = a2 &gt; 0.04045 ? Math.pow((a2 + 0.055) / 1.055, 2.4) : a2 / 12.92, o2 = s2 &gt; 0.04045 ? Math.pow((s2 + 0.055) / 1.055, 2.4) : s2 / 12.92, l2 = r2 &gt; 0.04045 ? Math.pow((r2 + 0.055) / 1.055, 2.4) : r2 / 12.92, h2 = (0.4124 * n2 + 0.3576 * o2 + 0.1805 * l2) / 0.95047, c2 = (0.2126 * n2 + 0.7152 * o2 + 0.0722 * l2) / 1, d2 = (0.0193 * n2 + 0.1192 * o2 + 0.9505 * l2) / 1.08883, u2 = h2 &gt; 8856e-6 ? Math.pow(h2, 1 / 3) : 7.787 * h2 + 16 / 116, g2 = c2 &gt; 8856e-6 ? Math.pow(c2, 1 / 3) : 7.787 * c2 + 16 / 116, p2 = d2 &gt; 8856e-6 ? Math.pow(d2, 1 / 3) : 7.787 * d2 + 16 / 116;
    return new _xt(u2, g2, p2, &quot;xyz&quot;);
  }
  _clamped() {
    const { _a: t2, _b: e2, _c: i2 } = this.rgb(), { max: a2, min: s2, round: r2 } = Math;
    return [t2, e2, i2].map((t3) =&gt; a2(0, s2(r2(t3), 255)));
  }
};
var bt = class _bt {
  constructor(...t2) {
    this.init(...t2);
  }
  clone() {
    return new _bt(this);
  }
  init(t2, e2) {
    const i2 = 0, a2 = 0, s2 = Array.isArray(t2) ? { x: t2[0], y: t2[1] } : &quot;object&quot; == typeof t2 ? { x: t2.x, y: t2.y } : { x: t2, y: e2 };
    return this.x = null == s2.x ? i2 : s2.x, this.y = null == s2.y ? a2 : s2.y, this;
  }
  toArray() {
    return [this.x, this.y];
  }
  transform(t2) {
    return this.clone().transformO(t2);
  }
  transformO(t2) {
    vt.isMatrixLike(t2) || (t2 = new vt(t2));
    const { x: e2, y: i2 } = this;
    return this.x = t2.a * e2 + t2.c * i2 + t2.e, this.y = t2.b * e2 + t2.d * i2 + t2.f, this;
  }
};
function mt(t2, e2, i2) {
  return Math.abs(e2 - t2) &lt; (i2 || 1e-6);
}
var vt = class _vt {
  constructor(...t2) {
    this.init(...t2);
  }
  static formatTransforms(t2) {
    const e2 = &quot;both&quot; === t2.flip || true === t2.flip, i2 = t2.flip &amp;&amp; (e2 || &quot;x&quot; === t2.flip) ? -1 : 1, a2 = t2.flip &amp;&amp; (e2 || &quot;y&quot; === t2.flip) ? -1 : 1, s2 = t2.skew &amp;&amp; t2.skew.length ? t2.skew[0] : isFinite(t2.skew) ? t2.skew : isFinite(t2.skewX) ? t2.skewX : 0, r2 = t2.skew &amp;&amp; t2.skew.length ? t2.skew[1] : isFinite(t2.skew) ? t2.skew : isFinite(t2.skewY) ? t2.skewY : 0, n2 = t2.scale &amp;&amp; t2.scale.length ? t2.scale[0] * i2 : isFinite(t2.scale) ? t2.scale * i2 : isFinite(t2.scaleX) ? t2.scaleX * i2 : i2, o2 = t2.scale &amp;&amp; t2.scale.length ? t2.scale[1] * a2 : isFinite(t2.scale) ? t2.scale * a2 : isFinite(t2.scaleY) ? t2.scaleY * a2 : a2, l2 = t2.shear || 0, h2 = t2.rotate || t2.theta || 0, c2 = new bt(t2.origin || t2.around || t2.ox || t2.originX, t2.oy || t2.originY), d2 = c2.x, u2 = c2.y, g2 = new bt(t2.position || t2.px || t2.positionX || NaN, t2.py || t2.positionY || NaN), p2 = g2.x, f2 = g2.y, x2 = new bt(t2.translate || t2.tx || t2.translateX, t2.ty || t2.translateY), b2 = x2.x, m2 = x2.y, v2 = new bt(t2.relative || t2.rx || t2.relativeX, t2.ry || t2.relativeY);
    return { scaleX: n2, scaleY: o2, skewX: s2, skewY: r2, shear: l2, theta: h2, rx: v2.x, ry: v2.y, tx: b2, ty: m2, ox: d2, oy: u2, px: p2, py: f2 };
  }
  static fromArray(t2) {
    return { a: t2[0], b: t2[1], c: t2[2], d: t2[3], e: t2[4], f: t2[5] };
  }
  static isMatrixLike(t2) {
    return null != t2.a || null != t2.b || null != t2.c || null != t2.d || null != t2.e || null != t2.f;
  }
  static matrixMultiply(t2, e2, i2) {
    const a2 = t2.a * e2.a + t2.c * e2.b, s2 = t2.b * e2.a + t2.d * e2.b, r2 = t2.a * e2.c + t2.c * e2.d, n2 = t2.b * e2.c + t2.d * e2.d, o2 = t2.e + t2.a * e2.e + t2.c * e2.f, l2 = t2.f + t2.b * e2.e + t2.d * e2.f;
    return i2.a = a2, i2.b = s2, i2.c = r2, i2.d = n2, i2.e = o2, i2.f = l2, i2;
  }
  around(t2, e2, i2) {
    return this.clone().aroundO(t2, e2, i2);
  }
  aroundO(t2, e2, i2) {
    const a2 = t2 || 0, s2 = e2 || 0;
    return this.translateO(-a2, -s2).lmultiplyO(i2).translateO(a2, s2);
  }
  clone() {
    return new _vt(this);
  }
  decompose(t2 = 0, e2 = 0) {
    const i2 = this.a, a2 = this.b, s2 = this.c, r2 = this.d, n2 = this.e, o2 = this.f, l2 = i2 * r2 - a2 * s2, h2 = l2 &gt; 0 ? 1 : -1, c2 = h2 * Math.sqrt(i2 * i2 + a2 * a2), d2 = Math.atan2(h2 * a2, h2 * i2), u2 = 180 / Math.PI * d2, g2 = Math.cos(d2), p2 = Math.sin(d2), f2 = (i2 * s2 + a2 * r2) / l2, x2 = s2 * c2 / (f2 * i2 - a2) || r2 * c2 / (f2 * a2 + i2);
    return { scaleX: c2, scaleY: x2, shear: f2, rotate: u2, translateX: n2 - t2 + t2 * g2 * c2 + e2 * (f2 * g2 * c2 - p2 * x2), translateY: o2 - e2 + t2 * p2 * c2 + e2 * (f2 * p2 * c2 + g2 * x2), originX: t2, originY: e2, a: this.a, b: this.b, c: this.c, d: this.d, e: this.e, f: this.f };
  }
  equals(t2) {
    if (t2 === this) return true;
    const e2 = new _vt(t2);
    return mt(this.a, e2.a) &amp;&amp; mt(this.b, e2.b) &amp;&amp; mt(this.c, e2.c) &amp;&amp; mt(this.d, e2.d) &amp;&amp; mt(this.e, e2.e) &amp;&amp; mt(this.f, e2.f);
  }
  flip(t2, e2) {
    return this.clone().flipO(t2, e2);
  }
  flipO(t2, e2) {
    return &quot;x&quot; === t2 ? this.scaleO(-1, 1, e2, 0) : &quot;y&quot; === t2 ? this.scaleO(1, -1, 0, e2) : this.scaleO(-1, -1, t2, e2 || t2);
  }
  init(t2) {
    const e2 = _vt.fromArray([1, 0, 0, 1, 0, 0]);
    return t2 = t2 instanceof Gt ? t2.matrixify() : &quot;string&quot; == typeof t2 ? _vt.fromArray(t2.split(dt).map(parseFloat)) : Array.isArray(t2) ? _vt.fromArray(t2) : &quot;object&quot; == typeof t2 &amp;&amp; _vt.isMatrixLike(t2) ? t2 : &quot;object&quot; == typeof t2 ? new _vt().transform(t2) : 6 === arguments.length ? _vt.fromArray([].slice.call(arguments)) : e2, this.a = null != t2.a ? t2.a : e2.a, this.b = null != t2.b ? t2.b : e2.b, this.c = null != t2.c ? t2.c : e2.c, this.d = null != t2.d ? t2.d : e2.d, this.e = null != t2.e ? t2.e : e2.e, this.f = null != t2.f ? t2.f : e2.f, this;
  }
  inverse() {
    return this.clone().inverseO();
  }
  inverseO() {
    const t2 = this.a, e2 = this.b, i2 = this.c, a2 = this.d, s2 = this.e, r2 = this.f, n2 = t2 * a2 - e2 * i2;
    if (!n2) throw new Error(&quot;Cannot invert &quot; + this);
    const o2 = a2 / n2, l2 = -e2 / n2, h2 = -i2 / n2, c2 = t2 / n2, d2 = -(o2 * s2 + h2 * r2), u2 = -(l2 * s2 + c2 * r2);
    return this.a = o2, this.b = l2, this.c = h2, this.d = c2, this.e = d2, this.f = u2, this;
  }
  lmultiply(t2) {
    return this.clone().lmultiplyO(t2);
  }
  lmultiplyO(t2) {
    const e2 = t2 instanceof _vt ? t2 : new _vt(t2);
    return _vt.matrixMultiply(e2, this, this);
  }
  multiply(t2) {
    return this.clone().multiplyO(t2);
  }
  multiplyO(t2) {
    const e2 = t2 instanceof _vt ? t2 : new _vt(t2);
    return _vt.matrixMultiply(this, e2, this);
  }
  rotate(t2, e2, i2) {
    return this.clone().rotateO(t2, e2, i2);
  }
  rotateO(t2, e2 = 0, i2 = 0) {
    t2 = M(t2);
    const a2 = Math.cos(t2), s2 = Math.sin(t2), { a: r2, b: n2, c: o2, d: l2, e: h2, f: c2 } = this;
    return this.a = r2 * a2 - n2 * s2, this.b = n2 * a2 + r2 * s2, this.c = o2 * a2 - l2 * s2, this.d = l2 * a2 + o2 * s2, this.e = h2 * a2 - c2 * s2 + i2 * s2 - e2 * a2 + e2, this.f = c2 * a2 + h2 * s2 - e2 * s2 - i2 * a2 + i2, this;
  }
  scale() {
    return this.clone().scaleO(...arguments);
  }
  scaleO(t2, e2 = t2, i2 = 0, a2 = 0) {
    3 === arguments.length &amp;&amp; (a2 = i2, i2 = e2, e2 = t2);
    const { a: s2, b: r2, c: n2, d: o2, e: l2, f: h2 } = this;
    return this.a = s2 * t2, this.b = r2 * e2, this.c = n2 * t2, this.d = o2 * e2, this.e = l2 * t2 - i2 * t2 + i2, this.f = h2 * e2 - a2 * e2 + a2, this;
  }
  shear(t2, e2, i2) {
    return this.clone().shearO(t2, e2, i2);
  }
  shearO(t2, e2 = 0, i2 = 0) {
    const { a: a2, b: s2, c: r2, d: n2, e: o2, f: l2 } = this;
    return this.a = a2 + s2 * t2, this.c = r2 + n2 * t2, this.e = o2 + l2 * t2 - i2 * t2, this;
  }
  skew() {
    return this.clone().skewO(...arguments);
  }
  skewO(t2, e2 = t2, i2 = 0, a2 = 0) {
    3 === arguments.length &amp;&amp; (a2 = i2, i2 = e2, e2 = t2), t2 = M(t2), e2 = M(e2);
    const s2 = Math.tan(t2), r2 = Math.tan(e2), { a: n2, b: o2, c: l2, d: h2, e: c2, f: d2 } = this;
    return this.a = n2 + o2 * s2, this.b = o2 + n2 * r2, this.c = l2 + h2 * s2, this.d = h2 + l2 * r2, this.e = c2 + d2 * s2 - a2 * s2, this.f = d2 + c2 * r2 - i2 * r2, this;
  }
  skewX(t2, e2, i2) {
    return this.skew(t2, 0, e2, i2);
  }
  skewY(t2, e2, i2) {
    return this.skew(0, t2, e2, i2);
  }
  toArray() {
    return [this.a, this.b, this.c, this.d, this.e, this.f];
  }
  toString() {
    return &quot;matrix(&quot; + this.a + &quot;,&quot; + this.b + &quot;,&quot; + this.c + &quot;,&quot; + this.d + &quot;,&quot; + this.e + &quot;,&quot; + this.f + &quot;)&quot;;
  }
  transform(t2) {
    if (_vt.isMatrixLike(t2)) {
      return new _vt(t2).multiplyO(this);
    }
    const e2 = _vt.formatTransforms(t2), { x: i2, y: a2 } = new bt(e2.ox, e2.oy).transform(this), s2 = new _vt().translateO(e2.rx, e2.ry).lmultiplyO(this).translateO(-i2, -a2).scaleO(e2.scaleX, e2.scaleY).skewO(e2.skewX, e2.skewY).shearO(e2.shear).rotateO(e2.theta).translateO(i2, a2);
    if (isFinite(e2.px) || isFinite(e2.py)) {
      const t3 = new bt(i2, a2).transform(s2), r2 = isFinite(e2.px) ? e2.px - t3.x : 0, n2 = isFinite(e2.py) ? e2.py - t3.y : 0;
      s2.translateO(r2, n2);
    }
    return s2.translateO(e2.tx, e2.ty), s2;
  }
  translate(t2, e2) {
    return this.clone().translateO(t2, e2);
  }
  translateO(t2, e2) {
    return this.e += t2 || 0, this.f += e2 || 0, this;
  }
  valueOf() {
    return { a: this.a, b: this.b, c: this.c, d: this.d, e: this.e, f: this.f };
  }
};
function yt() {
  if (!yt.nodes) {
    const t2 = B().size(2, 0);
    t2.node.style.cssText = [&quot;opacity: 0&quot;, &quot;position: absolute&quot;, &quot;left: -100%&quot;, &quot;top: -100%&quot;, &quot;overflow: hidden&quot;].join(&quot;;&quot;), t2.attr(&quot;focusable&quot;, &quot;false&quot;), t2.attr(&quot;aria-hidden&quot;, &quot;true&quot;);
    const e2 = t2.path().node;
    yt.nodes = { svg: t2, path: e2 };
  }
  if (!yt.nodes.svg.node.parentNode) {
    const t2 = O.document.body || O.document.documentElement;
    yt.nodes.svg.addTo(t2);
  }
  return yt.nodes;
}
function wt(t2) {
  return !(t2.width || t2.height || t2.x || t2.y);
}
q(vt, &quot;Matrix&quot;);
var kt = class _kt {
  constructor(...t2) {
    this.init(...t2);
  }
  addOffset() {
    return this.x += O.window.pageXOffset, this.y += O.window.pageYOffset, new _kt(this);
  }
  init(t2) {
    return t2 = &quot;string&quot; == typeof t2 ? t2.split(dt).map(parseFloat) : Array.isArray(t2) ? t2 : &quot;object&quot; == typeof t2 ? [null != t2.left ? t2.left : t2.x, null != t2.top ? t2.top : t2.y, t2.width, t2.height] : 4 === arguments.length ? [].slice.call(arguments) : [0, 0, 0, 0], this.x = t2[0] || 0, this.y = t2[1] || 0, this.width = this.w = t2[2] || 0, this.height = this.h = t2[3] || 0, this.x2 = this.x + this.w, this.y2 = this.y + this.h, this.cx = this.x + this.w / 2, this.cy = this.y + this.h / 2, this;
  }
  isNulled() {
    return wt(this);
  }
  merge(t2) {
    const e2 = Math.min(this.x, t2.x), i2 = Math.min(this.y, t2.y), a2 = Math.max(this.x + this.width, t2.x + t2.width) - e2, s2 = Math.max(this.y + this.height, t2.y + t2.height) - i2;
    return new _kt(e2, i2, a2, s2);
  }
  toArray() {
    return [this.x, this.y, this.width, this.height];
  }
  toString() {
    return this.x + &quot; &quot; + this.y + &quot; &quot; + this.width + &quot; &quot; + this.height;
  }
  transform(t2) {
    t2 instanceof vt || (t2 = new vt(t2));
    let e2 = 1 / 0, i2 = -1 / 0, a2 = 1 / 0, s2 = -1 / 0;
    return [new bt(this.x, this.y), new bt(this.x2, this.y), new bt(this.x, this.y2), new bt(this.x2, this.y2)].forEach(function(r2) {
      r2 = r2.transform(t2), e2 = Math.min(e2, r2.x), i2 = Math.max(i2, r2.x), a2 = Math.min(a2, r2.y), s2 = Math.max(s2, r2.y);
    }), new _kt(e2, a2, i2 - e2, s2 - a2);
  }
};
function At(t2, e2, i2) {
  let a2;
  try {
    if (a2 = e2(t2.node), wt(a2) &amp;&amp; ((s2 = t2.node) !== O.document &amp;&amp; !(O.document.documentElement.contains || function(t3) {
      for (; t3.parentNode; ) t3 = t3.parentNode;
      return t3 === O.document;
    }).call(O.document.documentElement, s2))) throw new Error(&quot;Element not in the dom&quot;);
  } catch (e3) {
    a2 = i2(t2);
  }
  var s2;
  return a2;
}
A({ viewbox: { viewbox(t2, e2, i2, a2) {
  return null == t2 ? new kt(this.attr(&quot;viewBox&quot;)) : this.attr(&quot;viewBox&quot;, new kt(t2, e2, i2, a2));
}, zoom(t2, e2) {
  let { width: i2, height: a2 } = this.attr([&quot;width&quot;, &quot;height&quot;]);
  if ((i2 || a2) &amp;&amp; &quot;string&quot; != typeof i2 &amp;&amp; &quot;string&quot; != typeof a2 || (i2 = this.node.clientWidth, a2 = this.node.clientHeight), !i2 || !a2) throw new Error(&quot;Impossible to get absolute width and height. Please provide an absolute width and height attribute on the zooming element&quot;);
  const s2 = this.viewbox(), r2 = i2 / s2.width, n2 = a2 / s2.height, o2 = Math.min(r2, n2);
  if (null == t2) return o2;
  let l2 = o2 / t2;
  l2 === 1 / 0 &amp;&amp; (l2 = Number.MAX_SAFE_INTEGER / 100), e2 = e2 || new bt(i2 / 2 / r2 + s2.x, a2 / 2 / n2 + s2.y);
  const h2 = new kt(s2).transform(new vt({ scale: l2, origin: e2 }));
  return this.viewbox(h2);
} } }), q(kt, &quot;Box&quot;);
var Ct = class extends Array {
  constructor(t2 = [], ...e2) {
    if (super(t2, ...e2), &quot;number&quot; == typeof t2) return this;
    this.length = 0, this.push(...t2);
  }
};
Q([Ct], { each(t2, ...e2) {
  return &quot;function&quot; == typeof t2 ? this.map((e3, i2, a2) =&gt; t2.call(e3, e3, i2, a2)) : this.map((i2) =&gt; i2[t2](...e2));
}, toArray() {
  return Array.prototype.concat.apply([], this);
} });
var St = [&quot;toArray&quot;, &quot;constructor&quot;, &quot;each&quot;];
function Lt(t2, e2) {
  return new Ct(L((e2 || O.document).querySelectorAll(t2), function(t3) {
    return V(t3);
  }));
}
Ct.extend = function(t2) {
  t2 = t2.reduce((t3, e2) =&gt; (St.includes(e2) || &quot;_&quot; === e2[0] || (e2 in Array.prototype &amp;&amp; (t3[&quot;$&quot; + e2] = Array.prototype[e2]), t3[e2] = function(...t4) {
    return this.each(e2, ...t4);
  }), t3), {}), Q([Ct], t2);
};
var Mt = 0;
var Pt = {};
function It(t2) {
  let e2 = t2.getEventHolder();
  return e2 === O.window &amp;&amp; (e2 = Pt), e2.events || (e2.events = {}), e2.events;
}
function Tt(t2) {
  return t2.getEventTarget();
}
function zt(t2, e2, i2, a2, s2) {
  const r2 = i2.bind(a2 || t2), n2 = B(t2), o2 = It(n2), l2 = Tt(n2);
  e2 = Array.isArray(e2) ? e2 : e2.split(dt), i2._svgjsListenerId || (i2._svgjsListenerId = ++Mt), e2.forEach(function(t3) {
    const e3 = t3.split(&quot;.&quot;)[0], a3 = t3.split(&quot;.&quot;)[1] || &quot;*&quot;;
    o2[e3] = o2[e3] || {}, o2[e3][a3] = o2[e3][a3] || {}, o2[e3][a3][i2._svgjsListenerId] = r2, l2.addEventListener(e3, r2, s2 || false);
  });
}
function Xt(t2, e2, i2, a2) {
  const s2 = B(t2), r2 = It(s2), n2 = Tt(s2);
  (&quot;function&quot; != typeof i2 || (i2 = i2._svgjsListenerId)) &amp;&amp; (e2 = Array.isArray(e2) ? e2 : (e2 || &quot;&quot;).split(dt)).forEach(function(t3) {
    const e3 = t3 &amp;&amp; t3.split(&quot;.&quot;)[0], o2 = t3 &amp;&amp; t3.split(&quot;.&quot;)[1];
    let l2, h2;
    if (i2) r2[e3] &amp;&amp; r2[e3][o2 || &quot;*&quot;] &amp;&amp; (n2.removeEventListener(e3, r2[e3][o2 || &quot;*&quot;][i2], a2 || false), delete r2[e3][o2 || &quot;*&quot;][i2]);
    else if (e3 &amp;&amp; o2) {
      if (r2[e3] &amp;&amp; r2[e3][o2]) {
        for (h2 in r2[e3][o2]) Xt(n2, [e3, o2].join(&quot;.&quot;), h2);
        delete r2[e3][o2];
      }
    } else if (o2) for (t3 in r2) for (l2 in r2[t3]) o2 === l2 &amp;&amp; Xt(n2, [t3, o2].join(&quot;.&quot;));
    else if (e3) {
      if (r2[e3]) {
        for (l2 in r2[e3]) Xt(n2, [e3, l2].join(&quot;.&quot;));
        delete r2[e3];
      }
    } else {
      for (t3 in r2) Xt(n2, t3);
      !function(t4) {
        let e4 = t4.getEventHolder();
        e4 === O.window &amp;&amp; (e4 = Pt), e4.events &amp;&amp; (e4.events = {});
      }(s2);
    }
  });
}
var Rt = class extends D {
  addEventListener() {
  }
  dispatch(t2, e2, i2) {
    return function(t3, e3, i3, a2) {
      const s2 = Tt(t3);
      return e3 instanceof O.window.Event || (e3 = new O.window.CustomEvent(e3, { detail: i3, cancelable: true, ...a2 })), s2.dispatchEvent(e3), e3;
    }(this, t2, e2, i2);
  }
  dispatchEvent(t2) {
    const e2 = this.getEventHolder().events;
    if (!e2) return true;
    const i2 = e2[t2.type];
    for (const e3 in i2) for (const a2 in i2[e3]) i2[e3][a2](t2);
    return !t2.defaultPrevented;
  }
  fire(t2, e2, i2) {
    return this.dispatch(t2, e2, i2), this;
  }
  getEventHolder() {
    return this;
  }
  getEventTarget() {
    return this;
  }
  off(t2, e2, i2) {
    return Xt(this, t2, e2, i2), this;
  }
  on(t2, e2, i2, a2) {
    return zt(this, t2, e2, i2, a2), this;
  }
  removeEventListener() {
  }
};
function Et() {
}
q(Rt, &quot;EventTarget&quot;);
var Yt = 400;
var Ht = &quot;&gt;&quot;;
var Ot = 0;
var Ft = { &quot;fill-opacity&quot;: 1, &quot;stroke-opacity&quot;: 1, &quot;stroke-width&quot;: 0, &quot;stroke-linejoin&quot;: &quot;miter&quot;, &quot;stroke-linecap&quot;: &quot;butt&quot;, fill: &quot;#000000&quot;, stroke: &quot;#000000&quot;, opacity: 1, x: 0, y: 0, cx: 0, cy: 0, width: 0, height: 0, r: 0, rx: 0, ry: 0, offset: 0, &quot;stop-opacity&quot;: 1, &quot;stop-color&quot;: &quot;#000000&quot;, &quot;text-anchor&quot;: &quot;start&quot; };
var Dt = class extends Array {
  constructor(...t2) {
    super(...t2), this.init(...t2);
  }
  clone() {
    return new this.constructor(this);
  }
  init(t2) {
    return &quot;number&quot; == typeof t2 || (this.length = 0, this.push(...this.parse(t2))), this;
  }
  parse(t2 = []) {
    return t2 instanceof Array ? t2 : t2.trim().split(dt).map(parseFloat);
  }
  toArray() {
    return Array.prototype.concat.apply([], this);
  }
  toSet() {
    return new Set(this);
  }
  toString() {
    return this.join(&quot; &quot;);
  }
  valueOf() {
    const t2 = [];
    return t2.push(...this), t2;
  }
};
var _t = class __t {
  constructor(...t2) {
    this.init(...t2);
  }
  convert(t2) {
    return new __t(this.value, t2);
  }
  divide(t2) {
    return t2 = new __t(t2), new __t(this / t2, this.unit || t2.unit);
  }
  init(t2, e2) {
    return e2 = Array.isArray(t2) ? t2[1] : e2, t2 = Array.isArray(t2) ? t2[0] : t2, this.value = 0, this.unit = e2 || &quot;&quot;, &quot;number&quot; == typeof t2 ? this.value = isNaN(t2) ? 0 : isFinite(t2) ? t2 : t2 &lt; 0 ? -34e37 : 34e37 : &quot;string&quot; == typeof t2 ? (e2 = t2.match(tt)) &amp;&amp; (this.value = parseFloat(e2[1]), &quot;%&quot; === e2[5] ? this.value /= 100 : &quot;s&quot; === e2[5] &amp;&amp; (this.value *= 1e3), this.unit = e2[5]) : t2 instanceof __t &amp;&amp; (this.value = t2.valueOf(), this.unit = t2.unit), this;
  }
  minus(t2) {
    return t2 = new __t(t2), new __t(this - t2, this.unit || t2.unit);
  }
  plus(t2) {
    return t2 = new __t(t2), new __t(this + t2, this.unit || t2.unit);
  }
  times(t2) {
    return t2 = new __t(t2), new __t(this * t2, this.unit || t2.unit);
  }
  toArray() {
    return [this.value, this.unit];
  }
  toJSON() {
    return this.toString();
  }
  toString() {
    return (&quot;%&quot; === this.unit ? ~~(1e8 * this.value) / 1e6 : &quot;s&quot; === this.unit ? this.value / 1e3 : this.value) + this.unit;
  }
  valueOf() {
    return this.value;
  }
};
var Nt = /* @__PURE__ */ new Set([&quot;fill&quot;, &quot;stroke&quot;, &quot;color&quot;, &quot;bgcolor&quot;, &quot;stop-color&quot;, &quot;flood-color&quot;, &quot;lighting-color&quot;]);
var Wt = [];
var Bt = class _Bt extends Rt {
  constructor(t2, e2) {
    super(), this.node = t2, this.type = t2.nodeName, e2 &amp;&amp; t2 !== e2 &amp;&amp; this.attr(e2);
  }
  add(t2, e2) {
    return (t2 = B(t2)).removeNamespace &amp;&amp; this.node instanceof O.window.SVGElement &amp;&amp; t2.removeNamespace(), null == e2 ? this.node.appendChild(t2.node) : t2.node !== this.node.childNodes[e2] &amp;&amp; this.node.insertBefore(t2.node, this.node.childNodes[e2]), this;
  }
  addTo(t2, e2) {
    return B(t2).put(this, e2);
  }
  children() {
    return new Ct(L(this.node.children, function(t2) {
      return V(t2);
    }));
  }
  clear() {
    for (; this.node.hasChildNodes(); ) this.node.removeChild(this.node.lastChild);
    return this;
  }
  clone(t2 = true, e2 = true) {
    this.writeDataToDom();
    let i2 = this.node.cloneNode(t2);
    return e2 &amp;&amp; (i2 = J(i2)), new this.constructor(i2);
  }
  each(t2, e2) {
    const i2 = this.children();
    let a2, s2;
    for (a2 = 0, s2 = i2.length; a2 &lt; s2; a2++) t2.apply(i2[a2], [a2, i2]), e2 &amp;&amp; i2[a2].each(t2, e2);
    return this;
  }
  element(t2, e2) {
    return this.put(new _Bt(W(t2), e2));
  }
  first() {
    return V(this.node.firstChild);
  }
  get(t2) {
    return V(this.node.childNodes[t2]);
  }
  getEventHolder() {
    return this.node;
  }
  getEventTarget() {
    return this.node;
  }
  has(t2) {
    return this.index(t2) &gt;= 0;
  }
  html(t2, e2) {
    return this.xml(t2, e2, &quot;http://www.w3.org/1999/xhtml&quot;);
  }
  id(t2) {
    return void 0 !== t2 || this.node.id || (this.node.id = $(this.type)), this.attr(&quot;id&quot;, t2);
  }
  index(t2) {
    return [].slice.call(this.node.childNodes).indexOf(t2.node);
  }
  last() {
    return V(this.node.lastChild);
  }
  matches(t2) {
    const e2 = this.node, i2 = e2.matches || e2.matchesSelector || e2.msMatchesSelector || e2.mozMatchesSelector || e2.webkitMatchesSelector || e2.oMatchesSelector || null;
    return i2 &amp;&amp; i2.call(e2, t2);
  }
  parent(t2) {
    let e2 = this;
    if (!e2.node.parentNode) return null;
    if (e2 = V(e2.node.parentNode), !t2) return e2;
    do {
      if (&quot;string&quot; == typeof t2 ? e2.matches(t2) : e2 instanceof t2) return e2;
    } while (e2 = V(e2.node.parentNode));
    return e2;
  }
  put(t2, e2) {
    return t2 = B(t2), this.add(t2, e2), t2;
  }
  putIn(t2, e2) {
    return B(t2).add(this, e2);
  }
  remove() {
    return this.parent() &amp;&amp; this.parent().removeElement(this), this;
  }
  removeElement(t2) {
    return this.node.removeChild(t2.node), this;
  }
  replace(t2) {
    return t2 = B(t2), this.node.parentNode &amp;&amp; this.node.parentNode.replaceChild(t2.node, this.node), t2;
  }
  round(t2 = 2, e2 = null) {
    const i2 = 10 ** t2, a2 = this.attr(e2);
    for (const t3 in a2) &quot;number&quot; == typeof a2[t3] &amp;&amp; (a2[t3] = Math.round(a2[t3] * i2) / i2);
    return this.attr(a2), this;
  }
  svg(t2, e2) {
    return this.xml(t2, e2, E);
  }
  toString() {
    return this.id();
  }
  words(t2) {
    return this.node.textContent = t2, this;
  }
  wrap(t2) {
    const e2 = this.parent();
    if (!e2) return this.addTo(t2);
    const i2 = e2.index(this);
    return e2.put(t2, i2).put(this);
  }
  writeDataToDom() {
    return this.each(function() {
      this.writeDataToDom();
    }), this;
  }
  xml(t2, e2, i2) {
    if (&quot;boolean&quot; == typeof t2 &amp;&amp; (i2 = e2, e2 = t2, t2 = null), null == t2 || &quot;function&quot; == typeof t2) {
      e2 = null == e2 || e2, this.writeDataToDom();
      let i3 = this;
      if (null != t2) {
        if (i3 = V(i3.node.cloneNode(true)), e2) {
          const e3 = t2(i3);
          if (i3 = e3 || i3, false === e3) return &quot;&quot;;
        }
        i3.each(function() {
          const e3 = t2(this), i4 = e3 || this;
          false === e3 ? this.remove() : e3 &amp;&amp; this !== i4 &amp;&amp; this.replace(i4);
        }, true);
      }
      return e2 ? i3.node.outerHTML : i3.node.innerHTML;
    }
    e2 = null != e2 &amp;&amp; e2;
    const a2 = W(&quot;wrapper&quot;, i2), s2 = O.document.createDocumentFragment();
    a2.innerHTML = t2;
    for (let t3 = a2.children.length; t3--; ) s2.appendChild(a2.firstElementChild);
    const r2 = this.parent();
    return e2 ? this.replace(s2) &amp;&amp; r2 : this.add(s2);
  }
};
Q(Bt, { attr: function(t2, e2, i2) {
  if (null == t2) {
    t2 = {}, e2 = this.node.attributes;
    for (const i3 of e2) t2[i3.nodeName] = ht.test(i3.nodeValue) ? parseFloat(i3.nodeValue) : i3.nodeValue;
    return t2;
  }
  if (t2 instanceof Array) return t2.reduce((t3, e3) =&gt; (t3[e3] = this.attr(e3), t3), {});
  if (&quot;object&quot; == typeof t2 &amp;&amp; t2.constructor === Object) for (e2 in t2) this.attr(e2, t2[e2]);
  else if (null === e2) this.node.removeAttribute(t2);
  else {
    if (null == e2) return null == (e2 = this.node.getAttribute(t2)) ? Ft[t2] : ht.test(e2) ? parseFloat(e2) : e2;
    &quot;number&quot; == typeof (e2 = Wt.reduce((e3, i3) =&gt; i3(t2, e3, this), e2)) ? e2 = new _t(e2) : Nt.has(t2) &amp;&amp; xt.isColor(e2) ? e2 = new xt(e2) : e2.constructor === Array &amp;&amp; (e2 = new Dt(e2)), &quot;leading&quot; === t2 ? this.leading &amp;&amp; this.leading(e2) : &quot;string&quot; == typeof i2 ? this.node.setAttributeNS(i2, t2, e2.toString()) : this.node.setAttribute(t2, e2.toString()), !this.rebuild || &quot;font-size&quot; !== t2 &amp;&amp; &quot;x&quot; !== t2 || this.rebuild();
  }
  return this;
}, find: function(t2) {
  return Lt(t2, this.node);
}, findOne: function(t2) {
  return V(this.node.querySelector(t2));
} }), q(Bt, &quot;Dom&quot;);
var Gt = class extends Bt {
  constructor(t2, e2) {
    super(t2, e2), this.dom = {}, this.node.instance = this, (t2.hasAttribute(&quot;data-svgjs&quot;) || t2.hasAttribute(&quot;svgjs:data&quot;)) &amp;&amp; this.setData(JSON.parse(t2.getAttribute(&quot;data-svgjs&quot;)) ?? JSON.parse(t2.getAttribute(&quot;svgjs:data&quot;)) ?? {});
  }
  center(t2, e2) {
    return this.cx(t2).cy(e2);
  }
  cx(t2) {
    return null == t2 ? this.x() + this.width() / 2 : this.x(t2 - this.width() / 2);
  }
  cy(t2) {
    return null == t2 ? this.y() + this.height() / 2 : this.y(t2 - this.height() / 2);
  }
  defs() {
    const t2 = this.root();
    return t2 &amp;&amp; t2.defs();
  }
  dmove(t2, e2) {
    return this.dx(t2).dy(e2);
  }
  dx(t2 = 0) {
    return this.x(new _t(t2).plus(this.x()));
  }
  dy(t2 = 0) {
    return this.y(new _t(t2).plus(this.y()));
  }
  getEventHolder() {
    return this;
  }
  height(t2) {
    return this.attr(&quot;height&quot;, t2);
  }
  move(t2, e2) {
    return this.x(t2).y(e2);
  }
  parents(t2 = this.root()) {
    const e2 = &quot;string&quot; == typeof t2;
    e2 || (t2 = B(t2));
    const i2 = new Ct();
    let a2 = this;
    for (; (a2 = a2.parent()) &amp;&amp; a2.node !== O.document &amp;&amp; &quot;#document-fragment&quot; !== a2.nodeName &amp;&amp; (i2.push(a2), e2 || a2.node !== t2.node) &amp;&amp; (!e2 || !a2.matches(t2)); ) if (a2.node === this.root().node) return null;
    return i2;
  }
  reference(t2) {
    if (!(t2 = this.attr(t2))) return null;
    const e2 = (t2 + &quot;&quot;).match(at);
    return e2 ? B(e2[1]) : null;
  }
  root() {
    const t2 = this.parent(function(t3) {
      return _[t3];
    }(N));
    return t2 &amp;&amp; t2.root();
  }
  setData(t2) {
    return this.dom = t2, this;
  }
  size(t2, e2) {
    const i2 = I(this, t2, e2);
    return this.width(new _t(i2.width)).height(new _t(i2.height));
  }
  width(t2) {
    return this.attr(&quot;width&quot;, t2);
  }
  writeDataToDom() {
    return R(this, this.dom), super.writeDataToDom();
  }
  x(t2) {
    return this.attr(&quot;x&quot;, t2);
  }
  y(t2) {
    return this.attr(&quot;y&quot;, t2);
  }
};
Q(Gt, { bbox: function() {
  const t2 = At(this, (t3) =&gt; t3.getBBox(), (t3) =&gt; {
    try {
      const e2 = t3.clone().addTo(yt().svg).show(), i2 = e2.node.getBBox();
      return e2.remove(), i2;
    } catch (e2) {
      throw new Error(`Getting bbox of element &quot;${t3.node.nodeName}&quot; is not possible: ${e2.toString()}`);
    }
  });
  return new kt(t2);
}, rbox: function(t2) {
  const e2 = At(this, (t3) =&gt; t3.getBoundingClientRect(), (t3) =&gt; {
    throw new Error(`Getting rbox of element &quot;${t3.node.nodeName}&quot; is not possible`);
  }), i2 = new kt(e2);
  return t2 ? i2.transform(t2.screenCTM().inverseO()) : i2.addOffset();
}, inside: function(t2, e2) {
  const i2 = this.bbox();
  return t2 &gt; i2.x &amp;&amp; e2 &gt; i2.y &amp;&amp; t2 &lt; i2.x + i2.width &amp;&amp; e2 &lt; i2.y + i2.height;
}, point: function(t2, e2) {
  return new bt(t2, e2).transformO(this.screenCTM().inverseO());
}, ctm: function() {
  return new vt(this.node.getCTM());
}, screenCTM: function() {
  try {
    if (&quot;function&quot; == typeof this.isRoot &amp;&amp; !this.isRoot()) {
      const t2 = this.rect(1, 1), e2 = t2.node.getScreenCTM();
      return t2.remove(), new vt(e2);
    }
    return new vt(this.node.getScreenCTM());
  } catch (t2) {
    return console.warn(`Cannot get CTM from SVG node ${this.node.nodeName}. Is the element rendered?`), new vt();
  }
} }), q(Gt, &quot;Element&quot;);
var jt = { stroke: [&quot;color&quot;, &quot;width&quot;, &quot;opacity&quot;, &quot;linecap&quot;, &quot;linejoin&quot;, &quot;miterlimit&quot;, &quot;dasharray&quot;, &quot;dashoffset&quot;], fill: [&quot;color&quot;, &quot;opacity&quot;, &quot;rule&quot;], prefix: function(t2, e2) {
  return &quot;color&quot; === e2 ? t2 : t2 + &quot;-&quot; + e2;
} };
[&quot;fill&quot;, &quot;stroke&quot;].forEach(function(t2) {
  const e2 = {};
  let i2;
  e2[t2] = function(e3) {
    if (void 0 === e3) return this.attr(t2);
    if (&quot;string&quot; == typeof e3 || e3 instanceof xt || xt.isRgb(e3) || e3 instanceof Gt) this.attr(t2, e3);
    else for (i2 = jt[t2].length - 1; i2 &gt;= 0; i2--) null != e3[jt[t2][i2]] &amp;&amp; this.attr(jt.prefix(t2, jt[t2][i2]), e3[jt[t2][i2]]);
    return this;
  }, A([&quot;Element&quot;, &quot;Runner&quot;], e2);
}), A([&quot;Element&quot;, &quot;Runner&quot;], { matrix: function(t2, e2, i2, a2, s2, r2) {
  return null == t2 ? new vt(this) : this.attr(&quot;transform&quot;, new vt(t2, e2, i2, a2, s2, r2));
}, rotate: function(t2, e2, i2) {
  return this.transform({ rotate: t2, ox: e2, oy: i2 }, true);
}, skew: function(t2, e2, i2, a2) {
  return 1 === arguments.length || 3 === arguments.length ? this.transform({ skew: t2, ox: e2, oy: i2 }, true) : this.transform({ skew: [t2, e2], ox: i2, oy: a2 }, true);
}, shear: function(t2, e2, i2) {
  return this.transform({ shear: t2, ox: e2, oy: i2 }, true);
}, scale: function(t2, e2, i2, a2) {
  return 1 === arguments.length || 3 === arguments.length ? this.transform({ scale: t2, ox: e2, oy: i2 }, true) : this.transform({ scale: [t2, e2], ox: i2, oy: a2 }, true);
}, translate: function(t2, e2) {
  return this.transform({ translate: [t2, e2] }, true);
}, relative: function(t2, e2) {
  return this.transform({ relative: [t2, e2] }, true);
}, flip: function(t2 = &quot;both&quot;, e2 = &quot;center&quot;) {
  return -1 === &quot;xybothtrue&quot;.indexOf(t2) &amp;&amp; (e2 = t2, t2 = &quot;both&quot;), this.transform({ flip: t2, origin: e2 }, true);
}, opacity: function(t2) {
  return this.attr(&quot;opacity&quot;, t2);
} }), A(&quot;radius&quot;, { radius: function(t2, e2 = t2) {
  return &quot;radialGradient&quot; === (this._element || this).type ? this.attr(&quot;r&quot;, new _t(t2)) : this.rx(t2).ry(e2);
} }), A(&quot;Path&quot;, { length: function() {
  return this.node.getTotalLength();
}, pointAt: function(t2) {
  return new bt(this.node.getPointAtLength(t2));
} }), A([&quot;Element&quot;, &quot;Runner&quot;], { font: function(t2, e2) {
  if (&quot;object&quot; == typeof t2) {
    for (e2 in t2) this.font(e2, t2[e2]);
    return this;
  }
  return &quot;leading&quot; === t2 ? this.leading(e2) : &quot;anchor&quot; === t2 ? this.attr(&quot;text-anchor&quot;, e2) : &quot;size&quot; === t2 || &quot;family&quot; === t2 || &quot;weight&quot; === t2 || &quot;stretch&quot; === t2 || &quot;variant&quot; === t2 || &quot;style&quot; === t2 ? this.attr(&quot;font-&quot; + t2, e2) : this.attr(t2, e2);
} });
A(&quot;Element&quot;, [&quot;click&quot;, &quot;dblclick&quot;, &quot;mousedown&quot;, &quot;mouseup&quot;, &quot;mouseover&quot;, &quot;mouseout&quot;, &quot;mousemove&quot;, &quot;mouseenter&quot;, &quot;mouseleave&quot;, &quot;touchstart&quot;, &quot;touchmove&quot;, &quot;touchleave&quot;, &quot;touchend&quot;, &quot;touchcancel&quot;, &quot;contextmenu&quot;, &quot;wheel&quot;, &quot;pointerdown&quot;, &quot;pointermove&quot;, &quot;pointerup&quot;, &quot;pointerleave&quot;, &quot;pointercancel&quot;].reduce(function(t2, e2) {
  return t2[e2] = function(t3) {
    return null === t3 ? this.off(e2) : this.on(e2, t3), this;
  }, t2;
}, {})), A(&quot;Element&quot;, { untransform: function() {
  return this.attr(&quot;transform&quot;, null);
}, matrixify: function() {
  const t2 = (this.attr(&quot;transform&quot;) || &quot;&quot;).split(st).slice(0, -1).map(function(t3) {
    const e2 = t3.trim().split(&quot;(&quot;);
    return [e2[0], e2[1].split(dt).map(function(t4) {
      return parseFloat(t4);
    })];
  }).reverse().reduce(function(t3, e2) {
    return &quot;matrix&quot; === e2[0] ? t3.lmultiply(vt.fromArray(e2[1])) : t3[e2[0]].apply(t3, e2[1]);
  }, new vt());
  return t2;
}, toParent: function(t2, e2) {
  if (this === t2) return this;
  if (X(this.node)) return this.addTo(t2, e2);
  const i2 = this.screenCTM(), a2 = t2.screenCTM().inverse();
  return this.addTo(t2, e2).untransform().transform(a2.multiply(i2)), this;
}, toRoot: function(t2) {
  return this.toParent(this.root(), t2);
}, transform: function(t2, e2) {
  if (null == t2 || &quot;string&quot; == typeof t2) {
    const e3 = new vt(this).decompose();
    return null == t2 ? e3 : e3[t2];
  }
  vt.isMatrixLike(t2) || (t2 = { ...t2, origin: T(t2, this) });
  const i2 = new vt(true === e2 ? this : e2 || false).transform(t2);
  return this.attr(&quot;transform&quot;, i2);
} });
var Vt = class _Vt extends Gt {
  flatten() {
    return this.each(function() {
      if (this instanceof _Vt) return this.flatten().ungroup();
    }), this;
  }
  ungroup(t2 = this.parent(), e2 = t2.index(this)) {
    return e2 = -1 === e2 ? t2.children().length : e2, this.each(function(i2, a2) {
      return a2[a2.length - i2 - 1].toParent(t2, e2);
    }), this.remove();
  }
};
q(Vt, &quot;Container&quot;);
var Ut = class extends Vt {
  constructor(t2, e2 = t2) {
    super(G(&quot;defs&quot;, t2), e2);
  }
  flatten() {
    return this;
  }
  ungroup() {
    return this;
  }
};
q(Ut, &quot;Defs&quot;);
var qt = class extends Gt {
};
function Zt(t2) {
  return this.attr(&quot;rx&quot;, t2);
}
function $t(t2) {
  return this.attr(&quot;ry&quot;, t2);
}
function Jt(t2) {
  return null == t2 ? this.cx() - this.rx() : this.cx(t2 + this.rx());
}
function Qt(t2) {
  return null == t2 ? this.cy() - this.ry() : this.cy(t2 + this.ry());
}
function Kt(t2) {
  return this.attr(&quot;cx&quot;, t2);
}
function te(t2) {
  return this.attr(&quot;cy&quot;, t2);
}
function ee(t2) {
  return null == t2 ? 2 * this.rx() : this.rx(new _t(t2).divide(2));
}
function ie(t2) {
  return null == t2 ? 2 * this.ry() : this.ry(new _t(t2).divide(2));
}
q(qt, &quot;Shape&quot;);
var ae = Object.freeze({ __proto__: null, cx: Kt, cy: te, height: ie, rx: Zt, ry: $t, width: ee, x: Jt, y: Qt });
var se = class extends qt {
  constructor(t2, e2 = t2) {
    super(G(&quot;ellipse&quot;, t2), e2);
  }
  size(t2, e2) {
    const i2 = I(this, t2, e2);
    return this.rx(new _t(i2.width).divide(2)).ry(new _t(i2.height).divide(2));
  }
};
Q(se, ae), A(&quot;Container&quot;, { ellipse: K(function(t2 = 0, e2 = t2) {
  return this.put(new se()).size(t2, e2).move(0, 0);
}) }), q(se, &quot;Ellipse&quot;);
var re = class extends Bt {
  constructor(t2 = O.document.createDocumentFragment()) {
    super(t2);
  }
  xml(t2, e2, i2) {
    if (&quot;boolean&quot; == typeof t2 &amp;&amp; (i2 = e2, e2 = t2, t2 = null), null == t2 || &quot;function&quot; == typeof t2) {
      const t3 = new Bt(W(&quot;wrapper&quot;, i2));
      return t3.add(this.node.cloneNode(true)), t3.xml(false, i2);
    }
    return super.xml(t2, false, i2);
  }
};
function ne(t2, e2) {
  return &quot;radialGradient&quot; === (this._element || this).type ? this.attr({ fx: new _t(t2), fy: new _t(e2) }) : this.attr({ x1: new _t(t2), y1: new _t(e2) });
}
function oe(t2, e2) {
  return &quot;radialGradient&quot; === (this._element || this).type ? this.attr({ cx: new _t(t2), cy: new _t(e2) }) : this.attr({ x2: new _t(t2), y2: new _t(e2) });
}
q(re, &quot;Fragment&quot;);
var le = Object.freeze({ __proto__: null, from: ne, to: oe });
var he = class extends Vt {
  constructor(t2, e2) {
    super(G(t2 + &quot;Gradient&quot;, &quot;string&quot; == typeof t2 ? null : t2), e2);
  }
  attr(t2, e2, i2) {
    return &quot;transform&quot; === t2 &amp;&amp; (t2 = &quot;gradientTransform&quot;), super.attr(t2, e2, i2);
  }
  bbox() {
    return new kt();
  }
  targets() {
    return Lt(&quot;svg [fill*=&quot; + this.id() + &quot;]&quot;);
  }
  toString() {
    return this.url();
  }
  update(t2) {
    return this.clear(), &quot;function&quot; == typeof t2 &amp;&amp; t2.call(this, this), this;
  }
  url() {
    return &quot;url(#&quot; + this.id() + &quot;)&quot;;
  }
};
Q(he, le), A({ Container: { gradient(...t2) {
  return this.defs().gradient(...t2);
} }, Defs: { gradient: K(function(t2, e2) {
  return this.put(new he(t2)).update(e2);
}) } }), q(he, &quot;Gradient&quot;);
var ce = class extends Vt {
  constructor(t2, e2 = t2) {
    super(G(&quot;pattern&quot;, t2), e2);
  }
  attr(t2, e2, i2) {
    return &quot;transform&quot; === t2 &amp;&amp; (t2 = &quot;patternTransform&quot;), super.attr(t2, e2, i2);
  }
  bbox() {
    return new kt();
  }
  targets() {
    return Lt(&quot;svg [fill*=&quot; + this.id() + &quot;]&quot;);
  }
  toString() {
    return this.url();
  }
  update(t2) {
    return this.clear(), &quot;function&quot; == typeof t2 &amp;&amp; t2.call(this, this), this;
  }
  url() {
    return &quot;url(#&quot; + this.id() + &quot;)&quot;;
  }
};
A({ Container: { pattern(...t2) {
  return this.defs().pattern(...t2);
} }, Defs: { pattern: K(function(t2, e2, i2) {
  return this.put(new ce()).update(i2).attr({ x: 0, y: 0, width: t2, height: e2, patternUnits: &quot;userSpaceOnUse&quot; });
}) } }), q(ce, &quot;Pattern&quot;);
var de = class extends qt {
  constructor(t2, e2 = t2) {
    super(G(&quot;image&quot;, t2), e2);
  }
  load(t2, e2) {
    if (!t2) return this;
    const i2 = new O.window.Image();
    return zt(i2, &quot;load&quot;, function(t3) {
      const a2 = this.parent(ce);
      0 === this.width() &amp;&amp; 0 === this.height() &amp;&amp; this.size(i2.width, i2.height), a2 instanceof ce &amp;&amp; 0 === a2.width() &amp;&amp; 0 === a2.height() &amp;&amp; a2.size(this.width(), this.height()), &quot;function&quot; == typeof e2 &amp;&amp; e2.call(this, t3);
    }, this), zt(i2, &quot;load error&quot;, function() {
      Xt(i2);
    }), this.attr(&quot;href&quot;, i2.src = t2, H);
  }
};
var ue;
ue = function(t2, e2, i2) {
  return &quot;fill&quot; !== t2 &amp;&amp; &quot;stroke&quot; !== t2 || ct.test(e2) &amp;&amp; (e2 = i2.root().defs().image(e2)), e2 instanceof de &amp;&amp; (e2 = i2.root().defs().pattern(0, 0, (t3) =&gt; {
    t3.add(e2);
  })), e2;
}, Wt.push(ue), A({ Container: { image: K(function(t2, e2) {
  return this.put(new de()).size(0, 0).load(t2, e2);
}) } }), q(de, &quot;Image&quot;);
var ge = class extends Dt {
  bbox() {
    let t2 = -1 / 0, e2 = -1 / 0, i2 = 1 / 0, a2 = 1 / 0;
    return this.forEach(function(s2) {
      t2 = Math.max(s2[0], t2), e2 = Math.max(s2[1], e2), i2 = Math.min(s2[0], i2), a2 = Math.min(s2[1], a2);
    }), new kt(i2, a2, t2 - i2, e2 - a2);
  }
  move(t2, e2) {
    const i2 = this.bbox();
    if (t2 -= i2.x, e2 -= i2.y, !isNaN(t2) &amp;&amp; !isNaN(e2)) for (let i3 = this.length - 1; i3 &gt;= 0; i3--) this[i3] = [this[i3][0] + t2, this[i3][1] + e2];
    return this;
  }
  parse(t2 = [0, 0]) {
    const e2 = [];
    (t2 = t2 instanceof Array ? Array.prototype.concat.apply([], t2) : t2.trim().split(dt).map(parseFloat)).length % 2 != 0 &amp;&amp; t2.pop();
    for (let i2 = 0, a2 = t2.length; i2 &lt; a2; i2 += 2) e2.push([t2[i2], t2[i2 + 1]]);
    return e2;
  }
  size(t2, e2) {
    let i2;
    const a2 = this.bbox();
    for (i2 = this.length - 1; i2 &gt;= 0; i2--) a2.width &amp;&amp; (this[i2][0] = (this[i2][0] - a2.x) * t2 / a2.width + a2.x), a2.height &amp;&amp; (this[i2][1] = (this[i2][1] - a2.y) * e2 / a2.height + a2.y);
    return this;
  }
  toLine() {
    return { x1: this[0][0], y1: this[0][1], x2: this[1][0], y2: this[1][1] };
  }
  toString() {
    const t2 = [];
    for (let e2 = 0, i2 = this.length; e2 &lt; i2; e2++) t2.push(this[e2].join(&quot;,&quot;));
    return t2.join(&quot; &quot;);
  }
  transform(t2) {
    return this.clone().transformO(t2);
  }
  transformO(t2) {
    vt.isMatrixLike(t2) || (t2 = new vt(t2));
    for (let e2 = this.length; e2--; ) {
      const [i2, a2] = this[e2];
      this[e2][0] = t2.a * i2 + t2.c * a2 + t2.e, this[e2][1] = t2.b * i2 + t2.d * a2 + t2.f;
    }
    return this;
  }
};
var pe = ge;
var fe = Object.freeze({ __proto__: null, MorphArray: pe, height: function(t2) {
  const e2 = this.bbox();
  return null == t2 ? e2.height : this.size(e2.width, t2);
}, width: function(t2) {
  const e2 = this.bbox();
  return null == t2 ? e2.width : this.size(t2, e2.height);
}, x: function(t2) {
  return null == t2 ? this.bbox().x : this.move(t2, this.bbox().y);
}, y: function(t2) {
  return null == t2 ? this.bbox().y : this.move(this.bbox().x, t2);
} });
var xe = class extends qt {
  constructor(t2, e2 = t2) {
    super(G(&quot;line&quot;, t2), e2);
  }
  array() {
    return new ge([[this.attr(&quot;x1&quot;), this.attr(&quot;y1&quot;)], [this.attr(&quot;x2&quot;), this.attr(&quot;y2&quot;)]]);
  }
  move(t2, e2) {
    return this.attr(this.array().move(t2, e2).toLine());
  }
  plot(t2, e2, i2, a2) {
    return null == t2 ? this.array() : (t2 = void 0 !== e2 ? { x1: t2, y1: e2, x2: i2, y2: a2 } : new ge(t2).toLine(), this.attr(t2));
  }
  size(t2, e2) {
    const i2 = I(this, t2, e2);
    return this.attr(this.array().size(i2.width, i2.height).toLine());
  }
};
Q(xe, fe), A({ Container: { line: K(function(...t2) {
  return xe.prototype.plot.apply(this.put(new xe()), null != t2[0] ? t2 : [0, 0, 0, 0]);
}) } }), q(xe, &quot;Line&quot;);
var be = class extends Vt {
  constructor(t2, e2 = t2) {
    super(G(&quot;marker&quot;, t2), e2);
  }
  height(t2) {
    return this.attr(&quot;markerHeight&quot;, t2);
  }
  orient(t2) {
    return this.attr(&quot;orient&quot;, t2);
  }
  ref(t2, e2) {
    return this.attr(&quot;refX&quot;, t2).attr(&quot;refY&quot;, e2);
  }
  toString() {
    return &quot;url(#&quot; + this.id() + &quot;)&quot;;
  }
  update(t2) {
    return this.clear(), &quot;function&quot; == typeof t2 &amp;&amp; t2.call(this, this), this;
  }
  width(t2) {
    return this.attr(&quot;markerWidth&quot;, t2);
  }
};
function me(t2, e2) {
  return function(i2) {
    return null == i2 ? this[t2] : (this[t2] = i2, e2 &amp;&amp; e2.call(this), this);
  };
}
A({ Container: { marker(...t2) {
  return this.defs().marker(...t2);
} }, Defs: { marker: K(function(t2, e2, i2) {
  return this.put(new be()).size(t2, e2).ref(t2 / 2, e2 / 2).viewbox(0, 0, t2, e2).attr(&quot;orient&quot;, &quot;auto&quot;).update(i2);
}) }, marker: { marker(t2, e2, i2, a2) {
  let s2 = [&quot;marker&quot;];
  return &quot;all&quot; !== t2 &amp;&amp; s2.push(t2), s2 = s2.join(&quot;-&quot;), t2 = arguments[1] instanceof be ? arguments[1] : this.defs().marker(e2, i2, a2), this.attr(s2, t2);
} } }), q(be, &quot;Marker&quot;);
var ve = { &quot;-&quot;: function(t2) {
  return t2;
}, &quot;&lt;&gt;&quot;: function(t2) {
  return -Math.cos(t2 * Math.PI) / 2 + 0.5;
}, &quot;&gt;&quot;: function(t2) {
  return Math.sin(t2 * Math.PI / 2);
}, &quot;&lt;&quot;: function(t2) {
  return 1 - Math.cos(t2 * Math.PI / 2);
}, bezier: function(t2, e2, i2, a2) {
  return function(s2) {
    return s2 &lt; 0 ? t2 &gt; 0 ? e2 / t2 * s2 : i2 &gt; 0 ? a2 / i2 * s2 : 0 : s2 &gt; 1 ? i2 &lt; 1 ? (1 - a2) / (1 - i2) * s2 + (a2 - i2) / (1 - i2) : t2 &lt; 1 ? (1 - e2) / (1 - t2) * s2 + (e2 - t2) / (1 - t2) : 1 : 3 * s2 * (1 - s2) ** 2 * e2 + 3 * s2 ** 2 * (1 - s2) * a2 + s2 ** 3;
  };
}, steps: function(t2, e2 = &quot;end&quot;) {
  e2 = e2.split(&quot;-&quot;).reverse()[0];
  let i2 = t2;
  return &quot;none&quot; === e2 ? --i2 : &quot;both&quot; === e2 &amp;&amp; ++i2, (a2, s2 = false) =&gt; {
    let r2 = Math.floor(a2 * t2);
    const n2 = a2 * r2 % 1 == 0;
    return &quot;start&quot; !== e2 &amp;&amp; &quot;both&quot; !== e2 || ++r2, s2 &amp;&amp; n2 &amp;&amp; --r2, a2 &gt;= 0 &amp;&amp; r2 &lt; 0 &amp;&amp; (r2 = 0), a2 &lt;= 1 &amp;&amp; r2 &gt; i2 &amp;&amp; (r2 = i2), r2 / i2;
  };
} };
var ye = class {
  done() {
    return false;
  }
};
var we = class extends ye {
  constructor(t2 = Ht) {
    super(), this.ease = ve[t2] || t2;
  }
  step(t2, e2, i2) {
    return &quot;number&quot; != typeof t2 ? i2 &lt; 1 ? t2 : e2 : t2 + (e2 - t2) * this.ease(i2);
  }
};
var ke = class extends ye {
  constructor(t2) {
    super(), this.stepper = t2;
  }
  done(t2) {
    return t2.done;
  }
  step(t2, e2, i2, a2) {
    return this.stepper(t2, e2, i2, a2);
  }
};
function Ae() {
  const t2 = (this._duration || 500) / 1e3, e2 = this._overshoot || 0, i2 = Math.PI, a2 = Math.log(e2 / 100 + 1e-10), s2 = -a2 / Math.sqrt(i2 * i2 + a2 * a2), r2 = 3.9 / (s2 * t2);
  this.d = 2 * s2 * r2, this.k = r2 * r2;
}
Q(class extends ke {
  constructor(t2 = 500, e2 = 0) {
    super(), this.duration(t2).overshoot(e2);
  }
  step(t2, e2, i2, a2) {
    if (&quot;string&quot; == typeof t2) return t2;
    if (a2.done = i2 === 1 / 0, i2 === 1 / 0) return e2;
    if (0 === i2) return t2;
    i2 &gt; 100 &amp;&amp; (i2 = 16), i2 /= 1e3;
    const s2 = a2.velocity || 0, r2 = -this.d * s2 - this.k * (t2 - e2), n2 = t2 + s2 * i2 + r2 * i2 * i2 / 2;
    return a2.velocity = s2 + r2 * i2, a2.done = Math.abs(e2 - n2) + Math.abs(s2) &lt; 2e-3, a2.done ? e2 : n2;
  }
}, { duration: me(&quot;_duration&quot;, Ae), overshoot: me(&quot;_overshoot&quot;, Ae) });
Q(class extends ke {
  constructor(t2 = 0.1, e2 = 0.01, i2 = 0, a2 = 1e3) {
    super(), this.p(t2).i(e2).d(i2).windup(a2);
  }
  step(t2, e2, i2, a2) {
    if (&quot;string&quot; == typeof t2) return t2;
    if (a2.done = i2 === 1 / 0, i2 === 1 / 0) return e2;
    if (0 === i2) return t2;
    const s2 = e2 - t2;
    let r2 = (a2.integral || 0) + s2 * i2;
    const n2 = (s2 - (a2.error || 0)) / i2, o2 = this._windup;
    return false !== o2 &amp;&amp; (r2 = Math.max(-o2, Math.min(r2, o2))), a2.error = s2, a2.integral = r2, a2.done = Math.abs(s2) &lt; 1e-3, a2.done ? e2 : t2 + (this.P * s2 + this.I * r2 + this.D * n2);
  }
}, { windup: me(&quot;_windup&quot;), p: me(&quot;P&quot;), i: me(&quot;I&quot;), d: me(&quot;D&quot;) });
var Ce = { M: 2, L: 2, H: 1, V: 1, C: 6, S: 4, Q: 4, T: 2, A: 7, Z: 0 };
var Se = { M: function(t2, e2, i2) {
  return e2.x = i2.x = t2[0], e2.y = i2.y = t2[1], [&quot;M&quot;, e2.x, e2.y];
}, L: function(t2, e2) {
  return e2.x = t2[0], e2.y = t2[1], [&quot;L&quot;, t2[0], t2[1]];
}, H: function(t2, e2) {
  return e2.x = t2[0], [&quot;H&quot;, t2[0]];
}, V: function(t2, e2) {
  return e2.y = t2[0], [&quot;V&quot;, t2[0]];
}, C: function(t2, e2) {
  return e2.x = t2[4], e2.y = t2[5], [&quot;C&quot;, t2[0], t2[1], t2[2], t2[3], t2[4], t2[5]];
}, S: function(t2, e2) {
  return e2.x = t2[2], e2.y = t2[3], [&quot;S&quot;, t2[0], t2[1], t2[2], t2[3]];
}, Q: function(t2, e2) {
  return e2.x = t2[2], e2.y = t2[3], [&quot;Q&quot;, t2[0], t2[1], t2[2], t2[3]];
}, T: function(t2, e2) {
  return e2.x = t2[0], e2.y = t2[1], [&quot;T&quot;, t2[0], t2[1]];
}, Z: function(t2, e2, i2) {
  return e2.x = i2.x, e2.y = i2.y, [&quot;Z&quot;];
}, A: function(t2, e2) {
  return e2.x = t2[5], e2.y = t2[6], [&quot;A&quot;, t2[0], t2[1], t2[2], t2[3], t2[4], t2[5], t2[6]];
} };
var Le = &quot;mlhvqtcsaz&quot;.split(&quot;&quot;);
for (let t2 = 0, e2 = Le.length; t2 &lt; e2; ++t2) Se[Le[t2]] = /* @__PURE__ */ function(t3) {
  return function(e3, i2, a2) {
    if (&quot;H&quot; === t3) e3[0] = e3[0] + i2.x;
    else if (&quot;V&quot; === t3) e3[0] = e3[0] + i2.y;
    else if (&quot;A&quot; === t3) e3[5] = e3[5] + i2.x, e3[6] = e3[6] + i2.y;
    else for (let t4 = 0, a3 = e3.length; t4 &lt; a3; ++t4) e3[t4] = e3[t4] + (t4 % 2 ? i2.y : i2.x);
    return Se[t3](e3, i2, a2);
  };
}(Le[t2].toUpperCase());
function Me(t2) {
  return t2.segment.length &amp;&amp; t2.segment.length - 1 === Ce[t2.segment[0].toUpperCase()];
}
function Pe(t2, e2) {
  t2.inNumber &amp;&amp; Ie(t2, false);
  const i2 = ut.test(e2);
  if (i2) t2.segment = [e2];
  else {
    const e3 = t2.lastCommand, i3 = e3.toLowerCase(), a2 = e3 === i3;
    t2.segment = [&quot;m&quot; === i3 ? a2 ? &quot;l&quot; : &quot;L&quot; : e3];
  }
  return t2.inSegment = true, t2.lastCommand = t2.segment[0], i2;
}
function Ie(t2, e2) {
  if (!t2.inNumber) throw new Error(&quot;Parser Error&quot;);
  t2.number &amp;&amp; t2.segment.push(parseFloat(t2.number)), t2.inNumber = e2, t2.number = &quot;&quot;, t2.pointSeen = false, t2.hasExponent = false, Me(t2) &amp;&amp; Te(t2);
}
function Te(t2) {
  t2.inSegment = false, t2.absolute &amp;&amp; (t2.segment = function(t3) {
    const e2 = t3.segment[0];
    return Se[e2](t3.segment.slice(1), t3.p, t3.p0);
  }(t2)), t2.segments.push(t2.segment);
}
function ze(t2) {
  if (!t2.segment.length) return false;
  const e2 = &quot;A&quot; === t2.segment[0].toUpperCase(), i2 = t2.segment.length;
  return e2 &amp;&amp; (4 === i2 || 5 === i2);
}
function Xe(t2) {
  return &quot;E&quot; === t2.lastToken.toUpperCase();
}
var Re = /* @__PURE__ */ new Set([&quot; &quot;, &quot;,&quot;, &quot;	&quot;, &quot;\n&quot;, &quot;\r&quot;, &quot;\f&quot;]);
var Ee = class extends Dt {
  bbox() {
    return yt().path.setAttribute(&quot;d&quot;, this.toString()), new kt(yt.nodes.path.getBBox());
  }
  move(t2, e2) {
    const i2 = this.bbox();
    if (t2 -= i2.x, e2 -= i2.y, !isNaN(t2) &amp;&amp; !isNaN(e2)) for (let i3, a2 = this.length - 1; a2 &gt;= 0; a2--) i3 = this[a2][0], &quot;M&quot; === i3 || &quot;L&quot; === i3 || &quot;T&quot; === i3 ? (this[a2][1] += t2, this[a2][2] += e2) : &quot;H&quot; === i3 ? this[a2][1] += t2 : &quot;V&quot; === i3 ? this[a2][1] += e2 : &quot;C&quot; === i3 || &quot;S&quot; === i3 || &quot;Q&quot; === i3 ? (this[a2][1] += t2, this[a2][2] += e2, this[a2][3] += t2, this[a2][4] += e2, &quot;C&quot; === i3 &amp;&amp; (this[a2][5] += t2, this[a2][6] += e2)) : &quot;A&quot; === i3 &amp;&amp; (this[a2][6] += t2, this[a2][7] += e2);
    return this;
  }
  parse(t2 = &quot;M0 0&quot;) {
    return Array.isArray(t2) &amp;&amp; (t2 = Array.prototype.concat.apply([], t2).toString()), function(t3, e2 = true) {
      let i2 = 0, a2 = &quot;&quot;;
      const s2 = { segment: [], inNumber: false, number: &quot;&quot;, lastToken: &quot;&quot;, inSegment: false, segments: [], pointSeen: false, hasExponent: false, absolute: e2, p0: new bt(), p: new bt() };
      for (; s2.lastToken = a2, a2 = t3.charAt(i2++); ) if (s2.inSegment || !Pe(s2, a2)) if (&quot;.&quot; !== a2) if (isNaN(parseInt(a2))) if (Re.has(a2)) s2.inNumber &amp;&amp; Ie(s2, false);
      else if (&quot;-&quot; !== a2 &amp;&amp; &quot;+&quot; !== a2) if (&quot;E&quot; !== a2.toUpperCase()) {
        if (ut.test(a2)) {
          if (s2.inNumber) Ie(s2, false);
          else {
            if (!Me(s2)) throw new Error(&quot;parser Error&quot;);
            Te(s2);
          }
          --i2;
        }
      } else s2.number += a2, s2.hasExponent = true;
      else {
        if (s2.inNumber &amp;&amp; !Xe(s2)) {
          Ie(s2, false), --i2;
          continue;
        }
        s2.number += a2, s2.inNumber = true;
      }
      else {
        if (&quot;0&quot; === s2.number || ze(s2)) {
          s2.inNumber = true, s2.number = a2, Ie(s2, true);
          continue;
        }
        s2.inNumber = true, s2.number += a2;
      }
      else {
        if (s2.pointSeen || s2.hasExponent) {
          Ie(s2, false), --i2;
          continue;
        }
        s2.inNumber = true, s2.pointSeen = true, s2.number += a2;
      }
      return s2.inNumber &amp;&amp; Ie(s2, false), s2.inSegment &amp;&amp; Me(s2) &amp;&amp; Te(s2), s2.segments;
    }(t2);
  }
  size(t2, e2) {
    const i2 = this.bbox();
    let a2, s2;
    for (i2.width = 0 === i2.width ? 1 : i2.width, i2.height = 0 === i2.height ? 1 : i2.height, a2 = this.length - 1; a2 &gt;= 0; a2--) s2 = this[a2][0], &quot;M&quot; === s2 || &quot;L&quot; === s2 || &quot;T&quot; === s2 ? (this[a2][1] = (this[a2][1] - i2.x) * t2 / i2.width + i2.x, this[a2][2] = (this[a2][2] - i2.y) * e2 / i2.height + i2.y) : &quot;H&quot; === s2 ? this[a2][1] = (this[a2][1] - i2.x) * t2 / i2.width + i2.x : &quot;V&quot; === s2 ? this[a2][1] = (this[a2][1] - i2.y) * e2 / i2.height + i2.y : &quot;C&quot; === s2 || &quot;S&quot; === s2 || &quot;Q&quot; === s2 ? (this[a2][1] = (this[a2][1] - i2.x) * t2 / i2.width + i2.x, this[a2][2] = (this[a2][2] - i2.y) * e2 / i2.height + i2.y, this[a2][3] = (this[a2][3] - i2.x) * t2 / i2.width + i2.x, this[a2][4] = (this[a2][4] - i2.y) * e2 / i2.height + i2.y, &quot;C&quot; === s2 &amp;&amp; (this[a2][5] = (this[a2][5] - i2.x) * t2 / i2.width + i2.x, this[a2][6] = (this[a2][6] - i2.y) * e2 / i2.height + i2.y)) : &quot;A&quot; === s2 &amp;&amp; (this[a2][1] = this[a2][1] * t2 / i2.width, this[a2][2] = this[a2][2] * e2 / i2.height, this[a2][6] = (this[a2][6] - i2.x) * t2 / i2.width + i2.x, this[a2][7] = (this[a2][7] - i2.y) * e2 / i2.height + i2.y);
    return this;
  }
  toString() {
    return function(t2) {
      let e2 = &quot;&quot;;
      for (let i2 = 0, a2 = t2.length; i2 &lt; a2; i2++) e2 += t2[i2][0], null != t2[i2][1] &amp;&amp; (e2 += t2[i2][1], null != t2[i2][2] &amp;&amp; (e2 += &quot; &quot;, e2 += t2[i2][2], null != t2[i2][3] &amp;&amp; (e2 += &quot; &quot;, e2 += t2[i2][3], e2 += &quot; &quot;, e2 += t2[i2][4], null != t2[i2][5] &amp;&amp; (e2 += &quot; &quot;, e2 += t2[i2][5], e2 += &quot; &quot;, e2 += t2[i2][6], null != t2[i2][7] &amp;&amp; (e2 += &quot; &quot;, e2 += t2[i2][7])))));
      return e2 + &quot; &quot;;
    }(this);
  }
};
var Ye = (t2) =&gt; {
  const e2 = typeof t2;
  return &quot;number&quot; === e2 ? _t : &quot;string&quot; === e2 ? xt.isColor(t2) ? xt : dt.test(t2) ? ut.test(t2) ? Ee : Dt : tt.test(t2) ? _t : Oe : Ne.indexOf(t2.constructor) &gt; -1 ? t2.constructor : Array.isArray(t2) ? Dt : &quot;object&quot; === e2 ? _e : Oe;
};
var He = class {
  constructor(t2) {
    this._stepper = t2 || new we(&quot;-&quot;), this._from = null, this._to = null, this._type = null, this._context = null, this._morphObj = null;
  }
  at(t2) {
    return this._morphObj.morph(this._from, this._to, t2, this._stepper, this._context);
  }
  done() {
    return this._context.map(this._stepper.done).reduce(function(t2, e2) {
      return t2 &amp;&amp; e2;
    }, true);
  }
  from(t2) {
    return null == t2 ? this._from : (this._from = this._set(t2), this);
  }
  stepper(t2) {
    return null == t2 ? this._stepper : (this._stepper = t2, this);
  }
  to(t2) {
    return null == t2 ? this._to : (this._to = this._set(t2), this);
  }
  type(t2) {
    return null == t2 ? this._type : (this._type = t2, this);
  }
  _set(t2) {
    this._type || this.type(Ye(t2));
    let e2 = new this._type(t2);
    return this._type === xt &amp;&amp; (e2 = this._to ? e2[this._to[4]]() : this._from ? e2[this._from[4]]() : e2), this._type === _e &amp;&amp; (e2 = this._to ? e2.align(this._to) : this._from ? e2.align(this._from) : e2), e2 = e2.toConsumable(), this._morphObj = this._morphObj || new this._type(), this._context = this._context || Array.apply(null, Array(e2.length)).map(Object).map(function(t3) {
      return t3.done = true, t3;
    }), e2;
  }
};
var Oe = class {
  constructor(...t2) {
    this.init(...t2);
  }
  init(t2) {
    return t2 = Array.isArray(t2) ? t2[0] : t2, this.value = t2, this;
  }
  toArray() {
    return [this.value];
  }
  valueOf() {
    return this.value;
  }
};
var Fe = class _Fe {
  constructor(...t2) {
    this.init(...t2);
  }
  init(t2) {
    return Array.isArray(t2) &amp;&amp; (t2 = { scaleX: t2[0], scaleY: t2[1], shear: t2[2], rotate: t2[3], translateX: t2[4], translateY: t2[5], originX: t2[6], originY: t2[7] }), Object.assign(this, _Fe.defaults, t2), this;
  }
  toArray() {
    const t2 = this;
    return [t2.scaleX, t2.scaleY, t2.shear, t2.rotate, t2.translateX, t2.translateY, t2.originX, t2.originY];
  }
};
Fe.defaults = { scaleX: 1, scaleY: 1, shear: 0, rotate: 0, translateX: 0, translateY: 0, originX: 0, originY: 0 };
var De = (t2, e2) =&gt; t2[0] &lt; e2[0] ? -1 : t2[0] &gt; e2[0] ? 1 : 0;
var _e = class {
  constructor(...t2) {
    this.init(...t2);
  }
  align(t2) {
    const e2 = this.values;
    for (let i2 = 0, a2 = e2.length; i2 &lt; a2; ++i2) {
      if (e2[i2 + 1] === t2[i2 + 1]) {
        if (e2[i2 + 1] === xt &amp;&amp; t2[i2 + 7] !== e2[i2 + 7]) {
          const e3 = t2[i2 + 7], a4 = new xt(this.values.splice(i2 + 3, 5))[e3]().toArray();
          this.values.splice(i2 + 3, 0, ...a4);
        }
        i2 += e2[i2 + 2] + 2;
        continue;
      }
      if (!t2[i2 + 1]) return this;
      const a3 = new t2[i2 + 1]().toArray(), s2 = e2[i2 + 2] + 3;
      e2.splice(i2, s2, t2[i2], t2[i2 + 1], t2[i2 + 2], ...a3), i2 += e2[i2 + 2] + 2;
    }
    return this;
  }
  init(t2) {
    if (this.values = [], Array.isArray(t2)) return void (this.values = t2.slice());
    t2 = t2 || {};
    const e2 = [];
    for (const i2 in t2) {
      const a2 = Ye(t2[i2]), s2 = new a2(t2[i2]).toArray();
      e2.push([i2, a2, s2.length, ...s2]);
    }
    return e2.sort(De), this.values = e2.reduce((t3, e3) =&gt; t3.concat(e3), []), this;
  }
  toArray() {
    return this.values;
  }
  valueOf() {
    const t2 = {}, e2 = this.values;
    for (; e2.length; ) {
      const i2 = e2.shift(), a2 = e2.shift(), s2 = e2.shift(), r2 = e2.splice(0, s2);
      t2[i2] = new a2(r2);
    }
    return t2;
  }
};
var Ne = [Oe, Fe, _e];
var We = class extends qt {
  constructor(t2, e2 = t2) {
    super(G(&quot;path&quot;, t2), e2);
  }
  array() {
    return this._array || (this._array = new Ee(this.attr(&quot;d&quot;)));
  }
  clear() {
    return delete this._array, this;
  }
  height(t2) {
    return null == t2 ? this.bbox().height : this.size(this.bbox().width, t2);
  }
  move(t2, e2) {
    return this.attr(&quot;d&quot;, this.array().move(t2, e2));
  }
  plot(t2) {
    return null == t2 ? this.array() : this.clear().attr(&quot;d&quot;, &quot;string&quot; == typeof t2 ? t2 : this._array = new Ee(t2));
  }
  size(t2, e2) {
    const i2 = I(this, t2, e2);
    return this.attr(&quot;d&quot;, this.array().size(i2.width, i2.height));
  }
  width(t2) {
    return null == t2 ? this.bbox().width : this.size(t2, this.bbox().height);
  }
  x(t2) {
    return null == t2 ? this.bbox().x : this.move(t2, this.bbox().y);
  }
  y(t2) {
    return null == t2 ? this.bbox().y : this.move(this.bbox().x, t2);
  }
};
We.prototype.MorphArray = Ee, A({ Container: { path: K(function(t2) {
  return this.put(new We()).plot(t2 || new Ee());
}) } }), q(We, &quot;Path&quot;);
var Be = Object.freeze({ __proto__: null, array: function() {
  return this._array || (this._array = new ge(this.attr(&quot;points&quot;)));
}, clear: function() {
  return delete this._array, this;
}, move: function(t2, e2) {
  return this.attr(&quot;points&quot;, this.array().move(t2, e2));
}, plot: function(t2) {
  return null == t2 ? this.array() : this.clear().attr(&quot;points&quot;, &quot;string&quot; == typeof t2 ? t2 : this._array = new ge(t2));
}, size: function(t2, e2) {
  const i2 = I(this, t2, e2);
  return this.attr(&quot;points&quot;, this.array().size(i2.width, i2.height));
} });
var Ge = class extends qt {
  constructor(t2, e2 = t2) {
    super(G(&quot;polygon&quot;, t2), e2);
  }
};
A({ Container: { polygon: K(function(t2) {
  return this.put(new Ge()).plot(t2 || new ge());
}) } }), Q(Ge, fe), Q(Ge, Be), q(Ge, &quot;Polygon&quot;);
var je = class extends qt {
  constructor(t2, e2 = t2) {
    super(G(&quot;polyline&quot;, t2), e2);
  }
};
A({ Container: { polyline: K(function(t2) {
  return this.put(new je()).plot(t2 || new ge());
}) } }), Q(je, fe), Q(je, Be), q(je, &quot;Polyline&quot;);
var Ve = class extends qt {
  constructor(t2, e2 = t2) {
    super(G(&quot;rect&quot;, t2), e2);
  }
};
Q(Ve, { rx: Zt, ry: $t }), A({ Container: { rect: K(function(t2, e2) {
  return this.put(new Ve()).size(t2, e2);
}) } }), q(Ve, &quot;Rect&quot;);
var Ue = class {
  constructor() {
    this._first = null, this._last = null;
  }
  first() {
    return this._first &amp;&amp; this._first.value;
  }
  last() {
    return this._last &amp;&amp; this._last.value;
  }
  push(t2) {
    const e2 = void 0 !== t2.next ? t2 : { value: t2, next: null, prev: null };
    return this._last ? (e2.prev = this._last, this._last.next = e2, this._last = e2) : (this._last = e2, this._first = e2), e2;
  }
  remove(t2) {
    t2.prev &amp;&amp; (t2.prev.next = t2.next), t2.next &amp;&amp; (t2.next.prev = t2.prev), t2 === this._last &amp;&amp; (this._last = t2.prev), t2 === this._first &amp;&amp; (this._first = t2.next), t2.prev = null, t2.next = null;
  }
  shift() {
    const t2 = this._first;
    return t2 ? (this._first = t2.next, this._first &amp;&amp; (this._first.prev = null), this._last = this._first ? this._last : null, t2.value) : null;
  }
};
var qe = { nextDraw: null, frames: new Ue(), timeouts: new Ue(), immediates: new Ue(), timer: () =&gt; O.window.performance || O.window.Date, transforms: [], frame(t2) {
  const e2 = qe.frames.push({ run: t2 });
  return null === qe.nextDraw &amp;&amp; (qe.nextDraw = O.window.requestAnimationFrame(qe._draw)), e2;
}, timeout(t2, e2) {
  e2 = e2 || 0;
  const i2 = qe.timer().now() + e2, a2 = qe.timeouts.push({ run: t2, time: i2 });
  return null === qe.nextDraw &amp;&amp; (qe.nextDraw = O.window.requestAnimationFrame(qe._draw)), a2;
}, immediate(t2) {
  const e2 = qe.immediates.push(t2);
  return null === qe.nextDraw &amp;&amp; (qe.nextDraw = O.window.requestAnimationFrame(qe._draw)), e2;
}, cancelFrame(t2) {
  null != t2 &amp;&amp; qe.frames.remove(t2);
}, clearTimeout(t2) {
  null != t2 &amp;&amp; qe.timeouts.remove(t2);
}, cancelImmediate(t2) {
  null != t2 &amp;&amp; qe.immediates.remove(t2);
}, _draw(t2) {
  let e2 = null;
  const i2 = qe.timeouts.last();
  for (; (e2 = qe.timeouts.shift()) &amp;&amp; (t2 &gt;= e2.time ? e2.run() : qe.timeouts.push(e2), e2 !== i2); ) ;
  let a2 = null;
  const s2 = qe.frames.last();
  for (; a2 !== s2 &amp;&amp; (a2 = qe.frames.shift()); ) a2.run(t2);
  let r2 = null;
  for (; r2 = qe.immediates.shift(); ) r2();
  qe.nextDraw = qe.timeouts.first() || qe.frames.first() ? O.window.requestAnimationFrame(qe._draw) : null;
} };
var Ze = function(t2) {
  const e2 = t2.start, i2 = t2.runner.duration();
  return { start: e2, duration: i2, end: e2 + i2, runner: t2.runner };
};
var $e = function() {
  const t2 = O.window;
  return (t2.performance || t2.Date).now();
};
var Je = class extends Rt {
  constructor(t2 = $e) {
    super(), this._timeSource = t2, this.terminate();
  }
  active() {
    return !!this._nextFrame;
  }
  finish() {
    return this.time(this.getEndTimeOfTimeline() + 1), this.pause();
  }
  getEndTime() {
    const t2 = this.getLastRunnerInfo(), e2 = t2 ? t2.runner.duration() : 0;
    return (t2 ? t2.start : this._time) + e2;
  }
  getEndTimeOfTimeline() {
    const t2 = this._runners.map((t3) =&gt; t3.start + t3.runner.duration());
    return Math.max(0, ...t2);
  }
  getLastRunnerInfo() {
    return this.getRunnerInfoById(this._lastRunnerId);
  }
  getRunnerInfoById(t2) {
    return this._runners[this._runnerIds.indexOf(t2)] || null;
  }
  pause() {
    return this._paused = true, this._continue();
  }
  persist(t2) {
    return null == t2 ? this._persist : (this._persist = t2, this);
  }
  play() {
    return this._paused = false, this.updateTime()._continue();
  }
  reverse(t2) {
    const e2 = this.speed();
    if (null == t2) return this.speed(-e2);
    const i2 = Math.abs(e2);
    return this.speed(t2 ? -i2 : i2);
  }
  schedule(t2, e2, i2) {
    if (null == t2) return this._runners.map(Ze);
    let a2 = 0;
    const s2 = this.getEndTime();
    if (e2 = e2 || 0, null == i2 || &quot;last&quot; === i2 || &quot;after&quot; === i2) a2 = s2;
    else if (&quot;absolute&quot; === i2 || &quot;start&quot; === i2) a2 = e2, e2 = 0;
    else if (&quot;now&quot; === i2) a2 = this._time;
    else if (&quot;relative&quot; === i2) {
      const i3 = this.getRunnerInfoById(t2.id);
      i3 &amp;&amp; (a2 = i3.start + e2, e2 = 0);
    } else {
      if (&quot;with-last&quot; !== i2) throw new Error(&#x27;Invalid value for the &quot;when&quot; parameter&#x27;);
      {
        const t3 = this.getLastRunnerInfo();
        a2 = t3 ? t3.start : this._time;
      }
    }
    t2.unschedule(), t2.timeline(this);
    const r2 = t2.persist(), n2 = { persist: null === r2 ? this._persist : r2, start: a2 + e2, runner: t2 };
    return this._lastRunnerId = t2.id, this._runners.push(n2), this._runners.sort((t3, e3) =&gt; t3.start - e3.start), this._runnerIds = this._runners.map((t3) =&gt; t3.runner.id), this.updateTime()._continue(), this;
  }
  seek(t2) {
    return this.time(this._time + t2);
  }
  source(t2) {
    return null == t2 ? this._timeSource : (this._timeSource = t2, this);
  }
  speed(t2) {
    return null == t2 ? this._speed : (this._speed = t2, this);
  }
  stop() {
    return this.time(0), this.pause();
  }
  time(t2) {
    return null == t2 ? this._time : (this._time = t2, this._continue(true));
  }
  unschedule(t2) {
    const e2 = this._runnerIds.indexOf(t2.id);
    return e2 &lt; 0 || (this._runners.splice(e2, 1), this._runnerIds.splice(e2, 1), t2.timeline(null)), this;
  }
  updateTime() {
    return this.active() || (this._lastSourceTime = this._timeSource()), this;
  }
  _continue(t2 = false) {
    return qe.cancelFrame(this._nextFrame), this._nextFrame = null, t2 ? this._stepImmediate() : (this._paused || (this._nextFrame = qe.frame(this._step)), this);
  }
  _stepFn(t2 = false) {
    const e2 = this._timeSource();
    let i2 = e2 - this._lastSourceTime;
    t2 &amp;&amp; (i2 = 0);
    const a2 = this._speed * i2 + (this._time - this._lastStepTime);
    this._lastSourceTime = e2, t2 || (this._time += a2, this._time = this._time &lt; 0 ? 0 : this._time), this._lastStepTime = this._time, this.fire(&quot;time&quot;, this._time);
    for (let t3 = this._runners.length; t3--; ) {
      const e3 = this._runners[t3], i3 = e3.runner;
      this._time - e3.start &lt;= 0 &amp;&amp; i3.reset();
    }
    let s2 = false;
    for (let t3 = 0, e3 = this._runners.length; t3 &lt; e3; t3++) {
      const i3 = this._runners[t3], r2 = i3.runner;
      let n2 = a2;
      const o2 = this._time - i3.start;
      if (o2 &lt;= 0) {
        s2 = true;
        continue;
      }
      if (o2 &lt; n2 &amp;&amp; (n2 = o2), !r2.active()) continue;
      if (r2.step(n2).done) {
        if (true !== i3.persist) {
          r2.duration() - r2.time() + this._time + i3.persist &lt; this._time &amp;&amp; (r2.unschedule(), --t3, --e3);
        }
      } else s2 = true;
    }
    return s2 &amp;&amp; !(this._speed &lt; 0 &amp;&amp; 0 === this._time) || this._runnerIds.length &amp;&amp; this._speed &lt; 0 &amp;&amp; this._time &gt; 0 ? this._continue() : (this.pause(), this.fire(&quot;finished&quot;)), this;
  }
  terminate() {
    this._startTime = 0, this._speed = 1, this._persist = 0, this._nextFrame = null, this._paused = true, this._runners = [], this._runnerIds = [], this._lastRunnerId = -1, this._time = 0, this._lastSourceTime = 0, this._lastStepTime = 0, this._step = this._stepFn.bind(this, false), this._stepImmediate = this._stepFn.bind(this, true);
  }
};
A({ Element: { timeline: function(t2) {
  return null == t2 ? (this._timeline = this._timeline || new Je(), this._timeline) : (this._timeline = t2, this);
} } });
var Qe = class _Qe extends Rt {
  constructor(t2) {
    super(), this.id = _Qe.id++, t2 = &quot;function&quot; == typeof (t2 = null == t2 ? Yt : t2) ? new ke(t2) : t2, this._element = null, this._timeline = null, this.done = false, this._queue = [], this._duration = &quot;number&quot; == typeof t2 &amp;&amp; t2, this._isDeclarative = t2 instanceof ke, this._stepper = this._isDeclarative ? t2 : new we(), this._history = {}, this.enabled = true, this._time = 0, this._lastTime = 0, this._reseted = true, this.transforms = new vt(), this.transformId = 1, this._haveReversed = false, this._reverse = false, this._loopsDone = 0, this._swing = false, this._wait = 0, this._times = 1, this._frameId = null, this._persist = !!this._isDeclarative || null;
  }
  static sanitise(t2, e2, i2) {
    let a2 = 1, s2 = false, r2 = 0;
    return e2 = e2 ?? Ot, i2 = i2 || &quot;last&quot;, &quot;object&quot; != typeof (t2 = t2 ?? Yt) || t2 instanceof ye || (e2 = t2.delay ?? e2, i2 = t2.when ?? i2, s2 = t2.swing || s2, a2 = t2.times ?? a2, r2 = t2.wait ?? r2, t2 = t2.duration ?? Yt), { duration: t2, delay: e2, swing: s2, times: a2, wait: r2, when: i2 };
  }
  active(t2) {
    return null == t2 ? this.enabled : (this.enabled = t2, this);
  }
  addTransform(t2) {
    return this.transforms.lmultiplyO(t2), this;
  }
  after(t2) {
    return this.on(&quot;finished&quot;, t2);
  }
  animate(t2, e2, i2) {
    const a2 = _Qe.sanitise(t2, e2, i2), s2 = new _Qe(a2.duration);
    return this._timeline &amp;&amp; s2.timeline(this._timeline), this._element &amp;&amp; s2.element(this._element), s2.loop(a2).schedule(a2.delay, a2.when);
  }
  clearTransform() {
    return this.transforms = new vt(), this;
  }
  clearTransformsFromQueue() {
    this.done &amp;&amp; this._timeline &amp;&amp; this._timeline._runnerIds.includes(this.id) || (this._queue = this._queue.filter((t2) =&gt; !t2.isTransform));
  }
  delay(t2) {
    return this.animate(0, t2);
  }
  duration() {
    return this._times * (this._wait + this._duration) - this._wait;
  }
  during(t2) {
    return this.queue(null, t2);
  }
  ease(t2) {
    return this._stepper = new we(t2), this;
  }
  element(t2) {
    return null == t2 ? this._element : (this._element = t2, t2._prepareRunner(), this);
  }
  finish() {
    return this.step(1 / 0);
  }
  loop(t2, e2, i2) {
    return &quot;object&quot; == typeof t2 &amp;&amp; (e2 = t2.swing, i2 = t2.wait, t2 = t2.times), this._times = t2 || 1 / 0, this._swing = e2 || false, this._wait = i2 || 0, true === this._times &amp;&amp; (this._times = 1 / 0), this;
  }
  loops(t2) {
    const e2 = this._duration + this._wait;
    if (null == t2) {
      const t3 = Math.floor(this._time / e2), i3 = (this._time - t3 * e2) / this._duration;
      return Math.min(t3 + i3, this._times);
    }
    const i2 = t2 % 1, a2 = e2 * Math.floor(t2) + this._duration * i2;
    return this.time(a2);
  }
  persist(t2) {
    return null == t2 ? this._persist : (this._persist = t2, this);
  }
  position(t2) {
    const e2 = this._time, i2 = this._duration, a2 = this._wait, s2 = this._times, r2 = this._swing, n2 = this._reverse;
    let o2;
    if (null == t2) {
      const t3 = function(t4) {
        const e3 = r2 * Math.floor(t4 % (2 * (a2 + i2)) / (a2 + i2)), s3 = e3 &amp;&amp; !n2 || !e3 &amp;&amp; n2, o3 = Math.pow(-1, s3) * (t4 % (a2 + i2)) / i2 + s3;
        return Math.max(Math.min(o3, 1), 0);
      }, l3 = s2 * (a2 + i2) - a2;
      return o2 = e2 &lt;= 0 ? Math.round(t3(1e-5)) : e2 &lt; l3 ? t3(e2) : Math.round(t3(l3 - 1e-5)), o2;
    }
    const l2 = Math.floor(this.loops()), h2 = r2 &amp;&amp; l2 % 2 == 0;
    return o2 = l2 + (h2 &amp;&amp; !n2 || n2 &amp;&amp; h2 ? t2 : 1 - t2), this.loops(o2);
  }
  progress(t2) {
    return null == t2 ? Math.min(1, this._time / this.duration()) : this.time(t2 * this.duration());
  }
  queue(t2, e2, i2, a2) {
    this._queue.push({ initialiser: t2 || Et, runner: e2 || Et, retarget: i2, isTransform: a2, initialised: false, finished: false });
    return this.timeline() &amp;&amp; this.timeline()._continue(), this;
  }
  reset() {
    return this._reseted || (this.time(0), this._reseted = true), this;
  }
  reverse(t2) {
    return this._reverse = null == t2 ? !this._reverse : t2, this;
  }
  schedule(t2, e2, i2) {
    if (t2 instanceof Je || (i2 = e2, e2 = t2, t2 = this.timeline()), !t2) throw Error(&quot;Runner cannot be scheduled without timeline&quot;);
    return t2.schedule(this, e2, i2), this;
  }
  step(t2) {
    if (!this.enabled) return this;
    t2 = null == t2 ? 16 : t2, this._time += t2;
    const e2 = this.position(), i2 = this._lastPosition !== e2 &amp;&amp; this._time &gt;= 0;
    this._lastPosition = e2;
    const a2 = this.duration(), s2 = this._lastTime &lt;= 0 &amp;&amp; this._time &gt; 0, r2 = this._lastTime &lt; a2 &amp;&amp; this._time &gt;= a2;
    this._lastTime = this._time, s2 &amp;&amp; this.fire(&quot;start&quot;, this);
    const n2 = this._isDeclarative;
    this.done = !n2 &amp;&amp; !r2 &amp;&amp; this._time &gt;= a2, this._reseted = false;
    let o2 = false;
    return (i2 || n2) &amp;&amp; (this._initialise(i2), this.transforms = new vt(), o2 = this._run(n2 ? t2 : e2), this.fire(&quot;step&quot;, this)), this.done = this.done || o2 &amp;&amp; n2, r2 &amp;&amp; this.fire(&quot;finished&quot;, this), this;
  }
  time(t2) {
    if (null == t2) return this._time;
    const e2 = t2 - this._time;
    return this.step(e2), this;
  }
  timeline(t2) {
    return void 0 === t2 ? this._timeline : (this._timeline = t2, this);
  }
  unschedule() {
    const t2 = this.timeline();
    return t2 &amp;&amp; t2.unschedule(this), this;
  }
  _initialise(t2) {
    if (t2 || this._isDeclarative) for (let e2 = 0, i2 = this._queue.length; e2 &lt; i2; ++e2) {
      const i3 = this._queue[e2], a2 = this._isDeclarative || !i3.initialised &amp;&amp; t2;
      t2 = !i3.finished, a2 &amp;&amp; t2 &amp;&amp; (i3.initialiser.call(this), i3.initialised = true);
    }
  }
  _rememberMorpher(t2, e2) {
    if (this._history[t2] = { morpher: e2, caller: this._queue[this._queue.length - 1] }, this._isDeclarative) {
      const t3 = this.timeline();
      t3 &amp;&amp; t3.play();
    }
  }
  _run(t2) {
    let e2 = true;
    for (let i2 = 0, a2 = this._queue.length; i2 &lt; a2; ++i2) {
      const a3 = this._queue[i2], s2 = a3.runner.call(this, t2);
      a3.finished = a3.finished || true === s2, e2 = e2 &amp;&amp; a3.finished;
    }
    return e2;
  }
  _tryRetarget(t2, e2, i2) {
    if (this._history[t2]) {
      if (!this._history[t2].caller.initialised) {
        const e3 = this._queue.indexOf(this._history[t2].caller);
        return this._queue.splice(e3, 1), false;
      }
      this._history[t2].caller.retarget ? this._history[t2].caller.retarget.call(this, e2, i2) : this._history[t2].morpher.to(e2), this._history[t2].caller.finished = false;
      const a2 = this.timeline();
      return a2 &amp;&amp; a2.play(), true;
    }
    return false;
  }
};
Qe.id = 0;
var Ke = class {
  constructor(t2 = new vt(), e2 = -1, i2 = true) {
    this.transforms = t2, this.id = e2, this.done = i2;
  }
  clearTransformsFromQueue() {
  }
};
Q([Qe, Ke], { mergeWith(t2) {
  return new Ke(t2.transforms.lmultiply(this.transforms), t2.id);
} });
var ti = (t2, e2) =&gt; t2.lmultiplyO(e2);
var ei = (t2) =&gt; t2.transforms;
function ii() {
  const t2 = this._transformationRunners.runners.map(ei).reduce(ti, new vt());
  this.transform(t2), this._transformationRunners.merge(), 1 === this._transformationRunners.length() &amp;&amp; (this._frameId = null);
}
var ai = class {
  constructor() {
    this.runners = [], this.ids = [];
  }
  add(t2) {
    if (this.runners.includes(t2)) return;
    const e2 = t2.id + 1;
    return this.runners.push(t2), this.ids.push(e2), this;
  }
  clearBefore(t2) {
    const e2 = this.ids.indexOf(t2 + 1) || 1;
    return this.ids.splice(0, e2, 0), this.runners.splice(0, e2, new Ke()).forEach((t3) =&gt; t3.clearTransformsFromQueue()), this;
  }
  edit(t2, e2) {
    const i2 = this.ids.indexOf(t2 + 1);
    return this.ids.splice(i2, 1, t2 + 1), this.runners.splice(i2, 1, e2), this;
  }
  getByID(t2) {
    return this.runners[this.ids.indexOf(t2 + 1)];
  }
  length() {
    return this.ids.length;
  }
  merge() {
    let t2 = null;
    for (let e2 = 0; e2 &lt; this.runners.length; ++e2) {
      const i2 = this.runners[e2];
      if (t2 &amp;&amp; i2.done &amp;&amp; t2.done &amp;&amp; (!i2._timeline || !i2._timeline._runnerIds.includes(i2.id)) &amp;&amp; (!t2._timeline || !t2._timeline._runnerIds.includes(t2.id))) {
        this.remove(i2.id);
        const a2 = i2.mergeWith(t2);
        this.edit(t2.id, a2), t2 = a2, --e2;
      } else t2 = i2;
    }
    return this;
  }
  remove(t2) {
    const e2 = this.ids.indexOf(t2 + 1);
    return this.ids.splice(e2, 1), this.runners.splice(e2, 1), this;
  }
};
A({ Element: { animate(t2, e2, i2) {
  const a2 = Qe.sanitise(t2, e2, i2), s2 = this.timeline();
  return new Qe(a2.duration).loop(a2).element(this).timeline(s2.play()).schedule(a2.delay, a2.when);
}, delay(t2, e2) {
  return this.animate(0, t2, e2);
}, _clearTransformRunnersBefore(t2) {
  this._transformationRunners.clearBefore(t2.id);
}, _currentTransform(t2) {
  return this._transformationRunners.runners.filter((e2) =&gt; e2.id &lt;= t2.id).map(ei).reduce(ti, new vt());
}, _addRunner(t2) {
  this._transformationRunners.add(t2), qe.cancelImmediate(this._frameId), this._frameId = qe.immediate(ii.bind(this));
}, _prepareRunner() {
  null == this._frameId &amp;&amp; (this._transformationRunners = new ai().add(new Ke(new vt(this))));
} } });
Q(Qe, { attr(t2, e2) {
  return this.styleAttr(&quot;attr&quot;, t2, e2);
}, css(t2, e2) {
  return this.styleAttr(&quot;css&quot;, t2, e2);
}, styleAttr(t2, e2, i2) {
  if (&quot;string&quot; == typeof e2) return this.styleAttr(t2, { [e2]: i2 });
  let a2 = e2;
  if (this._tryRetarget(t2, a2)) return this;
  let s2 = new He(this._stepper).to(a2), r2 = Object.keys(a2);
  return this.queue(function() {
    s2 = s2.from(this.element()[t2](r2));
  }, function(e3) {
    return this.element()[t2](s2.at(e3).valueOf()), s2.done();
  }, function(e3) {
    const i3 = Object.keys(e3), n2 = (o2 = r2, i3.filter((t3) =&gt; !o2.includes(t3)));
    var o2;
    if (n2.length) {
      const e4 = this.element()[t2](n2), i4 = new _e(s2.from()).valueOf();
      Object.assign(i4, e4), s2.from(i4);
    }
    const l2 = new _e(s2.to()).valueOf();
    Object.assign(l2, e3), s2.to(l2), r2 = i3, a2 = e3;
  }), this._rememberMorpher(t2, s2), this;
}, zoom(t2, e2) {
  if (this._tryRetarget(&quot;zoom&quot;, t2, e2)) return this;
  let i2 = new He(this._stepper).to(new _t(t2));
  return this.queue(function() {
    i2 = i2.from(this.element().zoom());
  }, function(t3) {
    return this.element().zoom(i2.at(t3), e2), i2.done();
  }, function(t3, a2) {
    e2 = a2, i2.to(t3);
  }), this._rememberMorpher(&quot;zoom&quot;, i2), this;
}, transform(t2, e2, i2) {
  if (e2 = t2.relative || e2, this._isDeclarative &amp;&amp; !e2 &amp;&amp; this._tryRetarget(&quot;transform&quot;, t2)) return this;
  const a2 = vt.isMatrixLike(t2);
  i2 = null != t2.affine ? t2.affine : null != i2 ? i2 : !a2;
  const s2 = new He(this._stepper).type(i2 ? Fe : vt);
  let r2, n2, o2, l2, h2;
  return this.queue(function() {
    n2 = n2 || this.element(), r2 = r2 || T(t2, n2), h2 = new vt(e2 ? void 0 : n2), n2._addRunner(this), e2 || n2._clearTransformRunnersBefore(this);
  }, function(c2) {
    e2 || this.clearTransform();
    const { x: d2, y: u2 } = new bt(r2).transform(n2._currentTransform(this));
    let g2 = new vt({ ...t2, origin: [d2, u2] }), p2 = this._isDeclarative &amp;&amp; o2 ? o2 : h2;
    if (i2) {
      g2 = g2.decompose(d2, u2), p2 = p2.decompose(d2, u2);
      const t3 = g2.rotate, e3 = p2.rotate, i3 = [t3 - 360, t3, t3 + 360], a3 = i3.map((t4) =&gt; Math.abs(t4 - e3)), s3 = Math.min(...a3), r3 = a3.indexOf(s3);
      g2.rotate = i3[r3];
    }
    e2 &amp;&amp; (a2 || (g2.rotate = t2.rotate || 0), this._isDeclarative &amp;&amp; l2 &amp;&amp; (p2.rotate = l2)), s2.from(p2), s2.to(g2);
    const f2 = s2.at(c2);
    return l2 = f2.rotate, o2 = new vt(f2), this.addTransform(o2), n2._addRunner(this), s2.done();
  }, function(e3) {
    (e3.origin || &quot;center&quot;).toString() !== (t2.origin || &quot;center&quot;).toString() &amp;&amp; (r2 = T(e3, n2)), t2 = { ...e3, origin: r2 };
  }, true), this._isDeclarative &amp;&amp; this._rememberMorpher(&quot;transform&quot;, s2), this;
}, x(t2) {
  return this._queueNumber(&quot;x&quot;, t2);
}, y(t2) {
  return this._queueNumber(&quot;y&quot;, t2);
}, ax(t2) {
  return this._queueNumber(&quot;ax&quot;, t2);
}, ay(t2) {
  return this._queueNumber(&quot;ay&quot;, t2);
}, dx(t2 = 0) {
  return this._queueNumberDelta(&quot;x&quot;, t2);
}, dy(t2 = 0) {
  return this._queueNumberDelta(&quot;y&quot;, t2);
}, dmove(t2, e2) {
  return this.dx(t2).dy(e2);
}, _queueNumberDelta(t2, e2) {
  if (e2 = new _t(e2), this._tryRetarget(t2, e2)) return this;
  const i2 = new He(this._stepper).to(e2);
  let a2 = null;
  return this.queue(function() {
    a2 = this.element()[t2](), i2.from(a2), i2.to(a2 + e2);
  }, function(e3) {
    return this.element()[t2](i2.at(e3)), i2.done();
  }, function(t3) {
    i2.to(a2 + new _t(t3));
  }), this._rememberMorpher(t2, i2), this;
}, _queueObject(t2, e2) {
  if (this._tryRetarget(t2, e2)) return this;
  const i2 = new He(this._stepper).to(e2);
  return this.queue(function() {
    i2.from(this.element()[t2]());
  }, function(e3) {
    return this.element()[t2](i2.at(e3)), i2.done();
  }), this._rememberMorpher(t2, i2), this;
}, _queueNumber(t2, e2) {
  return this._queueObject(t2, new _t(e2));
}, cx(t2) {
  return this._queueNumber(&quot;cx&quot;, t2);
}, cy(t2) {
  return this._queueNumber(&quot;cy&quot;, t2);
}, move(t2, e2) {
  return this.x(t2).y(e2);
}, amove(t2, e2) {
  return this.ax(t2).ay(e2);
}, center(t2, e2) {
  return this.cx(t2).cy(e2);
}, size(t2, e2) {
  let i2;
  return t2 &amp;&amp; e2 || (i2 = this._element.bbox()), t2 || (t2 = i2.width / i2.height * e2), e2 || (e2 = i2.height / i2.width * t2), this.width(t2).height(e2);
}, width(t2) {
  return this._queueNumber(&quot;width&quot;, t2);
}, height(t2) {
  return this._queueNumber(&quot;height&quot;, t2);
}, plot(t2, e2, i2, a2) {
  if (4 === arguments.length) return this.plot([t2, e2, i2, a2]);
  if (this._tryRetarget(&quot;plot&quot;, t2)) return this;
  const s2 = new He(this._stepper).type(this._element.MorphArray).to(t2);
  return this.queue(function() {
    s2.from(this._element.array());
  }, function(t3) {
    return this._element.plot(s2.at(t3)), s2.done();
  }), this._rememberMorpher(&quot;plot&quot;, s2), this;
}, leading(t2) {
  return this._queueNumber(&quot;leading&quot;, t2);
}, viewbox(t2, e2, i2, a2) {
  return this._queueObject(&quot;viewbox&quot;, new kt(t2, e2, i2, a2));
}, update(t2) {
  return &quot;object&quot; != typeof t2 ? this.update({ offset: arguments[0], color: arguments[1], opacity: arguments[2] }) : (null != t2.opacity &amp;&amp; this.attr(&quot;stop-opacity&quot;, t2.opacity), null != t2.color &amp;&amp; this.attr(&quot;stop-color&quot;, t2.color), null != t2.offset &amp;&amp; this.attr(&quot;offset&quot;, t2.offset), this);
} }), Q(Qe, { rx: Zt, ry: $t, from: ne, to: oe }), q(Qe, &quot;Runner&quot;);
var si = class extends Vt {
  constructor(t2, e2 = t2) {
    super(G(&quot;svg&quot;, t2), e2), this.namespace();
  }
  defs() {
    return this.isRoot() ? V(this.node.querySelector(&quot;defs&quot;)) || this.put(new Ut()) : this.root().defs();
  }
  isRoot() {
    return !this.node.parentNode || !(this.node.parentNode instanceof O.window.SVGElement) &amp;&amp; &quot;#document-fragment&quot; !== this.node.parentNode.nodeName;
  }
  namespace() {
    return this.isRoot() ? this.attr({ xmlns: E, version: &quot;1.1&quot; }).attr(&quot;xmlns:xlink&quot;, H, Y) : this.root().namespace();
  }
  removeNamespace() {
    return this.attr({ xmlns: null, version: null }).attr(&quot;xmlns:xlink&quot;, null, Y).attr(&quot;xmlns:svgjs&quot;, null, Y);
  }
  root() {
    return this.isRoot() ? this : super.root();
  }
};
A({ Container: { nested: K(function() {
  return this.put(new si());
}) } }), q(si, &quot;Svg&quot;, true);
var ri = class extends Vt {
  constructor(t2, e2 = t2) {
    super(G(&quot;symbol&quot;, t2), e2);
  }
};
A({ Container: { symbol: K(function() {
  return this.put(new ri());
}) } }), q(ri, &quot;Symbol&quot;);
var ni = Object.freeze({ __proto__: null, amove: function(t2, e2) {
  return this.ax(t2).ay(e2);
}, ax: function(t2) {
  return this.attr(&quot;x&quot;, t2);
}, ay: function(t2) {
  return this.attr(&quot;y&quot;, t2);
}, build: function(t2) {
  return this._build = !!t2, this;
}, center: function(t2, e2, i2 = this.bbox()) {
  return this.cx(t2, i2).cy(e2, i2);
}, cx: function(t2, e2 = this.bbox()) {
  return null == t2 ? e2.cx : this.attr(&quot;x&quot;, this.attr(&quot;x&quot;) + t2 - e2.cx);
}, cy: function(t2, e2 = this.bbox()) {
  return null == t2 ? e2.cy : this.attr(&quot;y&quot;, this.attr(&quot;y&quot;) + t2 - e2.cy);
}, length: function() {
  return this.node.getComputedTextLength();
}, move: function(t2, e2, i2 = this.bbox()) {
  return this.x(t2, i2).y(e2, i2);
}, plain: function(t2) {
  return false === this._build &amp;&amp; this.clear(), this.node.appendChild(O.document.createTextNode(t2)), this;
}, x: function(t2, e2 = this.bbox()) {
  return null == t2 ? e2.x : this.attr(&quot;x&quot;, this.attr(&quot;x&quot;) + t2 - e2.x);
}, y: function(t2, e2 = this.bbox()) {
  return null == t2 ? e2.y : this.attr(&quot;y&quot;, this.attr(&quot;y&quot;) + t2 - e2.y);
} });
var oi = class extends qt {
  constructor(t2, e2 = t2) {
    super(G(&quot;text&quot;, t2), e2), this.dom.leading = this.dom.leading ?? new _t(1.3), this._rebuild = true, this._build = false;
  }
  leading(t2) {
    return null == t2 ? this.dom.leading : (this.dom.leading = new _t(t2), this.rebuild());
  }
  rebuild(t2) {
    if (&quot;boolean&quot; == typeof t2 &amp;&amp; (this._rebuild = t2), this._rebuild) {
      const t3 = this;
      let e2 = 0;
      const i2 = this.dom.leading;
      this.each(function(a2) {
        if (X(this.node)) return;
        const s2 = O.window.getComputedStyle(this.node).getPropertyValue(&quot;font-size&quot;), r2 = i2 * new _t(s2);
        this.dom.newLined &amp;&amp; (this.attr(&quot;x&quot;, t3.attr(&quot;x&quot;)), &quot;\n&quot; === this.text() ? e2 += r2 : (this.attr(&quot;dy&quot;, a2 ? r2 + e2 : 0), e2 = 0));
      }), this.fire(&quot;rebuild&quot;);
    }
    return this;
  }
  setData(t2) {
    return this.dom = t2, this.dom.leading = new _t(t2.leading || 1.3), this;
  }
  writeDataToDom() {
    return R(this, this.dom, { leading: 1.3 }), this;
  }
  text(t2) {
    if (void 0 === t2) {
      const e2 = this.node.childNodes;
      let i2 = 0;
      t2 = &quot;&quot;;
      for (let a2 = 0, s2 = e2.length; a2 &lt; s2; ++a2) &quot;textPath&quot; === e2[a2].nodeName || X(e2[a2]) ? 0 === a2 &amp;&amp; (i2 = a2 + 1) : (a2 !== i2 &amp;&amp; 3 !== e2[a2].nodeType &amp;&amp; true === V(e2[a2]).dom.newLined &amp;&amp; (t2 += &quot;\n&quot;), t2 += e2[a2].textContent);
      return t2;
    }
    if (this.clear().build(true), &quot;function&quot; == typeof t2) t2.call(this, this);
    else for (let e2 = 0, i2 = (t2 = (t2 + &quot;&quot;).split(&quot;\n&quot;)).length; e2 &lt; i2; e2++) this.newLine(t2[e2]);
    return this.build(false).rebuild();
  }
};
Q(oi, ni), A({ Container: { text: K(function(t2 = &quot;&quot;) {
  return this.put(new oi()).text(t2);
}), plain: K(function(t2 = &quot;&quot;) {
  return this.put(new oi()).plain(t2);
}) } }), q(oi, &quot;Text&quot;);
var li = class extends qt {
  constructor(t2, e2 = t2) {
    super(G(&quot;tspan&quot;, t2), e2), this._build = false;
  }
  dx(t2) {
    return this.attr(&quot;dx&quot;, t2);
  }
  dy(t2) {
    return this.attr(&quot;dy&quot;, t2);
  }
  newLine() {
    this.dom.newLined = true;
    const t2 = this.parent();
    if (!(t2 instanceof oi)) return this;
    const e2 = t2.index(this), i2 = O.window.getComputedStyle(this.node).getPropertyValue(&quot;font-size&quot;), a2 = t2.dom.leading * new _t(i2);
    return this.dy(e2 ? a2 : 0).attr(&quot;x&quot;, t2.x());
  }
  text(t2) {
    return null == t2 ? this.node.textContent + (this.dom.newLined ? &quot;\n&quot; : &quot;&quot;) : (&quot;function&quot; == typeof t2 ? (this.clear().build(true), t2.call(this, this), this.build(false)) : this.plain(t2), this);
  }
};
Q(li, ni), A({ Tspan: { tspan: K(function(t2 = &quot;&quot;) {
  const e2 = new li();
  return this._build || this.clear(), this.put(e2).text(t2);
}) }, Text: { newLine: function(t2 = &quot;&quot;) {
  return this.tspan(t2).newLine();
} } }), q(li, &quot;Tspan&quot;);
var hi = class extends qt {
  constructor(t2, e2 = t2) {
    super(G(&quot;circle&quot;, t2), e2);
  }
  radius(t2) {
    return this.attr(&quot;r&quot;, t2);
  }
  rx(t2) {
    return this.attr(&quot;r&quot;, t2);
  }
  ry(t2) {
    return this.rx(t2);
  }
  size(t2) {
    return this.radius(new _t(t2).divide(2));
  }
};
Q(hi, { x: Jt, y: Qt, cx: Kt, cy: te, width: ee, height: ie }), A({ Container: { circle: K(function(t2 = 0) {
  return this.put(new hi()).size(t2).move(0, 0);
}) } }), q(hi, &quot;Circle&quot;);
var ci = class extends Vt {
  constructor(t2, e2 = t2) {
    super(G(&quot;clipPath&quot;, t2), e2);
  }
  remove() {
    return this.targets().forEach(function(t2) {
      t2.unclip();
    }), super.remove();
  }
  targets() {
    return Lt(&quot;svg [clip-path*=&quot; + this.id() + &quot;]&quot;);
  }
};
A({ Container: { clip: K(function() {
  return this.defs().put(new ci());
}) }, Element: { clipper() {
  return this.reference(&quot;clip-path&quot;);
}, clipWith(t2) {
  const e2 = t2 instanceof ci ? t2 : this.parent().clip().add(t2);
  return this.attr(&quot;clip-path&quot;, &quot;url(#&quot; + e2.id() + &quot;)&quot;);
}, unclip() {
  return this.attr(&quot;clip-path&quot;, null);
} } }), q(ci, &quot;ClipPath&quot;);
var di = class extends Gt {
  constructor(t2, e2 = t2) {
    super(G(&quot;foreignObject&quot;, t2), e2);
  }
};
A({ Container: { foreignObject: K(function(t2, e2) {
  return this.put(new di()).size(t2, e2);
}) } }), q(di, &quot;ForeignObject&quot;);
var ui = Object.freeze({ __proto__: null, dmove: function(t2, e2) {
  return this.children().forEach((i2) =&gt; {
    let a2;
    try {
      a2 = i2.node instanceof F().SVGSVGElement ? new kt(i2.attr([&quot;x&quot;, &quot;y&quot;, &quot;width&quot;, &quot;height&quot;])) : i2.bbox();
    } catch (t3) {
      return;
    }
    const s2 = new vt(i2), r2 = s2.translate(t2, e2).transform(s2.inverse()), n2 = new bt(a2.x, a2.y).transform(r2);
    i2.move(n2.x, n2.y);
  }), this;
}, dx: function(t2) {
  return this.dmove(t2, 0);
}, dy: function(t2) {
  return this.dmove(0, t2);
}, height: function(t2, e2 = this.bbox()) {
  return null == t2 ? e2.height : this.size(e2.width, t2, e2);
}, move: function(t2 = 0, e2 = 0, i2 = this.bbox()) {
  const a2 = t2 - i2.x, s2 = e2 - i2.y;
  return this.dmove(a2, s2);
}, size: function(t2, e2, i2 = this.bbox()) {
  const a2 = I(this, t2, e2, i2), s2 = a2.width / i2.width, r2 = a2.height / i2.height;
  return this.children().forEach((t3) =&gt; {
    const e3 = new bt(i2).transform(new vt(t3).inverse());
    t3.scale(s2, r2, e3.x, e3.y);
  }), this;
}, width: function(t2, e2 = this.bbox()) {
  return null == t2 ? e2.width : this.size(t2, e2.height, e2);
}, x: function(t2, e2 = this.bbox()) {
  return null == t2 ? e2.x : this.move(t2, e2.y, e2);
}, y: function(t2, e2 = this.bbox()) {
  return null == t2 ? e2.y : this.move(e2.x, t2, e2);
} });
var gi = class extends Vt {
  constructor(t2, e2 = t2) {
    super(G(&quot;g&quot;, t2), e2);
  }
};
Q(gi, ui), A({ Container: { group: K(function() {
  return this.put(new gi());
}) } }), q(gi, &quot;G&quot;);
var pi = class extends Vt {
  constructor(t2, e2 = t2) {
    super(G(&quot;a&quot;, t2), e2);
  }
  target(t2) {
    return this.attr(&quot;target&quot;, t2);
  }
  to(t2) {
    return this.attr(&quot;href&quot;, t2, H);
  }
};
Q(pi, ui), A({ Container: { link: K(function(t2) {
  return this.put(new pi()).to(t2);
}) }, Element: { unlink() {
  const t2 = this.linker();
  if (!t2) return this;
  const e2 = t2.parent();
  if (!e2) return this.remove();
  const i2 = e2.index(t2);
  return e2.add(this, i2), t2.remove(), this;
}, linkTo(t2) {
  let e2 = this.linker();
  return e2 || (e2 = new pi(), this.wrap(e2)), &quot;function&quot; == typeof t2 ? t2.call(e2, e2) : e2.to(t2), this;
}, linker() {
  const t2 = this.parent();
  return t2 &amp;&amp; &quot;a&quot; === t2.node.nodeName.toLowerCase() ? t2 : null;
} } }), q(pi, &quot;A&quot;);
var fi = class extends Vt {
  constructor(t2, e2 = t2) {
    super(G(&quot;mask&quot;, t2), e2);
  }
  remove() {
    return this.targets().forEach(function(t2) {
      t2.unmask();
    }), super.remove();
  }
  targets() {
    return Lt(&quot;svg [mask*=&quot; + this.id() + &quot;]&quot;);
  }
};
A({ Container: { mask: K(function() {
  return this.defs().put(new fi());
}) }, Element: { masker() {
  return this.reference(&quot;mask&quot;);
}, maskWith(t2) {
  const e2 = t2 instanceof fi ? t2 : this.parent().mask().add(t2);
  return this.attr(&quot;mask&quot;, &quot;url(#&quot; + e2.id() + &quot;)&quot;);
}, unmask() {
  return this.attr(&quot;mask&quot;, null);
} } }), q(fi, &quot;Mask&quot;);
var xi = class extends Gt {
  constructor(t2, e2 = t2) {
    super(G(&quot;stop&quot;, t2), e2);
  }
  update(t2) {
    return (&quot;number&quot; == typeof t2 || t2 instanceof _t) &amp;&amp; (t2 = { offset: arguments[0], color: arguments[1], opacity: arguments[2] }), null != t2.opacity &amp;&amp; this.attr(&quot;stop-opacity&quot;, t2.opacity), null != t2.color &amp;&amp; this.attr(&quot;stop-color&quot;, t2.color), null != t2.offset &amp;&amp; this.attr(&quot;offset&quot;, new _t(t2.offset)), this;
  }
};
A({ Gradient: { stop: function(t2, e2, i2) {
  return this.put(new xi()).update(t2, e2, i2);
} } }), q(xi, &quot;Stop&quot;);
var bi = class extends Gt {
  constructor(t2, e2 = t2) {
    super(G(&quot;style&quot;, t2), e2);
  }
  addText(t2 = &quot;&quot;) {
    return this.node.textContent += t2, this;
  }
  font(t2, e2, i2 = {}) {
    return this.rule(&quot;@font-face&quot;, { fontFamily: t2, src: e2, ...i2 });
  }
  rule(t2, e2) {
    return this.addText(function(t3, e3) {
      if (!t3) return &quot;&quot;;
      if (!e3) return t3;
      let i2 = t3 + &quot;{&quot;;
      for (const t4 in e3) i2 += t4.replace(/([A-Z])/g, function(t5, e4) {
        return &quot;-&quot; + e4.toLowerCase();
      }) + &quot;:&quot; + e3[t4] + &quot;;&quot;;
      return i2 += &quot;}&quot;, i2;
    }(t2, e2));
  }
};
A(&quot;Dom&quot;, { style(t2, e2) {
  return this.put(new bi()).rule(t2, e2);
}, fontface(t2, e2, i2) {
  return this.put(new bi()).font(t2, e2, i2);
} }), q(bi, &quot;Style&quot;);
var mi = class extends oi {
  constructor(t2, e2 = t2) {
    super(G(&quot;textPath&quot;, t2), e2);
  }
  array() {
    const t2 = this.track();
    return t2 ? t2.array() : null;
  }
  plot(t2) {
    const e2 = this.track();
    let i2 = null;
    return e2 &amp;&amp; (i2 = e2.plot(t2)), null == t2 ? i2 : this;
  }
  track() {
    return this.reference(&quot;href&quot;);
  }
};
A({ Container: { textPath: K(function(t2, e2) {
  return t2 instanceof oi || (t2 = this.text(t2)), t2.path(e2);
}) }, Text: { path: K(function(t2, e2 = true) {
  const i2 = new mi();
  let a2;
  if (t2 instanceof We || (t2 = this.defs().path(t2)), i2.attr(&quot;href&quot;, &quot;#&quot; + t2, H), e2) for (; a2 = this.node.firstChild; ) i2.node.appendChild(a2);
  return this.put(i2);
}), textPath() {
  return this.findOne(&quot;textPath&quot;);
} }, Path: { text: K(function(t2) {
  return t2 instanceof oi || (t2 = new oi().addTo(this.parent()).text(t2)), t2.path(this);
}), targets() {
  return Lt(&quot;svg textPath&quot;).filter((t2) =&gt; (t2.attr(&quot;href&quot;) || &quot;&quot;).includes(this.id()));
} } }), mi.prototype.MorphArray = Ee, q(mi, &quot;TextPath&quot;);
var vi = class extends qt {
  constructor(t2, e2 = t2) {
    super(G(&quot;use&quot;, t2), e2);
  }
  use(t2, e2) {
    return this.attr(&quot;href&quot;, (e2 || &quot;&quot;) + &quot;#&quot; + t2, H);
  }
};
A({ Container: { use: K(function(t2, e2) {
  return this.put(new vi()).use(t2, e2);
}) } }), q(vi, &quot;Use&quot;);
var yi = B;
Q([si, ri, de, ce, be], C(&quot;viewbox&quot;)), Q([xe, je, Ge, We], C(&quot;marker&quot;)), Q(oi, C(&quot;Text&quot;)), Q(We, C(&quot;Path&quot;)), Q(Ut, C(&quot;Defs&quot;)), Q([oi, li], C(&quot;Tspan&quot;)), Q([Ve, se, he, Qe], C(&quot;radius&quot;)), Q(Rt, C(&quot;EventTarget&quot;)), Q(Bt, C(&quot;Dom&quot;)), Q(Gt, C(&quot;Element&quot;)), Q(qt, C(&quot;Shape&quot;)), Q([Vt, re], C(&quot;Container&quot;)), Q(he, C(&quot;Gradient&quot;)), Q(Qe, C(&quot;Runner&quot;)), Ct.extend([...new Set(k)]), function(t2 = []) {
  Ne.push(...[].concat(t2));
}([_t, xt, kt, vt, Dt, ge, Ee, bt]), Q(Ne, { to(t2) {
  return new He().type(this.constructor).from(this.toArray()).to(t2);
}, fromArray(t2) {
  return this.init(t2), this;
}, toConsumable() {
  return this.toArray();
}, morph(t2, e2, i2, a2, s2) {
  return this.fromArray(t2.map(function(t3, r2) {
    return a2.step(t3, e2[r2], i2, s2[r2], s2);
  }));
} });
var wi = class extends Gt {
  constructor(t2) {
    super(G(&quot;filter&quot;, t2), t2), this.$source = &quot;SourceGraphic&quot;, this.$sourceAlpha = &quot;SourceAlpha&quot;, this.$background = &quot;BackgroundImage&quot;, this.$backgroundAlpha = &quot;BackgroundAlpha&quot;, this.$fill = &quot;FillPaint&quot;, this.$stroke = &quot;StrokePaint&quot;, this.$autoSetIn = true;
  }
  put(t2, e2) {
    return !(t2 = super.put(t2, e2)).attr(&quot;in&quot;) &amp;&amp; this.$autoSetIn &amp;&amp; t2.attr(&quot;in&quot;, this.$source), t2.attr(&quot;result&quot;) || t2.attr(&quot;result&quot;, t2.id()), t2;
  }
  remove() {
    return this.targets().each(&quot;unfilter&quot;), super.remove();
  }
  targets() {
    return Lt(&#x27;svg [filter*=&quot;&#x27; + this.id() + &#x27;&quot;]&#x27;);
  }
  toString() {
    return &quot;url(#&quot; + this.id() + &quot;)&quot;;
  }
};
var ki = class extends Gt {
  constructor(t2, e2) {
    super(t2, e2), this.result(this.id());
  }
  in(t2) {
    if (null == t2) {
      const t3 = this.attr(&quot;in&quot;);
      return this.parent() &amp;&amp; this.parent().find(`[result=&quot;${t3}&quot;]`)[0] || t3;
    }
    return this.attr(&quot;in&quot;, t2);
  }
  result(t2) {
    return this.attr(&quot;result&quot;, t2);
  }
  toString() {
    return this.result();
  }
};
var Ai = (t2) =&gt; function(...e2) {
  for (let i2 = t2.length; i2--; ) null != e2[i2] &amp;&amp; this.attr(t2[i2], e2[i2]);
};
var Ci = { blend: Ai([&quot;in&quot;, &quot;in2&quot;, &quot;mode&quot;]), colorMatrix: Ai([&quot;type&quot;, &quot;values&quot;]), composite: Ai([&quot;in&quot;, &quot;in2&quot;, &quot;operator&quot;]), convolveMatrix: function(t2) {
  t2 = new Dt(t2).toString(), this.attr({ order: Math.sqrt(t2.split(&quot; &quot;).length), kernelMatrix: t2 });
}, diffuseLighting: Ai([&quot;surfaceScale&quot;, &quot;lightingColor&quot;, &quot;diffuseConstant&quot;, &quot;kernelUnitLength&quot;]), displacementMap: Ai([&quot;in&quot;, &quot;in2&quot;, &quot;scale&quot;, &quot;xChannelSelector&quot;, &quot;yChannelSelector&quot;]), dropShadow: Ai([&quot;in&quot;, &quot;dx&quot;, &quot;dy&quot;, &quot;stdDeviation&quot;]), flood: Ai([&quot;flood-color&quot;, &quot;flood-opacity&quot;]), gaussianBlur: function(t2 = 0, e2 = t2) {
  this.attr(&quot;stdDeviation&quot;, t2 + &quot; &quot; + e2);
}, image: function(t2) {
  this.attr(&quot;href&quot;, t2, H);
}, morphology: Ai([&quot;operator&quot;, &quot;radius&quot;]), offset: Ai([&quot;dx&quot;, &quot;dy&quot;]), specularLighting: Ai([&quot;surfaceScale&quot;, &quot;lightingColor&quot;, &quot;diffuseConstant&quot;, &quot;specularExponent&quot;, &quot;kernelUnitLength&quot;]), tile: Ai([]), turbulence: Ai([&quot;baseFrequency&quot;, &quot;numOctaves&quot;, &quot;seed&quot;, &quot;stitchTiles&quot;, &quot;type&quot;]) };
[&quot;blend&quot;, &quot;colorMatrix&quot;, &quot;componentTransfer&quot;, &quot;composite&quot;, &quot;convolveMatrix&quot;, &quot;diffuseLighting&quot;, &quot;displacementMap&quot;, &quot;dropShadow&quot;, &quot;flood&quot;, &quot;gaussianBlur&quot;, &quot;image&quot;, &quot;merge&quot;, &quot;morphology&quot;, &quot;offset&quot;, &quot;specularLighting&quot;, &quot;tile&quot;, &quot;turbulence&quot;].forEach((t2) =&gt; {
  const e2 = P(t2), i2 = Ci[t2];
  wi[e2 + &quot;Effect&quot;] = class extends ki {
    constructor(t3) {
      super(G(&quot;fe&quot; + e2, t3), t3);
    }
    update(t3) {
      return i2.apply(this, t3), this;
    }
  }, wi.prototype[t2] = K(function(t3, ...i3) {
    const a2 = new wi[e2 + &quot;Effect&quot;]();
    return null == t3 ? this.put(a2) : (&quot;function&quot; == typeof t3 ? t3.call(a2, a2) : i3.unshift(t3), this.put(a2).update(i3));
  });
}), Q(wi, { merge(t2) {
  const e2 = this.put(new wi.MergeEffect());
  if (&quot;function&quot; == typeof t2) return t2.call(e2, e2), e2;
  return (t2 instanceof Array ? t2 : [...arguments]).forEach((t3) =&gt; {
    t3 instanceof wi.MergeNode ? e2.put(t3) : e2.mergeNode(t3);
  }), e2;
}, componentTransfer(t2 = {}) {
  const e2 = this.put(new wi.ComponentTransferEffect());
  if (&quot;function&quot; == typeof t2) return t2.call(e2, e2), e2;
  if (!(t2.r || t2.g || t2.b || t2.a)) {
    t2 = { r: t2, g: t2, b: t2, a: t2 };
  }
  for (const i2 in t2) e2.add(new wi[&quot;Func&quot; + i2.toUpperCase()](t2[i2]));
  return e2;
} });
[&quot;distantLight&quot;, &quot;pointLight&quot;, &quot;spotLight&quot;, &quot;mergeNode&quot;, &quot;FuncR&quot;, &quot;FuncG&quot;, &quot;FuncB&quot;, &quot;FuncA&quot;].forEach((t2) =&gt; {
  const e2 = P(t2);
  wi[e2] = class extends ki {
    constructor(t3) {
      super(G(&quot;fe&quot; + e2, t3), t3);
    }
  };
});
[&quot;funcR&quot;, &quot;funcG&quot;, &quot;funcB&quot;, &quot;funcA&quot;].forEach(function(t2) {
  const e2 = wi[P(t2)], i2 = K(function() {
    return this.put(new e2());
  });
  wi.ComponentTransferEffect.prototype[t2] = i2;
});
[&quot;distantLight&quot;, &quot;pointLight&quot;, &quot;spotLight&quot;].forEach((t2) =&gt; {
  const e2 = wi[P(t2)], i2 = K(function() {
    return this.put(new e2());
  });
  wi.DiffuseLightingEffect.prototype[t2] = i2, wi.SpecularLightingEffect.prototype[t2] = i2;
}), Q(wi.MergeEffect, { mergeNode(t2) {
  return this.put(new wi.MergeNode()).attr(&quot;in&quot;, t2);
} }), Q(Ut, { filter: function(t2) {
  const e2 = this.put(new wi());
  return &quot;function&quot; == typeof t2 &amp;&amp; t2.call(e2, e2), e2;
} }), Q(Vt, { filter: function(t2) {
  return this.defs().filter(t2);
} }), Q(Gt, { filterWith: function(t2) {
  const e2 = t2 instanceof wi ? t2 : this.defs().filter(t2);
  return this.attr(&quot;filter&quot;, e2);
}, unfilter: function(t2) {
  return this.attr(&quot;filter&quot;, null);
}, filterer() {
  return this.reference(&quot;filter&quot;);
} });
var Si = { blend: function(t2, e2) {
  return this.parent() &amp;&amp; this.parent().blend(this, t2, e2);
}, colorMatrix: function(t2, e2) {
  return this.parent() &amp;&amp; this.parent().colorMatrix(t2, e2).in(this);
}, componentTransfer: function(t2) {
  return this.parent() &amp;&amp; this.parent().componentTransfer(t2).in(this);
}, composite: function(t2, e2) {
  return this.parent() &amp;&amp; this.parent().composite(this, t2, e2);
}, convolveMatrix: function(t2) {
  return this.parent() &amp;&amp; this.parent().convolveMatrix(t2).in(this);
}, diffuseLighting: function(t2, e2, i2, a2) {
  return this.parent() &amp;&amp; this.parent().diffuseLighting(t2, i2, a2).in(this);
}, displacementMap: function(t2, e2, i2, a2) {
  return this.parent() &amp;&amp; this.parent().displacementMap(this, t2, e2, i2, a2);
}, dropShadow: function(t2, e2, i2) {
  return this.parent() &amp;&amp; this.parent().dropShadow(this, t2, e2, i2).in(this);
}, flood: function(t2, e2) {
  return this.parent() &amp;&amp; this.parent().flood(t2, e2);
}, gaussianBlur: function(t2, e2) {
  return this.parent() &amp;&amp; this.parent().gaussianBlur(t2, e2).in(this);
}, image: function(t2) {
  return this.parent() &amp;&amp; this.parent().image(t2);
}, merge: function(t2) {
  return t2 = t2 instanceof Array ? t2 : [...t2], this.parent() &amp;&amp; this.parent().merge(this, ...t2);
}, morphology: function(t2, e2) {
  return this.parent() &amp;&amp; this.parent().morphology(t2, e2).in(this);
}, offset: function(t2, e2) {
  return this.parent() &amp;&amp; this.parent().offset(t2, e2).in(this);
}, specularLighting: function(t2, e2, i2, a2, s2) {
  return this.parent() &amp;&amp; this.parent().specularLighting(t2, i2, a2, s2).in(this);
}, tile: function() {
  return this.parent() &amp;&amp; this.parent().tile().in(this);
}, turbulence: function(t2, e2, i2, a2, s2) {
  return this.parent() &amp;&amp; this.parent().turbulence(t2, e2, i2, a2, s2).in(this);
} };
Q(ki, Si), Q(wi.MergeEffect, { in: function(t2) {
  return t2 instanceof wi.MergeNode ? this.add(t2, 0) : this.add(new wi.MergeNode().in(t2), 0), this;
} }), Q([wi.CompositeEffect, wi.BlendEffect, wi.DisplacementMapEffect], { in2: function(t2) {
  if (null == t2) {
    const t3 = this.attr(&quot;in2&quot;);
    return this.parent() &amp;&amp; this.parent().find(`[result=&quot;${t3}&quot;]`)[0] || t3;
  }
  return this.attr(&quot;in2&quot;, t2);
} }), wi.filter = { sepiatone: [0.343, 0.669, 0.119, 0, 0, 0.249, 0.626, 0.13, 0, 0, 0.172, 0.334, 0.111, 0, 0, 0, 0, 0, 1, 0] };
var Li = function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w;
  }
  return s(t2, [{ key: &quot;getDefaultFilter&quot;, value: function(t3, e2) {
    var i2 = this.w;
    t3.unfilter(true), new wi().size(&quot;120%&quot;, &quot;180%&quot;, &quot;-5%&quot;, &quot;-40%&quot;), i2.config.chart.dropShadow.enabled &amp;&amp; this.dropShadow(t3, i2.config.chart.dropShadow, e2);
  } }, { key: &quot;applyFilter&quot;, value: function(t3, e2, i2) {
    var a2, s2 = this, r2 = this.w;
    if (t3.unfilter(true), &quot;none&quot; !== i2) {
      var n2, o2, l2 = r2.config.chart.dropShadow, h2 = &quot;lighten&quot; === i2 ? 2 : 0.3;
      if (t3.filterWith(function(t4) {
        t4.colorMatrix({ type: &quot;matrix&quot;, values: &quot;\n          &quot;.concat(h2, &quot; 0 0 0 0\n          0 &quot;).concat(h2, &quot; 0 0 0\n          0 0 &quot;).concat(h2, &quot; 0 0\n          0 0 0 1 0\n        &quot;), in: &quot;SourceGraphic&quot;, result: &quot;brightness&quot; }), l2.enabled &amp;&amp; s2.addShadow(t4, e2, l2, &quot;brightness&quot;);
      }), !l2.noUserSpaceOnUse) null === (n2 = t3.filterer()) || void 0 === n2 || null === (o2 = n2.node) || void 0 === o2 || o2.setAttribute(&quot;filterUnits&quot;, &quot;userSpaceOnUse&quot;);
      this._scaleFilterSize(null === (a2 = t3.filterer()) || void 0 === a2 ? void 0 : a2.node);
    } else this.getDefaultFilter(t3, e2);
  } }, { key: &quot;addShadow&quot;, value: function(t3, e2, i2, a2) {
    var s2, r2 = this.w, n2 = i2.blur, o2 = i2.top, l2 = i2.left, h2 = i2.color, c2 = i2.opacity;
    if (h2 = Array.isArray(h2) ? h2[e2] : h2, (null === (s2 = r2.config.chart.dropShadow.enabledOnSeries) || void 0 === s2 ? void 0 : s2.length) &gt; 0 &amp;&amp; -1 === r2.config.chart.dropShadow.enabledOnSeries.indexOf(e2)) return t3;
    t3.offset({ in: a2, dx: l2, dy: o2, result: &quot;offset&quot; }), t3.gaussianBlur({ in: &quot;offset&quot;, stdDeviation: n2, result: &quot;blur&quot; }), t3.flood({ &quot;flood-color&quot;: h2, &quot;flood-opacity&quot;: c2, result: &quot;flood&quot; }), t3.composite({ in: &quot;flood&quot;, in2: &quot;blur&quot;, operator: &quot;in&quot;, result: &quot;shadow&quot; }), t3.merge([&quot;shadow&quot;, a2]);
  } }, { key: &quot;dropShadow&quot;, value: function(t3, e2) {
    var i2, a2, s2, r2, n2, o2 = this, l2 = arguments.length &gt; 2 &amp;&amp; void 0 !== arguments[2] ? arguments[2] : 0, h2 = this.w;
    if (t3.unfilter(true), v.isMsEdge() &amp;&amp; &quot;radialBar&quot; === h2.config.chart.type) return t3;
    if ((null === (i2 = h2.config.chart.dropShadow.enabledOnSeries) || void 0 === i2 ? void 0 : i2.length) &gt; 0 &amp;&amp; -1 === (null === (s2 = h2.config.chart.dropShadow.enabledOnSeries) || void 0 === s2 ? void 0 : s2.indexOf(l2))) return t3;
    (t3.filterWith(function(t4) {
      o2.addShadow(t4, l2, e2, &quot;SourceGraphic&quot;);
    }), e2.noUserSpaceOnUse) || (null === (r2 = t3.filterer()) || void 0 === r2 || null === (n2 = r2.node) || void 0 === n2 || n2.setAttribute(&quot;filterUnits&quot;, &quot;userSpaceOnUse&quot;));
    return this._scaleFilterSize(null === (a2 = t3.filterer()) || void 0 === a2 ? void 0 : a2.node), t3;
  } }, { key: &quot;setSelectionFilter&quot;, value: function(t3, e2, i2) {
    var a2 = this.w;
    if (void 0 !== a2.globals.selectedDataPoints[e2] &amp;&amp; a2.globals.selectedDataPoints[e2].indexOf(i2) &gt; -1) {
      t3.node.setAttribute(&quot;selected&quot;, true);
      var s2 = a2.config.states.active.filter;
      &quot;none&quot; !== s2 &amp;&amp; this.applyFilter(t3, e2, s2.type);
    }
  } }, { key: &quot;_scaleFilterSize&quot;, value: function(t3) {
    if (t3) {
      !function(e2) {
        for (var i2 in e2) e2.hasOwnProperty(i2) &amp;&amp; t3.setAttribute(i2, e2[i2]);
      }({ width: &quot;200%&quot;, height: &quot;200%&quot;, x: &quot;-50%&quot;, y: &quot;-50%&quot; });
    }
  } }]), t2;
}();
var Mi = function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w;
  }
  return s(t2, [{ key: &quot;roundPathCorners&quot;, value: function(t3, e2) {
    function i2(t4, e3, i3) {
      var s3 = e3.x - t4.x, r3 = e3.y - t4.y, n3 = Math.sqrt(s3 * s3 + r3 * r3);
      return a2(t4, e3, Math.min(1, i3 / n3));
    }
    function a2(t4, e3, i3) {
      return { x: t4.x + (e3.x - t4.x) * i3, y: t4.y + (e3.y - t4.y) * i3 };
    }
    function s2(t4, e3) {
      t4.length &gt; 2 &amp;&amp; (t4[t4.length - 2] = e3.x, t4[t4.length - 1] = e3.y);
    }
    function r2(t4) {
      return { x: parseFloat(t4[t4.length - 2]), y: parseFloat(t4[t4.length - 1]) };
    }
    t3.indexOf(&quot;NaN&quot;) &gt; -1 &amp;&amp; (t3 = &quot;&quot;);
    var n2 = t3.split(/[,\s]/).reduce(function(t4, e3) {
      var i3 = e3.match(&quot;([a-zA-Z])(.+)&quot;);
      return i3 ? (t4.push(i3[1]), t4.push(i3[2])) : t4.push(e3), t4;
    }, []).reduce(function(t4, e3) {
      return parseFloat(e3) == e3 &amp;&amp; t4.length ? t4[t4.length - 1].push(e3) : t4.push([e3]), t4;
    }, []), o2 = [];
    if (n2.length &gt; 1) {
      var l2 = r2(n2[0]), h2 = null;
      &quot;Z&quot; == n2[n2.length - 1][0] &amp;&amp; n2[0].length &gt; 2 &amp;&amp; (h2 = [&quot;L&quot;, l2.x, l2.y], n2[n2.length - 1] = h2), o2.push(n2[0]);
      for (var c2 = 1; c2 &lt; n2.length; c2++) {
        var d2 = o2[o2.length - 1], u2 = n2[c2], g2 = u2 == h2 ? n2[1] : n2[c2 + 1];
        if (g2 &amp;&amp; d2 &amp;&amp; d2.length &gt; 2 &amp;&amp; &quot;L&quot; == u2[0] &amp;&amp; g2.length &gt; 2 &amp;&amp; &quot;L&quot; == g2[0]) {
          var p2, f2, x2 = r2(d2), b2 = r2(u2), m2 = r2(g2);
          p2 = i2(b2, x2, e2), f2 = i2(b2, m2, e2), s2(u2, p2), u2.origPoint = b2, o2.push(u2);
          var v2 = a2(p2, b2, 0.5), y2 = a2(b2, f2, 0.5), w2 = [&quot;C&quot;, v2.x, v2.y, y2.x, y2.y, f2.x, f2.y];
          w2.origPoint = b2, o2.push(w2);
        } else o2.push(u2);
      }
      if (h2) {
        var k2 = r2(o2[o2.length - 1]);
        o2.push([&quot;Z&quot;]), s2(o2[0], k2);
      }
    } else o2 = n2;
    return o2.reduce(function(t4, e3) {
      return t4 + e3.join(&quot; &quot;) + &quot; &quot;;
    }, &quot;&quot;);
  } }, { key: &quot;drawLine&quot;, value: function(t3, e2, i2, a2) {
    var s2 = arguments.length &gt; 4 &amp;&amp; void 0 !== arguments[4] ? arguments[4] : &quot;#a8a8a8&quot;, r2 = arguments.length &gt; 5 &amp;&amp; void 0 !== arguments[5] ? arguments[5] : 0, n2 = arguments.length &gt; 6 &amp;&amp; void 0 !== arguments[6] ? arguments[6] : null, o2 = arguments.length &gt; 7 &amp;&amp; void 0 !== arguments[7] ? arguments[7] : &quot;butt&quot;;
    return this.w.globals.dom.Paper.line().attr({ x1: t3, y1: e2, x2: i2, y2: a2, stroke: s2, &quot;stroke-dasharray&quot;: r2, &quot;stroke-width&quot;: n2, &quot;stroke-linecap&quot;: o2 });
  } }, { key: &quot;drawRect&quot;, value: function() {
    var t3 = arguments.length &gt; 0 &amp;&amp; void 0 !== arguments[0] ? arguments[0] : 0, e2 = arguments.length &gt; 1 &amp;&amp; void 0 !== arguments[1] ? arguments[1] : 0, i2 = arguments.length &gt; 2 &amp;&amp; void 0 !== arguments[2] ? arguments[2] : 0, a2 = arguments.length &gt; 3 &amp;&amp; void 0 !== arguments[3] ? arguments[3] : 0, s2 = arguments.length &gt; 4 &amp;&amp; void 0 !== arguments[4] ? arguments[4] : 0, r2 = arguments.length &gt; 5 &amp;&amp; void 0 !== arguments[5] ? arguments[5] : &quot;#fefefe&quot;, n2 = arguments.length &gt; 6 &amp;&amp; void 0 !== arguments[6] ? arguments[6] : 1, o2 = arguments.length &gt; 7 &amp;&amp; void 0 !== arguments[7] ? arguments[7] : null, l2 = arguments.length &gt; 8 &amp;&amp; void 0 !== arguments[8] ? arguments[8] : null, h2 = arguments.length &gt; 9 &amp;&amp; void 0 !== arguments[9] ? arguments[9] : 0, c2 = this.w.globals.dom.Paper.rect();
    return c2.attr({ x: t3, y: e2, width: i2 &gt; 0 ? i2 : 0, height: a2 &gt; 0 ? a2 : 0, rx: s2, ry: s2, opacity: n2, &quot;stroke-width&quot;: null !== o2 ? o2 : 0, stroke: null !== l2 ? l2 : &quot;none&quot;, &quot;stroke-dasharray&quot;: h2 }), c2.node.setAttribute(&quot;fill&quot;, r2), c2;
  } }, { key: &quot;drawPolygon&quot;, value: function(t3) {
    var e2 = arguments.length &gt; 1 &amp;&amp; void 0 !== arguments[1] ? arguments[1] : &quot;#e1e1e1&quot;, i2 = arguments.length &gt; 2 &amp;&amp; void 0 !== arguments[2] ? arguments[2] : 1, a2 = arguments.length &gt; 3 &amp;&amp; void 0 !== arguments[3] ? arguments[3] : &quot;none&quot;;
    return this.w.globals.dom.Paper.polygon(t3).attr({ fill: a2, stroke: e2, &quot;stroke-width&quot;: i2 });
  } }, { key: &quot;drawCircle&quot;, value: function(t3) {
    var e2 = arguments.length &gt; 1 &amp;&amp; void 0 !== arguments[1] ? arguments[1] : null;
    t3 &lt; 0 &amp;&amp; (t3 = 0);
    var i2 = this.w.globals.dom.Paper.circle(2 * t3);
    return null !== e2 &amp;&amp; i2.attr(e2), i2;
  } }, { key: &quot;drawPath&quot;, value: function(t3) {
    var e2 = t3.d, i2 = void 0 === e2 ? &quot;&quot; : e2, a2 = t3.stroke, s2 = void 0 === a2 ? &quot;#a8a8a8&quot; : a2, r2 = t3.strokeWidth, n2 = void 0 === r2 ? 1 : r2, o2 = t3.fill, l2 = t3.fillOpacity, h2 = void 0 === l2 ? 1 : l2, c2 = t3.strokeOpacity, d2 = void 0 === c2 ? 1 : c2, u2 = t3.classes, g2 = t3.strokeLinecap, p2 = void 0 === g2 ? null : g2, f2 = t3.strokeDashArray, x2 = void 0 === f2 ? 0 : f2, b2 = this.w;
    return null === p2 &amp;&amp; (p2 = b2.config.stroke.lineCap), (i2.indexOf(&quot;undefined&quot;) &gt; -1 || i2.indexOf(&quot;NaN&quot;) &gt; -1) &amp;&amp; (i2 = &quot;M 0 &quot;.concat(b2.globals.gridHeight)), b2.globals.dom.Paper.path(i2).attr({ fill: o2, &quot;fill-opacity&quot;: h2, stroke: s2, &quot;stroke-opacity&quot;: d2, &quot;stroke-linecap&quot;: p2, &quot;stroke-width&quot;: n2, &quot;stroke-dasharray&quot;: x2, class: u2 });
  } }, { key: &quot;group&quot;, value: function() {
    var t3 = arguments.length &gt; 0 &amp;&amp; void 0 !== arguments[0] ? arguments[0] : null, e2 = this.w.globals.dom.Paper.group();
    return null !== t3 &amp;&amp; e2.attr(t3), e2;
  } }, { key: &quot;move&quot;, value: function(t3, e2) {
    var i2 = [&quot;M&quot;, t3, e2].join(&quot; &quot;);
    return i2;
  } }, { key: &quot;line&quot;, value: function(t3, e2) {
    var i2 = arguments.length &gt; 2 &amp;&amp; void 0 !== arguments[2] ? arguments[2] : null, a2 = null;
    return null === i2 ? a2 = [&quot; L&quot;, t3, e2].join(&quot; &quot;) : &quot;H&quot; === i2 ? a2 = [&quot; H&quot;, t3].join(&quot; &quot;) : &quot;V&quot; === i2 &amp;&amp; (a2 = [&quot; V&quot;, e2].join(&quot; &quot;)), a2;
  } }, { key: &quot;curve&quot;, value: function(t3, e2, i2, a2, s2, r2) {
    var n2 = [&quot;C&quot;, t3, e2, i2, a2, s2, r2].join(&quot; &quot;);
    return n2;
  } }, { key: &quot;quadraticCurve&quot;, value: function(t3, e2, i2, a2) {
    return [&quot;Q&quot;, t3, e2, i2, a2].join(&quot; &quot;);
  } }, { key: &quot;arc&quot;, value: function(t3, e2, i2, a2, s2, r2, n2) {
    var o2 = &quot;A&quot;;
    arguments.length &gt; 7 &amp;&amp; void 0 !== arguments[7] &amp;&amp; arguments[7] &amp;&amp; (o2 = &quot;a&quot;);
    var l2 = [o2, t3, e2, i2, a2, s2, r2, n2].join(&quot; &quot;);
    return l2;
  } }, { key: &quot;renderPaths&quot;, value: function(t3) {
    var e2, i2 = t3.j, a2 = t3.realIndex, s2 = t3.pathFrom, r2 = t3.pathTo, n2 = t3.stroke, o2 = t3.strokeWidth, l2 = t3.strokeLinecap, h2 = t3.fill, c2 = t3.animationDelay, d2 = t3.initialSpeed, g2 = t3.dataChangeSpeed, p2 = t3.className, f2 = t3.chartType, x2 = t3.shouldClipToGrid, b2 = void 0 === x2 || x2, m2 = t3.bindEventsOnPaths, v2 = void 0 === m2 || m2, w2 = t3.drawShadow, k2 = void 0 === w2 || w2, A2 = this.w, C2 = new Li(this.ctx), S2 = new y(this.ctx), L2 = this.w.config.chart.animations.enabled, M2 = L2 &amp;&amp; this.w.config.chart.animations.dynamicAnimation.enabled, P2 = !!(L2 &amp;&amp; !A2.globals.resized || M2 &amp;&amp; A2.globals.dataChanged &amp;&amp; A2.globals.shouldAnimate);
    P2 ? e2 = s2 : (e2 = r2, A2.globals.animationEnded = true);
    var I2 = A2.config.stroke.dashArray, T2 = 0;
    T2 = Array.isArray(I2) ? I2[a2] : A2.config.stroke.dashArray;
    var z2 = this.drawPath({ d: e2, stroke: n2, strokeWidth: o2, fill: h2, fillOpacity: 1, classes: p2, strokeLinecap: l2, strokeDashArray: T2 });
    z2.attr(&quot;index&quot;, a2), b2 &amp;&amp; (&quot;bar&quot; === f2 &amp;&amp; !A2.globals.isHorizontal || A2.globals.comboCharts ? z2.attr({ &quot;clip-path&quot;: &quot;url(#gridRectBarMask&quot;.concat(A2.globals.cuid, &quot;)&quot;) }) : z2.attr({ &quot;clip-path&quot;: &quot;url(#gridRectMask&quot;.concat(A2.globals.cuid, &quot;)&quot;) })), A2.config.chart.dropShadow.enabled &amp;&amp; k2 &amp;&amp; C2.dropShadow(z2, A2.config.chart.dropShadow, a2), v2 &amp;&amp; (z2.node.addEventListener(&quot;mouseenter&quot;, this.pathMouseEnter.bind(this, z2)), z2.node.addEventListener(&quot;mouseleave&quot;, this.pathMouseLeave.bind(this, z2)), z2.node.addEventListener(&quot;mousedown&quot;, this.pathMouseDown.bind(this, z2))), z2.attr({ pathTo: r2, pathFrom: s2 });
    var X2 = { el: z2, j: i2, realIndex: a2, pathFrom: s2, pathTo: r2, fill: h2, strokeWidth: o2, delay: c2 };
    return !L2 || A2.globals.resized || A2.globals.dataChanged ? !A2.globals.resized &amp;&amp; A2.globals.dataChanged || S2.showDelayedElements() : S2.animatePathsGradually(u(u({}, X2), {}, { speed: d2 })), A2.globals.dataChanged &amp;&amp; M2 &amp;&amp; P2 &amp;&amp; S2.animatePathsGradually(u(u({}, X2), {}, { speed: g2 })), z2;
  } }, { key: &quot;drawPattern&quot;, value: function(t3, e2, i2) {
    var a2 = arguments.length &gt; 3 &amp;&amp; void 0 !== arguments[3] ? arguments[3] : &quot;#a8a8a8&quot;, s2 = arguments.length &gt; 4 &amp;&amp; void 0 !== arguments[4] ? arguments[4] : 0;
    return this.w.globals.dom.Paper.pattern(e2, i2, function(r2) {
      &quot;horizontalLines&quot; === t3 ? r2.line(0, 0, i2, 0).stroke({ color: a2, width: s2 + 1 }) : &quot;verticalLines&quot; === t3 ? r2.line(0, 0, 0, e2).stroke({ color: a2, width: s2 + 1 }) : &quot;slantedLines&quot; === t3 ? r2.line(0, 0, e2, i2).stroke({ color: a2, width: s2 }) : &quot;squares&quot; === t3 ? r2.rect(e2, i2).fill(&quot;none&quot;).stroke({ color: a2, width: s2 }) : &quot;circles&quot; === t3 &amp;&amp; r2.circle(e2).fill(&quot;none&quot;).stroke({ color: a2, width: s2 });
    });
  } }, { key: &quot;drawGradient&quot;, value: function(t3, e2, i2, a2, s2) {
    var r2, n2 = arguments.length &gt; 5 &amp;&amp; void 0 !== arguments[5] ? arguments[5] : null, o2 = arguments.length &gt; 6 &amp;&amp; void 0 !== arguments[6] ? arguments[6] : null, l2 = arguments.length &gt; 7 &amp;&amp; void 0 !== arguments[7] ? arguments[7] : [], h2 = arguments.length &gt; 8 &amp;&amp; void 0 !== arguments[8] ? arguments[8] : 0, c2 = this.w;
    e2.length &lt; 9 &amp;&amp; 0 === e2.indexOf(&quot;#&quot;) &amp;&amp; (e2 = v.hexToRgba(e2, a2)), i2.length &lt; 9 &amp;&amp; 0 === i2.indexOf(&quot;#&quot;) &amp;&amp; (i2 = v.hexToRgba(i2, s2));
    var d2 = 0, u2 = 1, g2 = 1, p2 = null;
    null !== o2 &amp;&amp; (d2 = void 0 !== o2[0] ? o2[0] / 100 : 0, u2 = void 0 !== o2[1] ? o2[1] / 100 : 1, g2 = void 0 !== o2[2] ? o2[2] / 100 : 1, p2 = void 0 !== o2[3] ? o2[3] / 100 : null);
    var f2 = !(&quot;donut&quot; !== c2.config.chart.type &amp;&amp; &quot;pie&quot; !== c2.config.chart.type &amp;&amp; &quot;polarArea&quot; !== c2.config.chart.type &amp;&amp; &quot;bubble&quot; !== c2.config.chart.type);
    if (r2 = l2 &amp;&amp; 0 !== l2.length ? c2.globals.dom.Paper.gradient(f2 ? &quot;radial&quot; : &quot;linear&quot;, function(t4) {
      (Array.isArray(l2[h2]) ? l2[h2] : l2).forEach(function(e3) {
        t4.stop(e3.offset / 100, e3.color, e3.opacity);
      });
    }) : c2.globals.dom.Paper.gradient(f2 ? &quot;radial&quot; : &quot;linear&quot;, function(t4) {
      t4.stop(d2, e2, a2), t4.stop(u2, i2, s2), t4.stop(g2, i2, s2), null !== p2 &amp;&amp; t4.stop(p2, e2, a2);
    }), f2) {
      var x2 = c2.globals.gridWidth / 2, b2 = c2.globals.gridHeight / 2;
      &quot;bubble&quot; !== c2.config.chart.type ? r2.attr({ gradientUnits: &quot;userSpaceOnUse&quot;, cx: x2, cy: b2, r: n2 }) : r2.attr({ cx: 0.5, cy: 0.5, r: 0.8, fx: 0.2, fy: 0.2 });
    } else &quot;vertical&quot; === t3 ? r2.from(0, 0).to(0, 1) : &quot;diagonal&quot; === t3 ? r2.from(0, 0).to(1, 1) : &quot;horizontal&quot; === t3 ? r2.from(0, 1).to(1, 1) : &quot;diagonal2&quot; === t3 &amp;&amp; r2.from(1, 0).to(0, 1);
    return r2;
  } }, { key: &quot;getTextBasedOnMaxWidth&quot;, value: function(t3) {
    var e2 = t3.text, i2 = t3.maxWidth, a2 = t3.fontSize, s2 = t3.fontFamily, r2 = this.getTextRects(e2, a2, s2), n2 = r2.width / e2.length, o2 = Math.floor(i2 / n2);
    return i2 &lt; r2.width ? e2.slice(0, o2 - 3) + &quot;...&quot; : e2;
  } }, { key: &quot;drawText&quot;, value: function(t3) {
    var e2 = this, i2 = t3.x, a2 = t3.y, s2 = t3.text, r2 = t3.textAnchor, n2 = t3.fontSize, o2 = t3.fontFamily, l2 = t3.fontWeight, h2 = t3.foreColor, c2 = t3.opacity, d2 = t3.maxWidth, g2 = t3.cssClass, p2 = void 0 === g2 ? &quot;&quot; : g2, f2 = t3.isPlainText, x2 = void 0 === f2 || f2, b2 = t3.dominantBaseline, m2 = void 0 === b2 ? &quot;auto&quot; : b2, v2 = this.w;
    void 0 === s2 &amp;&amp; (s2 = &quot;&quot;);
    var y2 = s2;
    r2 || (r2 = &quot;start&quot;), h2 &amp;&amp; h2.length || (h2 = v2.config.chart.foreColor), o2 = o2 || v2.config.chart.fontFamily, l2 = l2 || &quot;regular&quot;;
    var w2, k2 = { maxWidth: d2, fontSize: n2 = n2 || &quot;11px&quot;, fontFamily: o2 };
    return Array.isArray(s2) ? w2 = v2.globals.dom.Paper.text(function(t4) {
      for (var i3 = 0; i3 &lt; s2.length; i3++) y2 = s2[i3], d2 &amp;&amp; (y2 = e2.getTextBasedOnMaxWidth(u({ text: s2[i3] }, k2))), 0 === i3 ? t4.tspan(y2) : t4.tspan(y2).newLine();
    }) : (d2 &amp;&amp; (y2 = this.getTextBasedOnMaxWidth(u({ text: s2 }, k2))), w2 = x2 ? v2.globals.dom.Paper.plain(s2) : v2.globals.dom.Paper.text(function(t4) {
      return t4.tspan(y2);
    })), w2.attr({ x: i2, y: a2, &quot;text-anchor&quot;: r2, &quot;dominant-baseline&quot;: m2, &quot;font-size&quot;: n2, &quot;font-family&quot;: o2, &quot;font-weight&quot;: l2, fill: h2, class: &quot;apexcharts-text &quot; + p2 }), w2.node.style.fontFamily = o2, w2.node.style.opacity = c2, w2;
  } }, { key: &quot;getMarkerPath&quot;, value: function(t3, e2, i2, a2) {
    var s2 = &quot;&quot;;
    switch (i2) {
      case &quot;cross&quot;:
        s2 = &quot;M &quot;.concat(t3 - (a2 /= 1.4), &quot; &quot;).concat(e2 - a2, &quot; L &quot;).concat(t3 + a2, &quot; &quot;).concat(e2 + a2, &quot;  M &quot;).concat(t3 - a2, &quot; &quot;).concat(e2 + a2, &quot; L &quot;).concat(t3 + a2, &quot; &quot;).concat(e2 - a2);
        break;
      case &quot;plus&quot;:
        s2 = &quot;M &quot;.concat(t3 - (a2 /= 1.12), &quot; &quot;).concat(e2, &quot; L &quot;).concat(t3 + a2, &quot; &quot;).concat(e2, &quot;  M &quot;).concat(t3, &quot; &quot;).concat(e2 - a2, &quot; L &quot;).concat(t3, &quot; &quot;).concat(e2 + a2);
        break;
      case &quot;star&quot;:
      case &quot;sparkle&quot;:
        var r2 = 5;
        a2 *= 1.15, &quot;sparkle&quot; === i2 &amp;&amp; (a2 /= 1.1, r2 = 4);
        for (var n2 = Math.PI / r2, o2 = 0; o2 &lt;= 2 * r2; o2++) {
          var l2 = o2 * n2, h2 = o2 % 2 == 0 ? a2 : a2 / 2;
          s2 += (0 === o2 ? &quot;M&quot; : &quot;L&quot;) + (t3 + h2 * Math.sin(l2)) + &quot;,&quot; + (e2 - h2 * Math.cos(l2));
        }
        s2 += &quot;Z&quot;;
        break;
      case &quot;triangle&quot;:
        s2 = &quot;M &quot;.concat(t3, &quot; &quot;).concat(e2 - a2, &quot; \n             L &quot;).concat(t3 + a2, &quot; &quot;).concat(e2 + a2, &quot; \n             L &quot;).concat(t3 - a2, &quot; &quot;).concat(e2 + a2, &quot; \n             Z&quot;);
        break;
      case &quot;square&quot;:
      case &quot;rect&quot;:
        s2 = &quot;M &quot;.concat(t3 - (a2 /= 1.125), &quot; &quot;).concat(e2 - a2, &quot; \n           L &quot;).concat(t3 + a2, &quot; &quot;).concat(e2 - a2, &quot; \n           L &quot;).concat(t3 + a2, &quot; &quot;).concat(e2 + a2, &quot; \n           L &quot;).concat(t3 - a2, &quot; &quot;).concat(e2 + a2, &quot; \n           Z&quot;);
        break;
      case &quot;diamond&quot;:
        a2 *= 1.05, s2 = &quot;M &quot;.concat(t3, &quot; &quot;).concat(e2 - a2, &quot; \n             L &quot;).concat(t3 + a2, &quot; &quot;).concat(e2, &quot; \n             L &quot;).concat(t3, &quot; &quot;).concat(e2 + a2, &quot; \n             L &quot;).concat(t3 - a2, &quot; &quot;).concat(e2, &quot; \n            Z&quot;);
        break;
      case &quot;line&quot;:
        s2 = &quot;M &quot;.concat(t3 - (a2 /= 1.1), &quot; &quot;).concat(e2, &quot; \n           L &quot;).concat(t3 + a2, &quot; &quot;).concat(e2);
        break;
      default:
        a2 *= 2, s2 = &quot;M &quot;.concat(t3, &quot;, &quot;).concat(e2, &quot; \n           m -&quot;).concat(a2 / 2, &quot;, 0 \n           a &quot;).concat(a2 / 2, &quot;,&quot;).concat(a2 / 2, &quot; 0 1,0 &quot;).concat(a2, &quot;,0 \n           a &quot;).concat(a2 / 2, &quot;,&quot;).concat(a2 / 2, &quot; 0 1,0 -&quot;).concat(a2, &quot;,0&quot;);
    }
    return s2;
  } }, { key: &quot;drawMarkerShape&quot;, value: function(t3, e2, i2, a2, s2) {
    var r2 = this.drawPath({ d: this.getMarkerPath(t3, e2, i2, a2, s2), stroke: s2.pointStrokeColor, strokeDashArray: s2.pointStrokeDashArray, strokeWidth: s2.pointStrokeWidth, fill: s2.pointFillColor, fillOpacity: s2.pointFillOpacity, strokeOpacity: s2.pointStrokeOpacity });
    return r2.attr({ cx: t3, cy: e2, shape: s2.shape, class: s2.class ? s2.class : &quot;&quot; }), r2;
  } }, { key: &quot;drawMarker&quot;, value: function(t3, e2, i2) {
    t3 = t3 || 0;
    var a2 = i2.pSize || 0;
    return v.isNumber(e2) || (a2 = 0, e2 = 0), this.drawMarkerShape(t3, e2, null == i2 ? void 0 : i2.shape, a2, u(u({}, i2), &quot;line&quot; === i2.shape || &quot;plus&quot; === i2.shape || &quot;cross&quot; === i2.shape ? { pointStrokeColor: i2.pointFillColor, pointStrokeOpacity: i2.pointFillOpacity } : {}));
  } }, { key: &quot;pathMouseEnter&quot;, value: function(t3, e2) {
    var i2 = this.w, a2 = new Li(this.ctx), s2 = parseInt(t3.node.getAttribute(&quot;index&quot;), 10), r2 = parseInt(t3.node.getAttribute(&quot;j&quot;), 10);
    if (&quot;function&quot; == typeof i2.config.chart.events.dataPointMouseEnter &amp;&amp; i2.config.chart.events.dataPointMouseEnter(e2, this.ctx, { seriesIndex: s2, dataPointIndex: r2, w: i2 }), this.ctx.events.fireEvent(&quot;dataPointMouseEnter&quot;, [e2, this.ctx, { seriesIndex: s2, dataPointIndex: r2, w: i2 }]), (&quot;none&quot; === i2.config.states.active.filter.type || &quot;true&quot; !== t3.node.getAttribute(&quot;selected&quot;)) &amp;&amp; &quot;none&quot; !== i2.config.states.hover.filter.type &amp;&amp; !i2.globals.isTouchDevice) {
      var n2 = i2.config.states.hover.filter;
      a2.applyFilter(t3, s2, n2.type);
    }
  } }, { key: &quot;pathMouseLeave&quot;, value: function(t3, e2) {
    var i2 = this.w, a2 = new Li(this.ctx), s2 = parseInt(t3.node.getAttribute(&quot;index&quot;), 10), r2 = parseInt(t3.node.getAttribute(&quot;j&quot;), 10);
    &quot;function&quot; == typeof i2.config.chart.events.dataPointMouseLeave &amp;&amp; i2.config.chart.events.dataPointMouseLeave(e2, this.ctx, { seriesIndex: s2, dataPointIndex: r2, w: i2 }), this.ctx.events.fireEvent(&quot;dataPointMouseLeave&quot;, [e2, this.ctx, { seriesIndex: s2, dataPointIndex: r2, w: i2 }]), &quot;none&quot; !== i2.config.states.active.filter.type &amp;&amp; &quot;true&quot; === t3.node.getAttribute(&quot;selected&quot;) || &quot;none&quot; !== i2.config.states.hover.filter.type &amp;&amp; a2.getDefaultFilter(t3, s2);
  } }, { key: &quot;pathMouseDown&quot;, value: function(t3, e2) {
    var i2 = this.w, a2 = new Li(this.ctx), s2 = parseInt(t3.node.getAttribute(&quot;index&quot;), 10), r2 = parseInt(t3.node.getAttribute(&quot;j&quot;), 10), n2 = &quot;false&quot;;
    if (&quot;true&quot; === t3.node.getAttribute(&quot;selected&quot;)) {
      if (t3.node.setAttribute(&quot;selected&quot;, &quot;false&quot;), i2.globals.selectedDataPoints[s2].indexOf(r2) &gt; -1) {
        var o2 = i2.globals.selectedDataPoints[s2].indexOf(r2);
        i2.globals.selectedDataPoints[s2].splice(o2, 1);
      }
    } else {
      if (!i2.config.states.active.allowMultipleDataPointsSelection &amp;&amp; i2.globals.selectedDataPoints.length &gt; 0) {
        i2.globals.selectedDataPoints = [];
        var l2 = i2.globals.dom.Paper.find(&quot;.apexcharts-series path:not(.apexcharts-decoration-element)&quot;), h2 = i2.globals.dom.Paper.find(&quot;.apexcharts-series circle:not(.apexcharts-decoration-element), .apexcharts-series rect:not(.apexcharts-decoration-element)&quot;), c2 = function(t4) {
          Array.prototype.forEach.call(t4, function(t5) {
            t5.node.setAttribute(&quot;selected&quot;, &quot;false&quot;), a2.getDefaultFilter(t5, s2);
          });
        };
        c2(l2), c2(h2);
      }
      t3.node.setAttribute(&quot;selected&quot;, &quot;true&quot;), n2 = &quot;true&quot;, void 0 === i2.globals.selectedDataPoints[s2] &amp;&amp; (i2.globals.selectedDataPoints[s2] = []), i2.globals.selectedDataPoints[s2].push(r2);
    }
    if (&quot;true&quot; === n2) {
      var d2 = i2.config.states.active.filter;
      if (&quot;none&quot; !== d2) a2.applyFilter(t3, s2, d2.type);
      else if (&quot;none&quot; !== i2.config.states.hover.filter &amp;&amp; !i2.globals.isTouchDevice) {
        var u2 = i2.config.states.hover.filter;
        a2.applyFilter(t3, s2, u2.type);
      }
    } else if (&quot;none&quot; !== i2.config.states.active.filter.type) if (&quot;none&quot; === i2.config.states.hover.filter.type || i2.globals.isTouchDevice) a2.getDefaultFilter(t3, s2);
    else {
      u2 = i2.config.states.hover.filter;
      a2.applyFilter(t3, s2, u2.type);
    }
    &quot;function&quot; == typeof i2.config.chart.events.dataPointSelection &amp;&amp; i2.config.chart.events.dataPointSelection(e2, this.ctx, { selectedDataPoints: i2.globals.selectedDataPoints, seriesIndex: s2, dataPointIndex: r2, w: i2 }), e2 &amp;&amp; this.ctx.events.fireEvent(&quot;dataPointSelection&quot;, [e2, this.ctx, { selectedDataPoints: i2.globals.selectedDataPoints, seriesIndex: s2, dataPointIndex: r2, w: i2 }]);
  } }, { key: &quot;rotateAroundCenter&quot;, value: function(t3) {
    var e2 = {};
    return t3 &amp;&amp; &quot;function&quot; == typeof t3.getBBox &amp;&amp; (e2 = t3.getBBox()), { x: e2.x + e2.width / 2, y: e2.y + e2.height / 2 };
  } }, { key: &quot;getTextRects&quot;, value: function(t3, e2, i2, a2) {
    var s2 = !(arguments.length &gt; 4 &amp;&amp; void 0 !== arguments[4]) || arguments[4], r2 = this.w, n2 = this.drawText({ x: -200, y: -200, text: t3, textAnchor: &quot;start&quot;, fontSize: e2, fontFamily: i2, foreColor: &quot;#fff&quot;, opacity: 0 });
    a2 &amp;&amp; n2.attr(&quot;transform&quot;, a2), r2.globals.dom.Paper.add(n2);
    var o2 = n2.bbox();
    return s2 || (o2 = n2.node.getBoundingClientRect()), n2.remove(), { width: o2.width, height: o2.height };
  } }, { key: &quot;placeTextWithEllipsis&quot;, value: function(t3, e2, i2) {
    if (&quot;function&quot; == typeof t3.getComputedTextLength &amp;&amp; (t3.textContent = e2, e2.length &gt; 0 &amp;&amp; t3.getComputedTextLength() &gt;= i2 / 1.1)) {
      for (var a2 = e2.length - 3; a2 &gt; 0; a2 -= 3) if (t3.getSubStringLength(0, a2) &lt;= i2 / 1.1) return void (t3.textContent = e2.substring(0, a2) + &quot;...&quot;);
      t3.textContent = &quot;.&quot;;
    }
  } }], [{ key: &quot;setAttrs&quot;, value: function(t3, e2) {
    for (var i2 in e2) e2.hasOwnProperty(i2) &amp;&amp; t3.setAttribute(i2, e2[i2]);
  } }]), t2;
}();
var Pi = function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w;
  }
  return s(t2, [{ key: &quot;getStackedSeriesTotals&quot;, value: function() {
    var t3 = arguments.length &gt; 0 &amp;&amp; void 0 !== arguments[0] ? arguments[0] : [], e2 = this.w, i2 = [];
    if (0 === e2.globals.series.length) return i2;
    for (var a2 = 0; a2 &lt; e2.globals.series[e2.globals.maxValsInArrayIndex].length; a2++) {
      for (var s2 = 0, r2 = 0; r2 &lt; e2.globals.series.length; r2++) void 0 !== e2.globals.series[r2][a2] &amp;&amp; -1 === t3.indexOf(r2) &amp;&amp; (s2 += e2.globals.series[r2][a2]);
      i2.push(s2);
    }
    return i2;
  } }, { key: &quot;getSeriesTotalByIndex&quot;, value: function() {
    var t3 = arguments.length &gt; 0 &amp;&amp; void 0 !== arguments[0] ? arguments[0] : null;
    return null === t3 ? this.w.config.series.reduce(function(t4, e2) {
      return t4 + e2;
    }, 0) : this.w.globals.series[t3].reduce(function(t4, e2) {
      return t4 + e2;
    }, 0);
  } }, { key: &quot;getStackedSeriesTotalsByGroups&quot;, value: function() {
    var t3 = this, e2 = this.w, i2 = [];
    return e2.globals.seriesGroups.forEach(function(a2) {
      var s2 = [];
      e2.config.series.forEach(function(t4, i3) {
        a2.indexOf(e2.globals.seriesNames[i3]) &gt; -1 &amp;&amp; s2.push(i3);
      });
      var r2 = e2.globals.series.map(function(t4, e3) {
        return -1 === s2.indexOf(e3) ? e3 : -1;
      }).filter(function(t4) {
        return -1 !== t4;
      });
      i2.push(t3.getStackedSeriesTotals(r2));
    }), i2;
  } }, { key: &quot;setSeriesYAxisMappings&quot;, value: function() {
    var t3 = this.w.globals, e2 = this.w.config, i2 = [], a2 = [], s2 = [], r2 = t3.series.length &gt; e2.yaxis.length || e2.yaxis.some(function(t4) {
      return Array.isArray(t4.seriesName);
    });
    e2.series.forEach(function(t4, e3) {
      s2.push(e3), a2.push(null);
    }), e2.yaxis.forEach(function(t4, e3) {
      i2[e3] = [];
    });
    var n2 = [];
    e2.yaxis.forEach(function(t4, a3) {
      var o3 = false;
      if (t4.seriesName) {
        var l3 = [];
        Array.isArray(t4.seriesName) ? l3 = t4.seriesName : l3.push(t4.seriesName), l3.forEach(function(t5) {
          e2.series.forEach(function(e3, n3) {
            if (e3.name === t5) {
              var l4 = n3;
              a3 === n3 || r2 ? !r2 || s2.indexOf(n3) &gt; -1 ? i2[a3].push([a3, n3]) : console.warn(&quot;Series &#x27;&quot; + e3.name + &quot;&#x27; referenced more than once in what looks like the new style. That is, when using either seriesName: [], or when there are more series than yaxes.&quot;) : (i2[n3].push([n3, a3]), l4 = a3), o3 = true, -1 !== (l4 = s2.indexOf(l4)) &amp;&amp; s2.splice(l4, 1);
            }
          });
        });
      }
      o3 || n2.push(a3);
    }), i2 = i2.map(function(t4, e3) {
      var i3 = [];
      return t4.forEach(function(t5) {
        a2[t5[1]] = t5[0], i3.push(t5[1]);
      }), i3;
    });
    for (var o2 = e2.yaxis.length - 1, l2 = 0; l2 &lt; n2.length &amp;&amp; (o2 = n2[l2], i2[o2] = [], s2); l2++) {
      var h2 = s2[0];
      s2.shift(), i2[o2].push(h2), a2[h2] = o2;
    }
    s2.forEach(function(t4) {
      i2[o2].push(t4), a2[t4] = o2;
    }), t3.seriesYAxisMap = i2.map(function(t4) {
      return t4;
    }), t3.seriesYAxisReverseMap = a2.map(function(t4) {
      return t4;
    }), t3.seriesYAxisMap.forEach(function(t4, i3) {
      t4.forEach(function(t5) {
        e2.series[t5] &amp;&amp; void 0 === e2.series[t5].group &amp;&amp; (e2.series[t5].group = &quot;apexcharts-axis-&quot;.concat(i3.toString()));
      });
    });
  } }, { key: &quot;isSeriesNull&quot;, value: function() {
    var t3 = arguments.length &gt; 0 &amp;&amp; void 0 !== arguments[0] ? arguments[0] : null;
    return 0 === (null === t3 ? this.w.config.series.filter(function(t4) {
      return null !== t4;
    }) : this.w.config.series[t3].data.filter(function(t4) {
      return null !== t4;
    })).length;
  } }, { key: &quot;seriesHaveSameValues&quot;, value: function(t3) {
    return this.w.globals.series[t3].every(function(t4, e2, i2) {
      return t4 === i2[0];
    });
  } }, { key: &quot;getCategoryLabels&quot;, value: function(t3) {
    var e2 = this.w, i2 = t3.slice();
    return e2.config.xaxis.convertedCatToNumeric &amp;&amp; (i2 = t3.map(function(t4, i3) {
      return e2.config.xaxis.labels.formatter(t4 - e2.globals.minX + 1);
    })), i2;
  } }, { key: &quot;getLargestSeries&quot;, value: function() {
    var t3 = this.w;
    t3.globals.maxValsInArrayIndex = t3.globals.series.map(function(t4) {
      return t4.length;
    }).indexOf(Math.max.apply(Math, t3.globals.series.map(function(t4) {
      return t4.length;
    })));
  } }, { key: &quot;getLargestMarkerSize&quot;, value: function() {
    var t3 = this.w, e2 = 0;
    return t3.globals.markers.size.forEach(function(t4) {
      e2 = Math.max(e2, t4);
    }), t3.config.markers.discrete &amp;&amp; t3.config.markers.discrete.length &amp;&amp; t3.config.markers.discrete.forEach(function(t4) {
      e2 = Math.max(e2, t4.size);
    }), e2 &gt; 0 &amp;&amp; (t3.config.markers.hover.size &gt; 0 ? e2 = t3.config.markers.hover.size : e2 += t3.config.markers.hover.sizeOffset), t3.globals.markers.largestSize = e2, e2;
  } }, { key: &quot;getSeriesTotals&quot;, value: function() {
    var t3 = this.w;
    t3.globals.seriesTotals = t3.globals.series.map(function(t4, e2) {
      var i2 = 0;
      if (Array.isArray(t4)) for (var a2 = 0; a2 &lt; t4.length; a2++) i2 += t4[a2];
      else i2 += t4;
      return i2;
    });
  } }, { key: &quot;getSeriesTotalsXRange&quot;, value: function(t3, e2) {
    var i2 = this.w;
    return i2.globals.series.map(function(a2, s2) {
      for (var r2 = 0, n2 = 0; n2 &lt; a2.length; n2++) i2.globals.seriesX[s2][n2] &gt; t3 &amp;&amp; i2.globals.seriesX[s2][n2] &lt; e2 &amp;&amp; (r2 += a2[n2]);
      return r2;
    });
  } }, { key: &quot;getPercentSeries&quot;, value: function() {
    var t3 = this.w;
    t3.globals.seriesPercent = t3.globals.series.map(function(e2, i2) {
      var a2 = [];
      if (Array.isArray(e2)) for (var s2 = 0; s2 &lt; e2.length; s2++) {
        var r2 = t3.globals.stackedSeriesTotals[s2], n2 = 0;
        r2 &amp;&amp; (n2 = 100 * e2[s2] / r2), a2.push(n2);
      }
      else {
        var o2 = 100 * e2 / t3.globals.seriesTotals.reduce(function(t4, e3) {
          return t4 + e3;
        }, 0);
        a2.push(o2);
      }
      return a2;
    });
  } }, { key: &quot;getCalculatedRatios&quot;, value: function() {
    var t3, e2, i2, a2 = this, s2 = this.w, r2 = s2.globals, n2 = [], o2 = 0, l2 = [], h2 = 0.1, c2 = 0;
    if (r2.yRange = [], r2.isMultipleYAxis) for (var d2 = 0; d2 &lt; r2.minYArr.length; d2++) r2.yRange.push(Math.abs(r2.minYArr[d2] - r2.maxYArr[d2])), l2.push(0);
    else r2.yRange.push(Math.abs(r2.minY - r2.maxY));
    r2.xRange = Math.abs(r2.maxX - r2.minX), r2.zRange = Math.abs(r2.maxZ - r2.minZ);
    for (var u2 = 0; u2 &lt; r2.yRange.length; u2++) n2.push(r2.yRange[u2] / r2.gridHeight);
    if (e2 = r2.xRange / r2.gridWidth, t3 = r2.yRange / r2.gridWidth, i2 = r2.xRange / r2.gridHeight, (o2 = r2.zRange / r2.gridHeight * 16) || (o2 = 1), r2.minY !== Number.MIN_VALUE &amp;&amp; 0 !== Math.abs(r2.minY) &amp;&amp; (r2.hasNegs = true), s2.globals.seriesYAxisReverseMap.length &gt; 0) {
      var g2 = function(t4, e3) {
        var i3 = s2.config.yaxis[s2.globals.seriesYAxisReverseMap[e3]], r3 = t4 &lt; 0 ? -1 : 1;
        return t4 = Math.abs(t4), i3.logarithmic &amp;&amp; (t4 = a2.getBaseLog(i3.logBase, t4)), -r3 * t4 / n2[e3];
      };
      if (r2.isMultipleYAxis) {
        l2 = [];
        for (var p2 = 0; p2 &lt; n2.length; p2++) l2.push(g2(r2.minYArr[p2], p2));
      } else (l2 = []).push(g2(r2.minY, 0)), r2.minY !== Number.MIN_VALUE &amp;&amp; 0 !== Math.abs(r2.minY) &amp;&amp; (h2 = -r2.minY / t3, c2 = r2.minX / e2);
    } else (l2 = []).push(0), h2 = 0, c2 = 0;
    return { yRatio: n2, invertedYRatio: t3, zRatio: o2, xRatio: e2, invertedXRatio: i2, baseLineInvertedY: h2, baseLineY: l2, baseLineX: c2 };
  } }, { key: &quot;getLogSeries&quot;, value: function(t3) {
    var e2 = this, i2 = this.w;
    return i2.globals.seriesLog = t3.map(function(t4, a2) {
      var s2 = i2.globals.seriesYAxisReverseMap[a2];
      return i2.config.yaxis[s2] &amp;&amp; i2.config.yaxis[s2].logarithmic ? t4.map(function(t5) {
        return null === t5 ? null : e2.getLogVal(i2.config.yaxis[s2].logBase, t5, a2);
      }) : t4;
    }), i2.globals.invalidLogScale ? t3 : i2.globals.seriesLog;
  } }, { key: &quot;getLogValAtSeriesIndex&quot;, value: function(t3, e2) {
    if (null === t3) return null;
    var i2 = this.w, a2 = i2.globals.seriesYAxisReverseMap[e2];
    return i2.config.yaxis[a2] &amp;&amp; i2.config.yaxis[a2].logarithmic ? this.getLogVal(i2.config.yaxis[a2].logBase, t3, e2) : t3;
  } }, { key: &quot;getBaseLog&quot;, value: function(t3, e2) {
    return Math.log(e2) / Math.log(t3);
  } }, { key: &quot;getLogVal&quot;, value: function(t3, e2, i2) {
    if (e2 &lt;= 0) return 0;
    var a2 = this.w, s2 = 0 === a2.globals.minYArr[i2] ? -1 : this.getBaseLog(t3, a2.globals.minYArr[i2]), r2 = (0 === a2.globals.maxYArr[i2] ? 0 : this.getBaseLog(t3, a2.globals.maxYArr[i2])) - s2;
    return e2 &lt; 1 ? e2 / r2 : (this.getBaseLog(t3, e2) - s2) / r2;
  } }, { key: &quot;getLogYRatios&quot;, value: function(t3) {
    var e2 = this, i2 = this.w, a2 = this.w.globals;
    return a2.yLogRatio = t3.slice(), a2.logYRange = a2.yRange.map(function(t4, s2) {
      var r2 = i2.globals.seriesYAxisReverseMap[s2];
      if (i2.config.yaxis[r2] &amp;&amp; e2.w.config.yaxis[r2].logarithmic) {
        var n2, o2 = -Number.MAX_VALUE, l2 = Number.MIN_VALUE;
        return a2.seriesLog.forEach(function(t5, e3) {
          t5.forEach(function(t6) {
            i2.config.yaxis[e3] &amp;&amp; i2.config.yaxis[e3].logarithmic &amp;&amp; (o2 = Math.max(t6, o2), l2 = Math.min(t6, l2));
          });
        }), n2 = Math.pow(a2.yRange[s2], Math.abs(l2 - o2) / a2.yRange[s2]), a2.yLogRatio[s2] = n2 / a2.gridHeight, n2;
      }
    }), a2.invalidLogScale ? t3.slice() : a2.yLogRatio;
  } }, { key: &quot;drawSeriesByGroup&quot;, value: function(t3, e2, i2, a2) {
    var s2 = this.w, r2 = [];
    return t3.series.length &gt; 0 &amp;&amp; e2.forEach(function(e3) {
      var n2 = [], o2 = [];
      t3.i.forEach(function(i3, a3) {
        s2.config.series[i3].group === e3 &amp;&amp; (n2.push(t3.series[a3]), o2.push(i3));
      }), n2.length &gt; 0 &amp;&amp; r2.push(a2.draw(n2, i2, o2));
    }), r2;
  } }], [{ key: &quot;checkComboSeries&quot;, value: function(t3, e2) {
    var i2 = false, a2 = 0, s2 = 0;
    return void 0 === e2 &amp;&amp; (e2 = &quot;line&quot;), t3.length &amp;&amp; void 0 !== t3[0].type &amp;&amp; t3.forEach(function(t4) {
      &quot;bar&quot; !== t4.type &amp;&amp; &quot;column&quot; !== t4.type &amp;&amp; &quot;candlestick&quot; !== t4.type &amp;&amp; &quot;boxPlot&quot; !== t4.type || a2++, void 0 !== t4.type &amp;&amp; t4.type !== e2 &amp;&amp; s2++;
    }), s2 &gt; 0 &amp;&amp; (i2 = true), { comboBarCount: a2, comboCharts: i2 };
  } }, { key: &quot;extendArrayProps&quot;, value: function(t3, e2, i2) {
    var a2, s2, r2, n2, o2, l2;
    (null !== (a2 = e2) &amp;&amp; void 0 !== a2 &amp;&amp; a2.yaxis &amp;&amp; (e2 = t3.extendYAxis(e2, i2)), null !== (s2 = e2) &amp;&amp; void 0 !== s2 &amp;&amp; s2.annotations) &amp;&amp; (e2.annotations.yaxis &amp;&amp; (e2 = t3.extendYAxisAnnotations(e2)), null !== (r2 = e2) &amp;&amp; void 0 !== r2 &amp;&amp; null !== (n2 = r2.annotations) &amp;&amp; void 0 !== n2 &amp;&amp; n2.xaxis &amp;&amp; (e2 = t3.extendXAxisAnnotations(e2)), null !== (o2 = e2) &amp;&amp; void 0 !== o2 &amp;&amp; null !== (l2 = o2.annotations) &amp;&amp; void 0 !== l2 &amp;&amp; l2.points &amp;&amp; (e2 = t3.extendPointAnnotations(e2)));
    return e2;
  } }]), t2;
}();
var Ii = function() {
  function t2(e2) {
    i(this, t2), this.w = e2.w, this.annoCtx = e2;
  }
  return s(t2, [{ key: &quot;setOrientations&quot;, value: function(t3) {
    var e2 = arguments.length &gt; 1 &amp;&amp; void 0 !== arguments[1] ? arguments[1] : null, i2 = this.w;
    if (&quot;vertical&quot; === t3.label.orientation) {
      var a2 = null !== e2 ? e2 : 0, s2 = i2.globals.dom.baseEl.querySelector(&quot;.apexcharts-xaxis-annotations .apexcharts-xaxis-annotation-label[rel=&#x27;&quot;.concat(a2, &quot;&#x27;]&quot;));
      if (null !== s2) {
        var r2 = s2.getBoundingClientRect();
        s2.setAttribute(&quot;x&quot;, parseFloat(s2.getAttribute(&quot;x&quot;)) - r2.height + 4);
        var n2 = &quot;top&quot; === t3.label.position ? r2.width : -r2.width;
        s2.setAttribute(&quot;y&quot;, parseFloat(s2.getAttribute(&quot;y&quot;)) + n2);
        var o2 = this.annoCtx.graphics.rotateAroundCenter(s2), l2 = o2.x, h2 = o2.y;
        s2.setAttribute(&quot;transform&quot;, &quot;rotate(-90 &quot;.concat(l2, &quot; &quot;).concat(h2, &quot;)&quot;));
      }
    }
  } }, { key: &quot;addBackgroundToAnno&quot;, value: function(t3, e2) {
    var i2 = this.w;
    if (!t3 || !e2.label.text || !String(e2.label.text).trim()) return null;
    var a2 = i2.globals.dom.baseEl.querySelector(&quot;.apexcharts-grid&quot;).getBoundingClientRect(), s2 = t3.getBoundingClientRect(), r2 = e2.label.style.padding, n2 = r2.left, o2 = r2.right, l2 = r2.top, h2 = r2.bottom;
    if (&quot;vertical&quot; === e2.label.orientation) {
      var c2 = [n2, o2, l2, h2];
      l2 = c2[0], h2 = c2[1], n2 = c2[2], o2 = c2[3];
    }
    var d2 = s2.left - a2.left - n2, u2 = s2.top - a2.top - l2, g2 = this.annoCtx.graphics.drawRect(d2 - i2.globals.barPadForNumericAxis, u2, s2.width + n2 + o2, s2.height + l2 + h2, e2.label.borderRadius, e2.label.style.background, 1, e2.label.borderWidth, e2.label.borderColor, 0);
    return e2.id &amp;&amp; g2.node.classList.add(e2.id), g2;
  } }, { key: &quot;annotationsBackground&quot;, value: function() {
    var t3 = this, e2 = this.w, i2 = function(i3, a2, s2) {
      var r2 = e2.globals.dom.baseEl.querySelector(&quot;.apexcharts-&quot;.concat(s2, &quot;-annotations .apexcharts-&quot;).concat(s2, &quot;-annotation-label[rel=&#x27;&quot;).concat(a2, &quot;&#x27;]&quot;));
      if (r2) {
        var n2 = r2.parentNode, o2 = t3.addBackgroundToAnno(r2, i3);
        o2 &amp;&amp; (n2.insertBefore(o2.node, r2), i3.label.mouseEnter &amp;&amp; o2.node.addEventListener(&quot;mouseenter&quot;, i3.label.mouseEnter.bind(t3, i3)), i3.label.mouseLeave &amp;&amp; o2.node.addEventListener(&quot;mouseleave&quot;, i3.label.mouseLeave.bind(t3, i3)), i3.label.click &amp;&amp; o2.node.addEventListener(&quot;click&quot;, i3.label.click.bind(t3, i3)));
      }
    };
    e2.config.annotations.xaxis.forEach(function(t4, e3) {
      return i2(t4, e3, &quot;xaxis&quot;);
    }), e2.config.annotations.yaxis.forEach(function(t4, e3) {
      return i2(t4, e3, &quot;yaxis&quot;);
    }), e2.config.annotations.points.forEach(function(t4, e3) {
      return i2(t4, e3, &quot;point&quot;);
    });
  } }, { key: &quot;getY1Y2&quot;, value: function(t3, e2) {
    var i2, a2 = this.w, s2 = &quot;y1&quot; === t3 ? e2.y : e2.y2, r2 = false;
    if (this.annoCtx.invertAxis) {
      var n2 = a2.config.xaxis.convertedCatToNumeric ? a2.globals.categoryLabels : a2.globals.labels, o2 = n2.indexOf(s2), l2 = a2.globals.dom.baseEl.querySelector(&quot;.apexcharts-yaxis-texts-g text:nth-child(&quot;.concat(o2 + 1, &quot;)&quot;));
      i2 = l2 ? parseFloat(l2.getAttribute(&quot;y&quot;)) : (a2.globals.gridHeight / n2.length - 1) * (o2 + 1) - a2.globals.barHeight, void 0 !== e2.seriesIndex &amp;&amp; a2.globals.barHeight &amp;&amp; (i2 -= a2.globals.barHeight / 2 * (a2.globals.series.length - 1) - a2.globals.barHeight * e2.seriesIndex);
    } else {
      var h2, c2 = a2.globals.seriesYAxisMap[e2.yAxisIndex][0], d2 = a2.config.yaxis[e2.yAxisIndex].logarithmic ? new Pi(this.annoCtx.ctx).getLogVal(a2.config.yaxis[e2.yAxisIndex].logBase, s2, c2) / a2.globals.yLogRatio[c2] : (s2 - a2.globals.minYArr[c2]) / (a2.globals.yRange[c2] / a2.globals.gridHeight);
      i2 = a2.globals.gridHeight - Math.min(Math.max(d2, 0), a2.globals.gridHeight), r2 = d2 &gt; a2.globals.gridHeight || d2 &lt; 0, !e2.marker || void 0 !== e2.y &amp;&amp; null !== e2.y || (i2 = 0), null !== (h2 = a2.config.yaxis[e2.yAxisIndex]) &amp;&amp; void 0 !== h2 &amp;&amp; h2.reversed &amp;&amp; (i2 = d2);
    }
    return &quot;string&quot; == typeof s2 &amp;&amp; s2.includes(&quot;px&quot;) &amp;&amp; (i2 = parseFloat(s2)), { yP: i2, clipped: r2 };
  } }, { key: &quot;getX1X2&quot;, value: function(t3, e2) {
    var i2 = this.w, a2 = &quot;x1&quot; === t3 ? e2.x : e2.x2, s2 = this.annoCtx.invertAxis ? i2.globals.minY : i2.globals.minX, r2 = this.annoCtx.invertAxis ? i2.globals.maxY : i2.globals.maxX, n2 = this.annoCtx.invertAxis ? i2.globals.yRange[0] : i2.globals.xRange, o2 = false, l2 = this.annoCtx.inversedReversedAxis ? (r2 - a2) / (n2 / i2.globals.gridWidth) : (a2 - s2) / (n2 / i2.globals.gridWidth);
    return &quot;category&quot; !== i2.config.xaxis.type &amp;&amp; !i2.config.xaxis.convertedCatToNumeric || this.annoCtx.invertAxis || i2.globals.dataFormatXNumeric || i2.config.chart.sparkline.enabled || (l2 = this.getStringX(a2)), &quot;string&quot; == typeof a2 &amp;&amp; a2.includes(&quot;px&quot;) &amp;&amp; (l2 = parseFloat(a2)), null == a2 &amp;&amp; e2.marker &amp;&amp; (l2 = i2.globals.gridWidth), void 0 !== e2.seriesIndex &amp;&amp; i2.globals.barWidth &amp;&amp; !this.annoCtx.invertAxis &amp;&amp; (l2 -= i2.globals.barWidth / 2 * (i2.globals.series.length - 1) - i2.globals.barWidth * e2.seriesIndex), l2 &gt; i2.globals.gridWidth ? (l2 = i2.globals.gridWidth, o2 = true) : l2 &lt; 0 &amp;&amp; (l2 = 0, o2 = true), { x: l2, clipped: o2 };
  } }, { key: &quot;getStringX&quot;, value: function(t3) {
    var e2 = this.w, i2 = t3;
    e2.config.xaxis.convertedCatToNumeric &amp;&amp; e2.globals.categoryLabels.length &amp;&amp; (t3 = e2.globals.categoryLabels.indexOf(t3) + 1);
    var a2 = e2.globals.labels.map(function(t4) {
      return Array.isArray(t4) ? t4.join(&quot; &quot;) : t4;
    }).indexOf(t3), s2 = e2.globals.dom.baseEl.querySelector(&quot;.apexcharts-xaxis-texts-g text:nth-child(&quot;.concat(a2 + 1, &quot;)&quot;));
    return s2 &amp;&amp; (i2 = parseFloat(s2.getAttribute(&quot;x&quot;))), i2;
  } }]), t2;
}();
var Ti = function() {
  function t2(e2) {
    i(this, t2), this.w = e2.w, this.annoCtx = e2, this.invertAxis = this.annoCtx.invertAxis, this.helpers = new Ii(this.annoCtx);
  }
  return s(t2, [{ key: &quot;addXaxisAnnotation&quot;, value: function(t3, e2, i2) {
    var a2, s2 = this.w, r2 = this.helpers.getX1X2(&quot;x1&quot;, t3), n2 = r2.x, o2 = r2.clipped, l2 = true, h2 = t3.label.text, c2 = t3.strokeDashArray;
    if (v.isNumber(n2)) {
      if (null === t3.x2 || void 0 === t3.x2) {
        if (!o2) {
          var d2 = this.annoCtx.graphics.drawLine(n2 + t3.offsetX, 0 + t3.offsetY, n2 + t3.offsetX, s2.globals.gridHeight + t3.offsetY, t3.borderColor, c2, t3.borderWidth);
          e2.appendChild(d2.node), t3.id &amp;&amp; d2.node.classList.add(t3.id);
        }
      } else {
        var u2 = this.helpers.getX1X2(&quot;x2&quot;, t3);
        if (a2 = u2.x, l2 = u2.clipped, a2 &lt; n2) {
          var g2 = n2;
          n2 = a2, a2 = g2;
        }
        var p2 = this.annoCtx.graphics.drawRect(n2 + t3.offsetX, 0 + t3.offsetY, a2 - n2, s2.globals.gridHeight + t3.offsetY, 0, t3.fillColor, t3.opacity, 1, t3.borderColor, c2);
        p2.node.classList.add(&quot;apexcharts-annotation-rect&quot;), p2.attr(&quot;clip-path&quot;, &quot;url(#gridRectMask&quot;.concat(s2.globals.cuid, &quot;)&quot;)), e2.appendChild(p2.node), t3.id &amp;&amp; p2.node.classList.add(t3.id);
      }
      if (!o2 || !l2) {
        var f2 = this.annoCtx.graphics.getTextRects(h2, parseFloat(t3.label.style.fontSize)), x2 = &quot;top&quot; === t3.label.position ? 4 : &quot;center&quot; === t3.label.position ? s2.globals.gridHeight / 2 + (&quot;vertical&quot; === t3.label.orientation ? f2.width / 2 : 0) : s2.globals.gridHeight, b2 = this.annoCtx.graphics.drawText({ x: n2 + t3.label.offsetX, y: x2 + t3.label.offsetY - (&quot;vertical&quot; === t3.label.orientation ? &quot;top&quot; === t3.label.position ? f2.width / 2 - 12 : -f2.width / 2 : 0), text: h2, textAnchor: t3.label.textAnchor, fontSize: t3.label.style.fontSize, fontFamily: t3.label.style.fontFamily, fontWeight: t3.label.style.fontWeight, foreColor: t3.label.style.color, cssClass: &quot;apexcharts-xaxis-annotation-label &quot;.concat(t3.label.style.cssClass, &quot; &quot;).concat(t3.id ? t3.id : &quot;&quot;) });
        b2.attr({ rel: i2 }), e2.appendChild(b2.node), this.annoCtx.helpers.setOrientations(t3, i2);
      }
    }
  } }, { key: &quot;drawXAxisAnnotations&quot;, value: function() {
    var t3 = this, e2 = this.w, i2 = this.annoCtx.graphics.group({ class: &quot;apexcharts-xaxis-annotations&quot; });
    return e2.config.annotations.xaxis.map(function(e3, a2) {
      t3.addXaxisAnnotation(e3, i2.node, a2);
    }), i2;
  } }]), t2;
}();
var zi = function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w, this.months31 = [1, 3, 5, 7, 8, 10, 12], this.months30 = [2, 4, 6, 9, 11], this.daysCntOfYear = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
  }
  return s(t2, [{ key: &quot;isValidDate&quot;, value: function(t3) {
    return &quot;number&quot; != typeof t3 &amp;&amp; !isNaN(this.parseDate(t3));
  } }, { key: &quot;getTimeStamp&quot;, value: function(t3) {
    return Date.parse(t3) ? this.w.config.xaxis.labels.datetimeUTC ? new Date(new Date(t3).toISOString().substr(0, 25)).getTime() : new Date(t3).getTime() : t3;
  } }, { key: &quot;getDate&quot;, value: function(t3) {
    return this.w.config.xaxis.labels.datetimeUTC ? new Date(new Date(t3).toUTCString()) : new Date(t3);
  } }, { key: &quot;parseDate&quot;, value: function(t3) {
    var e2 = Date.parse(t3);
    if (!isNaN(e2)) return this.getTimeStamp(t3);
    var i2 = Date.parse(t3.replace(/-/g, &quot;/&quot;).replace(/[a-z]+/gi, &quot; &quot;));
    return i2 = this.getTimeStamp(i2);
  } }, { key: &quot;parseDateWithTimezone&quot;, value: function(t3) {
    return Date.parse(t3.replace(/-/g, &quot;/&quot;).replace(/[a-z]+/gi, &quot; &quot;));
  } }, { key: &quot;formatDate&quot;, value: function(t3, e2) {
    var i2 = this.w.globals.locale, a2 = this.w.config.xaxis.labels.datetimeUTC, s2 = [&quot;\0&quot;].concat(f(i2.months)), r2 = [&quot;&quot;].concat(f(i2.shortMonths)), n2 = [&quot;&quot;].concat(f(i2.days)), o2 = [&quot;&quot;].concat(f(i2.shortDays));
    function l2(t4, e3) {
      var i3 = t4 + &quot;&quot;;
      for (e3 = e3 || 2; i3.length &lt; e3; ) i3 = &quot;0&quot; + i3;
      return i3;
    }
    var h2 = a2 ? t3.getUTCFullYear() : t3.getFullYear();
    e2 = (e2 = (e2 = e2.replace(/(^|[^\\])yyyy+/g, &quot;$1&quot; + h2)).replace(/(^|[^\\])yy/g, &quot;$1&quot; + h2.toString().substr(2, 2))).replace(/(^|[^\\])y/g, &quot;$1&quot; + h2);
    var c2 = (a2 ? t3.getUTCMonth() : t3.getMonth()) + 1;
    e2 = (e2 = (e2 = (e2 = e2.replace(/(^|[^\\])MMMM+/g, &quot;$1&quot; + s2[0])).replace(/(^|[^\\])MMM/g, &quot;$1&quot; + r2[0])).replace(/(^|[^\\])MM/g, &quot;$1&quot; + l2(c2))).replace(/(^|[^\\])M/g, &quot;$1&quot; + c2);
    var d2 = a2 ? t3.getUTCDate() : t3.getDate();
    e2 = (e2 = (e2 = (e2 = e2.replace(/(^|[^\\])dddd+/g, &quot;$1&quot; + n2[0])).replace(/(^|[^\\])ddd/g, &quot;$1&quot; + o2[0])).replace(/(^|[^\\])dd/g, &quot;$1&quot; + l2(d2))).replace(/(^|[^\\])d/g, &quot;$1&quot; + d2);
    var u2 = a2 ? t3.getUTCHours() : t3.getHours(), g2 = u2 &gt; 12 ? u2 - 12 : 0 === u2 ? 12 : u2;
    e2 = (e2 = (e2 = (e2 = e2.replace(/(^|[^\\])HH+/g, &quot;$1&quot; + l2(u2))).replace(/(^|[^\\])H/g, &quot;$1&quot; + u2)).replace(/(^|[^\\])hh+/g, &quot;$1&quot; + l2(g2))).replace(/(^|[^\\])h/g, &quot;$1&quot; + g2);
    var p2 = a2 ? t3.getUTCMinutes() : t3.getMinutes();
    e2 = (e2 = e2.replace(/(^|[^\\])mm+/g, &quot;$1&quot; + l2(p2))).replace(/(^|[^\\])m/g, &quot;$1&quot; + p2);
    var x2 = a2 ? t3.getUTCSeconds() : t3.getSeconds();
    e2 = (e2 = e2.replace(/(^|[^\\])ss+/g, &quot;$1&quot; + l2(x2))).replace(/(^|[^\\])s/g, &quot;$1&quot; + x2);
    var b2 = a2 ? t3.getUTCMilliseconds() : t3.getMilliseconds();
    e2 = e2.replace(/(^|[^\\])fff+/g, &quot;$1&quot; + l2(b2, 3)), b2 = Math.round(b2 / 10), e2 = e2.replace(/(^|[^\\])ff/g, &quot;$1&quot; + l2(b2)), b2 = Math.round(b2 / 10);
    var m2 = u2 &lt; 12 ? &quot;AM&quot; : &quot;PM&quot;;
    e2 = (e2 = (e2 = e2.replace(/(^|[^\\])f/g, &quot;$1&quot; + b2)).replace(/(^|[^\\])TT+/g, &quot;$1&quot; + m2)).replace(/(^|[^\\])T/g, &quot;$1&quot; + m2.charAt(0));
    var v2 = m2.toLowerCase();
    e2 = (e2 = e2.replace(/(^|[^\\])tt+/g, &quot;$1&quot; + v2)).replace(/(^|[^\\])t/g, &quot;$1&quot; + v2.charAt(0));
    var y2 = -t3.getTimezoneOffset(), w2 = a2 || !y2 ? &quot;Z&quot; : y2 &gt; 0 ? &quot;+&quot; : &quot;-&quot;;
    if (!a2) {
      var k2 = (y2 = Math.abs(y2)) % 60;
      w2 += l2(Math.floor(y2 / 60)) + &quot;:&quot; + l2(k2);
    }
    e2 = e2.replace(/(^|[^\\])K/g, &quot;$1&quot; + w2);
    var A2 = (a2 ? t3.getUTCDay() : t3.getDay()) + 1;
    return e2 = (e2 = (e2 = (e2 = (e2 = e2.replace(new RegExp(n2[0], &quot;g&quot;), n2[A2])).replace(new RegExp(o2[0], &quot;g&quot;), o2[A2])).replace(new RegExp(s2[0], &quot;g&quot;), s2[c2])).replace(new RegExp(r2[0], &quot;g&quot;), r2[c2])).replace(/\\(.)/g, &quot;$1&quot;);
  } }, { key: &quot;getTimeUnitsfromTimestamp&quot;, value: function(t3, e2, i2) {
    var a2 = this.w;
    void 0 !== a2.config.xaxis.min &amp;&amp; (t3 = a2.config.xaxis.min), void 0 !== a2.config.xaxis.max &amp;&amp; (e2 = a2.config.xaxis.max);
    var s2 = this.getDate(t3), r2 = this.getDate(e2), n2 = this.formatDate(s2, &quot;yyyy MM dd HH mm ss fff&quot;).split(&quot; &quot;), o2 = this.formatDate(r2, &quot;yyyy MM dd HH mm ss fff&quot;).split(&quot; &quot;);
    return { minMillisecond: parseInt(n2[6], 10), maxMillisecond: parseInt(o2[6], 10), minSecond: parseInt(n2[5], 10), maxSecond: parseInt(o2[5], 10), minMinute: parseInt(n2[4], 10), maxMinute: parseInt(o2[4], 10), minHour: parseInt(n2[3], 10), maxHour: parseInt(o2[3], 10), minDate: parseInt(n2[2], 10), maxDate: parseInt(o2[2], 10), minMonth: parseInt(n2[1], 10) - 1, maxMonth: parseInt(o2[1], 10) - 1, minYear: parseInt(n2[0], 10), maxYear: parseInt(o2[0], 10) };
  } }, { key: &quot;isLeapYear&quot;, value: function(t3) {
    return t3 % 4 == 0 &amp;&amp; t3 % 100 != 0 || t3 % 400 == 0;
  } }, { key: &quot;calculcateLastDaysOfMonth&quot;, value: function(t3, e2, i2) {
    return this.determineDaysOfMonths(t3, e2) - i2;
  } }, { key: &quot;determineDaysOfYear&quot;, value: function(t3) {
    var e2 = 365;
    return this.isLeapYear(t3) &amp;&amp; (e2 = 366), e2;
  } }, { key: &quot;determineRemainingDaysOfYear&quot;, value: function(t3, e2, i2) {
    var a2 = this.daysCntOfYear[e2] + i2;
    return e2 &gt; 1 &amp;&amp; this.isLeapYear() &amp;&amp; a2++, a2;
  } }, { key: &quot;determineDaysOfMonths&quot;, value: function(t3, e2) {
    var i2 = 30;
    switch (t3 = v.monthMod(t3), true) {
      case this.months30.indexOf(t3) &gt; -1:
        2 === t3 &amp;&amp; (i2 = this.isLeapYear(e2) ? 29 : 28);
        break;
      case this.months31.indexOf(t3) &gt; -1:
      default:
        i2 = 31;
    }
    return i2;
  } }]), t2;
}();
var Xi = function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w, this.tooltipKeyFormat = &quot;dd MMM&quot;;
  }
  return s(t2, [{ key: &quot;xLabelFormat&quot;, value: function(t3, e2, i2, a2) {
    var s2 = this.w;
    if (&quot;datetime&quot; === s2.config.xaxis.type &amp;&amp; void 0 === s2.config.xaxis.labels.formatter &amp;&amp; void 0 === s2.config.tooltip.x.formatter) {
      var r2 = new zi(this.ctx);
      return r2.formatDate(r2.getDate(e2), s2.config.tooltip.x.format);
    }
    return t3(e2, i2, a2);
  } }, { key: &quot;defaultGeneralFormatter&quot;, value: function(t3) {
    return Array.isArray(t3) ? t3.map(function(t4) {
      return t4;
    }) : t3;
  } }, { key: &quot;defaultYFormatter&quot;, value: function(t3, e2, i2) {
    var a2 = this.w;
    if (v.isNumber(t3)) if (0 !== a2.globals.yValueDecimal) t3 = t3.toFixed(void 0 !== e2.decimalsInFloat ? e2.decimalsInFloat : a2.globals.yValueDecimal);
    else {
      var s2 = t3.toFixed(0);
      t3 = t3 == s2 ? s2 : t3.toFixed(1);
    }
    return t3;
  } }, { key: &quot;setLabelFormatters&quot;, value: function() {
    var t3 = this, e2 = this.w;
    return e2.globals.xaxisTooltipFormatter = function(e3) {
      return t3.defaultGeneralFormatter(e3);
    }, e2.globals.ttKeyFormatter = function(e3) {
      return t3.defaultGeneralFormatter(e3);
    }, e2.globals.ttZFormatter = function(t4) {
      return t4;
    }, e2.globals.legendFormatter = function(e3) {
      return t3.defaultGeneralFormatter(e3);
    }, void 0 !== e2.config.xaxis.labels.formatter ? e2.globals.xLabelFormatter = e2.config.xaxis.labels.formatter : e2.globals.xLabelFormatter = function(t4) {
      if (v.isNumber(t4)) {
        if (!e2.config.xaxis.convertedCatToNumeric &amp;&amp; &quot;numeric&quot; === e2.config.xaxis.type) {
          if (v.isNumber(e2.config.xaxis.decimalsInFloat)) return t4.toFixed(e2.config.xaxis.decimalsInFloat);
          var i2 = e2.globals.maxX - e2.globals.minX;
          return i2 &gt; 0 &amp;&amp; i2 &lt; 100 ? t4.toFixed(1) : t4.toFixed(0);
        }
        if (e2.globals.isBarHorizontal) {
          if (e2.globals.maxY - e2.globals.minYArr &lt; 4) return t4.toFixed(1);
        }
        return t4.toFixed(0);
      }
      return t4;
    }, &quot;function&quot; == typeof e2.config.tooltip.x.formatter ? e2.globals.ttKeyFormatter = e2.config.tooltip.x.formatter : e2.globals.ttKeyFormatter = e2.globals.xLabelFormatter, &quot;function&quot; == typeof e2.config.xaxis.tooltip.formatter &amp;&amp; (e2.globals.xaxisTooltipFormatter = e2.config.xaxis.tooltip.formatter), (Array.isArray(e2.config.tooltip.y) || void 0 !== e2.config.tooltip.y.formatter) &amp;&amp; (e2.globals.ttVal = e2.config.tooltip.y), void 0 !== e2.config.tooltip.z.formatter &amp;&amp; (e2.globals.ttZFormatter = e2.config.tooltip.z.formatter), void 0 !== e2.config.legend.formatter &amp;&amp; (e2.globals.legendFormatter = e2.config.legend.formatter), e2.config.yaxis.forEach(function(i2, a2) {
      void 0 !== i2.labels.formatter ? e2.globals.yLabelFormatters[a2] = i2.labels.formatter : e2.globals.yLabelFormatters[a2] = function(s2) {
        return e2.globals.xyCharts ? Array.isArray(s2) ? s2.map(function(e3) {
          return t3.defaultYFormatter(e3, i2, a2);
        }) : t3.defaultYFormatter(s2, i2, a2) : s2;
      };
    }), e2.globals;
  } }, { key: &quot;heatmapLabelFormatters&quot;, value: function() {
    var t3 = this.w;
    if (&quot;heatmap&quot; === t3.config.chart.type) {
      t3.globals.yAxisScale[0].result = t3.globals.seriesNames.slice();
      var e2 = t3.globals.seriesNames.reduce(function(t4, e3) {
        return t4.length &gt; e3.length ? t4 : e3;
      }, 0);
      t3.globals.yAxisScale[0].niceMax = e2, t3.globals.yAxisScale[0].niceMin = e2;
    }
  } }]), t2;
}();
var Ri = function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w;
  }
  return s(t2, [{ key: &quot;getLabel&quot;, value: function(t3, e2, i2, a2) {
    var s2 = arguments.length &gt; 4 &amp;&amp; void 0 !== arguments[4] ? arguments[4] : [], r2 = arguments.length &gt; 5 &amp;&amp; void 0 !== arguments[5] ? arguments[5] : &quot;12px&quot;, n2 = !(arguments.length &gt; 6 &amp;&amp; void 0 !== arguments[6]) || arguments[6], o2 = this.w, l2 = void 0 === t3[a2] ? &quot;&quot; : t3[a2], h2 = l2, c2 = o2.globals.xLabelFormatter, d2 = o2.config.xaxis.labels.formatter, u2 = false, g2 = new Xi(this.ctx), p2 = l2;
    n2 &amp;&amp; (h2 = g2.xLabelFormat(c2, l2, p2, { i: a2, dateFormatter: new zi(this.ctx).formatDate, w: o2 }), void 0 !== d2 &amp;&amp; (h2 = d2(l2, t3[a2], { i: a2, dateFormatter: new zi(this.ctx).formatDate, w: o2 })));
    var f2, x2;
    e2.length &gt; 0 ? (f2 = e2[a2].unit, x2 = null, e2.forEach(function(t4) {
      &quot;month&quot; === t4.unit ? x2 = &quot;year&quot; : &quot;day&quot; === t4.unit ? x2 = &quot;month&quot; : &quot;hour&quot; === t4.unit ? x2 = &quot;day&quot; : &quot;minute&quot; === t4.unit &amp;&amp; (x2 = &quot;hour&quot;);
    }), u2 = x2 === f2, i2 = e2[a2].position, h2 = e2[a2].value) : &quot;datetime&quot; === o2.config.xaxis.type &amp;&amp; void 0 === d2 &amp;&amp; (h2 = &quot;&quot;), void 0 === h2 &amp;&amp; (h2 = &quot;&quot;), h2 = Array.isArray(h2) ? h2 : h2.toString();
    var b2 = new Mi(this.ctx), m2 = {};
    m2 = o2.globals.rotateXLabels &amp;&amp; n2 ? b2.getTextRects(h2, parseInt(r2, 10), null, &quot;rotate(&quot;.concat(o2.config.xaxis.labels.rotate, &quot; 0 0)&quot;), false) : b2.getTextRects(h2, parseInt(r2, 10));
    var v2 = !o2.config.xaxis.labels.showDuplicates &amp;&amp; this.ctx.timeScale;
    return !Array.isArray(h2) &amp;&amp; (&quot;NaN&quot; === String(h2) || s2.indexOf(h2) &gt;= 0 &amp;&amp; v2) &amp;&amp; (h2 = &quot;&quot;), { x: i2, text: h2, textRect: m2, isBold: u2 };
  } }, { key: &quot;checkLabelBasedOnTickamount&quot;, value: function(t3, e2, i2) {
    var a2 = this.w, s2 = a2.config.xaxis.tickAmount;
    return &quot;dataPoints&quot; === s2 &amp;&amp; (s2 = Math.round(a2.globals.gridWidth / 120)), s2 &gt; i2 || t3 % Math.round(i2 / (s2 + 1)) == 0 || (e2.text = &quot;&quot;), e2;
  } }, { key: &quot;checkForOverflowingLabels&quot;, value: function(t3, e2, i2, a2, s2) {
    var r2 = this.w;
    if (0 === t3 &amp;&amp; r2.globals.skipFirstTimelinelabel &amp;&amp; (e2.text = &quot;&quot;), t3 === i2 - 1 &amp;&amp; r2.globals.skipLastTimelinelabel &amp;&amp; (e2.text = &quot;&quot;), r2.config.xaxis.labels.hideOverlappingLabels &amp;&amp; a2.length &gt; 0) {
      var n2 = s2[s2.length - 1];
      e2.x &lt; n2.textRect.width / (r2.globals.rotateXLabels ? Math.abs(r2.config.xaxis.labels.rotate) / 12 : 1.01) + n2.x &amp;&amp; (e2.text = &quot;&quot;);
    }
    return e2;
  } }, { key: &quot;checkForReversedLabels&quot;, value: function(t3, e2) {
    var i2 = this.w;
    return i2.config.yaxis[t3] &amp;&amp; i2.config.yaxis[t3].reversed &amp;&amp; e2.reverse(), e2;
  } }, { key: &quot;yAxisAllSeriesCollapsed&quot;, value: function(t3) {
    var e2 = this.w.globals;
    return !e2.seriesYAxisMap[t3].some(function(t4) {
      return -1 === e2.collapsedSeriesIndices.indexOf(t4);
    });
  } }, { key: &quot;translateYAxisIndex&quot;, value: function(t3) {
    var e2 = this.w, i2 = e2.globals, a2 = e2.config.yaxis;
    return i2.series.length &gt; a2.length || a2.some(function(t4) {
      return Array.isArray(t4.seriesName);
    }) ? t3 : i2.seriesYAxisReverseMap[t3];
  } }, { key: &quot;isYAxisHidden&quot;, value: function(t3) {
    var e2 = this.w, i2 = e2.config.yaxis[t3];
    if (!i2.show || this.yAxisAllSeriesCollapsed(t3)) return true;
    if (!i2.showForNullSeries) {
      var a2 = e2.globals.seriesYAxisMap[t3], s2 = new Pi(this.ctx);
      return a2.every(function(t4) {
        return s2.isSeriesNull(t4);
      });
    }
    return false;
  } }, { key: &quot;getYAxisForeColor&quot;, value: function(t3, e2) {
    var i2 = this.w;
    return Array.isArray(t3) &amp;&amp; i2.globals.yAxisScale[e2] &amp;&amp; this.ctx.theme.pushExtraColors(t3, i2.globals.yAxisScale[e2].result.length, false), t3;
  } }, { key: &quot;drawYAxisTicks&quot;, value: function(t3, e2, i2, a2, s2, r2, n2) {
    var o2 = this.w, l2 = new Mi(this.ctx), h2 = o2.globals.translateY + o2.config.yaxis[s2].labels.offsetY;
    if (o2.globals.isBarHorizontal ? h2 = 0 : &quot;heatmap&quot; === o2.config.chart.type &amp;&amp; (h2 += r2 / 2), a2.show &amp;&amp; e2 &gt; 0) {
      true === o2.config.yaxis[s2].opposite &amp;&amp; (t3 += a2.width);
      for (var c2 = e2; c2 &gt;= 0; c2--) {
        var d2 = l2.drawLine(t3 + i2.offsetX - a2.width + a2.offsetX, h2 + a2.offsetY, t3 + i2.offsetX + a2.offsetX, h2 + a2.offsetY, a2.color);
        n2.add(d2), h2 += r2;
      }
    }
  } }]), t2;
}();
var Ei = function() {
  function t2(e2) {
    i(this, t2), this.w = e2.w, this.annoCtx = e2, this.helpers = new Ii(this.annoCtx), this.axesUtils = new Ri(this.annoCtx);
  }
  return s(t2, [{ key: &quot;addYaxisAnnotation&quot;, value: function(t3, e2, i2) {
    var a2, s2 = this.w, r2 = t3.strokeDashArray, n2 = this.helpers.getY1Y2(&quot;y1&quot;, t3), o2 = n2.yP, l2 = n2.clipped, h2 = true, c2 = false, d2 = t3.label.text;
    if (null === t3.y2 || void 0 === t3.y2) {
      if (!l2) {
        c2 = true;
        var u2 = this.annoCtx.graphics.drawLine(0 + t3.offsetX, o2 + t3.offsetY, this._getYAxisAnnotationWidth(t3), o2 + t3.offsetY, t3.borderColor, r2, t3.borderWidth);
        e2.appendChild(u2.node), t3.id &amp;&amp; u2.node.classList.add(t3.id);
      }
    } else {
      if (a2 = (n2 = this.helpers.getY1Y2(&quot;y2&quot;, t3)).yP, h2 = n2.clipped, a2 &gt; o2) {
        var g2 = o2;
        o2 = a2, a2 = g2;
      }
      if (!l2 || !h2) {
        c2 = true;
        var p2 = this.annoCtx.graphics.drawRect(0 + t3.offsetX, a2 + t3.offsetY, this._getYAxisAnnotationWidth(t3), o2 - a2, 0, t3.fillColor, t3.opacity, 1, t3.borderColor, r2);
        p2.node.classList.add(&quot;apexcharts-annotation-rect&quot;), p2.attr(&quot;clip-path&quot;, &quot;url(#gridRectMask&quot;.concat(s2.globals.cuid, &quot;)&quot;)), e2.appendChild(p2.node), t3.id &amp;&amp; p2.node.classList.add(t3.id);
      }
    }
    if (c2) {
      var f2 = &quot;right&quot; === t3.label.position ? s2.globals.gridWidth : &quot;center&quot; === t3.label.position ? s2.globals.gridWidth / 2 : 0, x2 = this.annoCtx.graphics.drawText({ x: f2 + t3.label.offsetX, y: (null != a2 ? a2 : o2) + t3.label.offsetY - 3, text: d2, textAnchor: t3.label.textAnchor, fontSize: t3.label.style.fontSize, fontFamily: t3.label.style.fontFamily, fontWeight: t3.label.style.fontWeight, foreColor: t3.label.style.color, cssClass: &quot;apexcharts-yaxis-annotation-label &quot;.concat(t3.label.style.cssClass, &quot; &quot;).concat(t3.id ? t3.id : &quot;&quot;) });
      x2.attr({ rel: i2 }), e2.appendChild(x2.node);
    }
  } }, { key: &quot;_getYAxisAnnotationWidth&quot;, value: function(t3) {
    var e2 = this.w;
    e2.globals.gridWidth;
    return (t3.width.indexOf(&quot;%&quot;) &gt; -1 ? e2.globals.gridWidth * parseInt(t3.width, 10) / 100 : parseInt(t3.width, 10)) + t3.offsetX;
  } }, { key: &quot;drawYAxisAnnotations&quot;, value: function() {
    var t3 = this, e2 = this.w, i2 = this.annoCtx.graphics.group({ class: &quot;apexcharts-yaxis-annotations&quot; });
    return e2.config.annotations.yaxis.forEach(function(e3, a2) {
      e3.yAxisIndex = t3.axesUtils.translateYAxisIndex(e3.yAxisIndex), t3.axesUtils.isYAxisHidden(e3.yAxisIndex) &amp;&amp; t3.axesUtils.yAxisAllSeriesCollapsed(e3.yAxisIndex) || t3.addYaxisAnnotation(e3, i2.node, a2);
    }), i2;
  } }]), t2;
}();
var Yi = function() {
  function t2(e2) {
    i(this, t2), this.w = e2.w, this.annoCtx = e2, this.helpers = new Ii(this.annoCtx);
  }
  return s(t2, [{ key: &quot;addPointAnnotation&quot;, value: function(t3, e2, i2) {
    if (!(this.w.globals.collapsedSeriesIndices.indexOf(t3.seriesIndex) &gt; -1)) {
      var a2 = this.helpers.getX1X2(&quot;x1&quot;, t3), s2 = a2.x, r2 = a2.clipped, n2 = (a2 = this.helpers.getY1Y2(&quot;y1&quot;, t3)).yP, o2 = a2.clipped;
      if (v.isNumber(s2) &amp;&amp; !o2 &amp;&amp; !r2) {
        var l2 = { pSize: t3.marker.size, pointStrokeWidth: t3.marker.strokeWidth, pointFillColor: t3.marker.fillColor, pointStrokeColor: t3.marker.strokeColor, shape: t3.marker.shape, pRadius: t3.marker.radius, class: &quot;apexcharts-point-annotation-marker &quot;.concat(t3.marker.cssClass, &quot; &quot;).concat(t3.id ? t3.id : &quot;&quot;) }, h2 = this.annoCtx.graphics.drawMarker(s2 + t3.marker.offsetX, n2 + t3.marker.offsetY, l2);
        e2.appendChild(h2.node);
        var c2 = t3.label.text ? t3.label.text : &quot;&quot;, d2 = this.annoCtx.graphics.drawText({ x: s2 + t3.label.offsetX, y: n2 + t3.label.offsetY - t3.marker.size - parseFloat(t3.label.style.fontSize) / 1.6, text: c2, textAnchor: t3.label.textAnchor, fontSize: t3.label.style.fontSize, fontFamily: t3.label.style.fontFamily, fontWeight: t3.label.style.fontWeight, foreColor: t3.label.style.color, cssClass: &quot;apexcharts-point-annotation-label &quot;.concat(t3.label.style.cssClass, &quot; &quot;).concat(t3.id ? t3.id : &quot;&quot;) });
        if (d2.attr({ rel: i2 }), e2.appendChild(d2.node), t3.customSVG.SVG) {
          var u2 = this.annoCtx.graphics.group({ class: &quot;apexcharts-point-annotations-custom-svg &quot; + t3.customSVG.cssClass });
          u2.attr({ transform: &quot;translate(&quot;.concat(s2 + t3.customSVG.offsetX, &quot;, &quot;).concat(n2 + t3.customSVG.offsetY, &quot;)&quot;) }), u2.node.innerHTML = t3.customSVG.SVG, e2.appendChild(u2.node);
        }
        if (t3.image.path) {
          var g2 = t3.image.width ? t3.image.width : 20, p2 = t3.image.height ? t3.image.height : 20;
          h2 = this.annoCtx.addImage({ x: s2 + t3.image.offsetX - g2 / 2, y: n2 + t3.image.offsetY - p2 / 2, width: g2, height: p2, path: t3.image.path, appendTo: &quot;.apexcharts-point-annotations&quot; });
        }
        t3.mouseEnter &amp;&amp; h2.node.addEventListener(&quot;mouseenter&quot;, t3.mouseEnter.bind(this, t3)), t3.mouseLeave &amp;&amp; h2.node.addEventListener(&quot;mouseleave&quot;, t3.mouseLeave.bind(this, t3)), t3.click &amp;&amp; h2.node.addEventListener(&quot;click&quot;, t3.click.bind(this, t3));
      }
    }
  } }, { key: &quot;drawPointAnnotations&quot;, value: function() {
    var t3 = this, e2 = this.w, i2 = this.annoCtx.graphics.group({ class: &quot;apexcharts-point-annotations&quot; });
    return e2.config.annotations.points.map(function(e3, a2) {
      t3.addPointAnnotation(e3, i2.node, a2);
    }), i2;
  } }]), t2;
}();
var Hi = { name: &quot;en&quot;, options: { months: [&quot;January&quot;, &quot;February&quot;, &quot;March&quot;, &quot;April&quot;, &quot;May&quot;, &quot;June&quot;, &quot;July&quot;, &quot;August&quot;, &quot;September&quot;, &quot;October&quot;, &quot;November&quot;, &quot;December&quot;], shortMonths: [&quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;, &quot;Jun&quot;, &quot;Jul&quot;, &quot;Aug&quot;, &quot;Sep&quot;, &quot;Oct&quot;, &quot;Nov&quot;, &quot;Dec&quot;], days: [&quot;Sunday&quot;, &quot;Monday&quot;, &quot;Tuesday&quot;, &quot;Wednesday&quot;, &quot;Thursday&quot;, &quot;Friday&quot;, &quot;Saturday&quot;], shortDays: [&quot;Sun&quot;, &quot;Mon&quot;, &quot;Tue&quot;, &quot;Wed&quot;, &quot;Thu&quot;, &quot;Fri&quot;, &quot;Sat&quot;], toolbar: { exportToSVG: &quot;Download SVG&quot;, exportToPNG: &quot;Download PNG&quot;, exportToCSV: &quot;Download CSV&quot;, menu: &quot;Menu&quot;, selection: &quot;Selection&quot;, selectionZoom: &quot;Selection Zoom&quot;, zoomIn: &quot;Zoom In&quot;, zoomOut: &quot;Zoom Out&quot;, pan: &quot;Panning&quot;, reset: &quot;Reset Zoom&quot; } } };
var Oi = function() {
  function t2() {
    i(this, t2), this.yAxis = { show: true, showAlways: false, showForNullSeries: true, seriesName: void 0, opposite: false, reversed: false, logarithmic: false, logBase: 10, tickAmount: void 0, stepSize: void 0, forceNiceScale: false, max: void 0, min: void 0, floating: false, decimalsInFloat: void 0, labels: { show: true, showDuplicates: false, minWidth: 0, maxWidth: 160, offsetX: 0, offsetY: 0, align: void 0, rotate: 0, padding: 20, style: { colors: [], fontSize: &quot;11px&quot;, fontWeight: 400, fontFamily: void 0, cssClass: &quot;&quot; }, formatter: void 0 }, axisBorder: { show: false, color: &quot;#e0e0e0&quot;, width: 1, offsetX: 0, offsetY: 0 }, axisTicks: { show: false, color: &quot;#e0e0e0&quot;, width: 6, offsetX: 0, offsetY: 0 }, title: { text: void 0, rotate: -90, offsetY: 0, offsetX: 0, style: { color: void 0, fontSize: &quot;11px&quot;, fontWeight: 900, fontFamily: void 0, cssClass: &quot;&quot; } }, tooltip: { enabled: false, offsetX: 0 }, crosshairs: { show: true, position: &quot;front&quot;, stroke: { color: &quot;#b6b6b6&quot;, width: 1, dashArray: 0 } } }, this.pointAnnotation = { id: void 0, x: 0, y: null, yAxisIndex: 0, seriesIndex: void 0, mouseEnter: void 0, mouseLeave: void 0, click: void 0, marker: { size: 4, fillColor: &quot;#fff&quot;, strokeWidth: 2, strokeColor: &quot;#333&quot;, shape: &quot;circle&quot;, offsetX: 0, offsetY: 0, cssClass: &quot;&quot; }, label: { borderColor: &quot;#c2c2c2&quot;, borderWidth: 1, borderRadius: 2, text: void 0, textAnchor: &quot;middle&quot;, offsetX: 0, offsetY: 0, mouseEnter: void 0, mouseLeave: void 0, click: void 0, style: { background: &quot;#fff&quot;, color: void 0, fontSize: &quot;11px&quot;, fontFamily: void 0, fontWeight: 400, cssClass: &quot;&quot;, padding: { left: 5, right: 5, top: 2, bottom: 2 } } }, customSVG: { SVG: void 0, cssClass: void 0, offsetX: 0, offsetY: 0 }, image: { path: void 0, width: 20, height: 20, offsetX: 0, offsetY: 0 } }, this.yAxisAnnotation = { id: void 0, y: 0, y2: null, strokeDashArray: 1, fillColor: &quot;#c2c2c2&quot;, borderColor: &quot;#c2c2c2&quot;, borderWidth: 1, opacity: 0.3, offsetX: 0, offsetY: 0, width: &quot;100%&quot;, yAxisIndex: 0, label: { borderColor: &quot;#c2c2c2&quot;, borderWidth: 1, borderRadius: 2, text: void 0, textAnchor: &quot;end&quot;, position: &quot;right&quot;, offsetX: 0, offsetY: -3, mouseEnter: void 0, mouseLeave: void 0, click: void 0, style: { background: &quot;#fff&quot;, color: void 0, fontSize: &quot;11px&quot;, fontFamily: void 0, fontWeight: 400, cssClass: &quot;&quot;, padding: { left: 5, right: 5, top: 2, bottom: 2 } } } }, this.xAxisAnnotation = { id: void 0, x: 0, x2: null, strokeDashArray: 1, fillColor: &quot;#c2c2c2&quot;, borderColor: &quot;#c2c2c2&quot;, borderWidth: 1, opacity: 0.3, offsetX: 0, offsetY: 0, label: { borderColor: &quot;#c2c2c2&quot;, borderWidth: 1, borderRadius: 2, text: void 0, textAnchor: &quot;middle&quot;, orientation: &quot;vertical&quot;, position: &quot;top&quot;, offsetX: 0, offsetY: 0, mouseEnter: void 0, mouseLeave: void 0, click: void 0, style: { background: &quot;#fff&quot;, color: void 0, fontSize: &quot;11px&quot;, fontFamily: void 0, fontWeight: 400, cssClass: &quot;&quot;, padding: { left: 5, right: 5, top: 2, bottom: 2 } } } }, this.text = { x: 0, y: 0, text: &quot;&quot;, textAnchor: &quot;start&quot;, foreColor: void 0, fontSize: &quot;13px&quot;, fontFamily: void 0, fontWeight: 400, appendTo: &quot;.apexcharts-annotations&quot;, backgroundColor: &quot;transparent&quot;, borderColor: &quot;#c2c2c2&quot;, borderRadius: 0, borderWidth: 0, paddingLeft: 4, paddingRight: 4, paddingTop: 2, paddingBottom: 2 };
  }
  return s(t2, [{ key: &quot;init&quot;, value: function() {
    return { annotations: { yaxis: [this.yAxisAnnotation], xaxis: [this.xAxisAnnotation], points: [this.pointAnnotation], texts: [], images: [], shapes: [] }, chart: { animations: { enabled: true, speed: 800, animateGradually: { delay: 150, enabled: true }, dynamicAnimation: { enabled: true, speed: 350 } }, background: &quot;&quot;, locales: [Hi], defaultLocale: &quot;en&quot;, dropShadow: { enabled: false, enabledOnSeries: void 0, top: 2, left: 2, blur: 4, color: &quot;#000&quot;, opacity: 0.7 }, events: { animationEnd: void 0, beforeMount: void 0, mounted: void 0, updated: void 0, click: void 0, mouseMove: void 0, mouseLeave: void 0, xAxisLabelClick: void 0, legendClick: void 0, markerClick: void 0, selection: void 0, dataPointSelection: void 0, dataPointMouseEnter: void 0, dataPointMouseLeave: void 0, beforeZoom: void 0, beforeResetZoom: void 0, zoomed: void 0, scrolled: void 0, brushScrolled: void 0 }, foreColor: &quot;#373d3f&quot;, fontFamily: &quot;Helvetica, Arial, sans-serif&quot;, height: &quot;auto&quot;, parentHeightOffset: 15, redrawOnParentResize: true, redrawOnWindowResize: true, id: void 0, group: void 0, nonce: void 0, offsetX: 0, offsetY: 0, selection: { enabled: false, type: &quot;x&quot;, fill: { color: &quot;#24292e&quot;, opacity: 0.1 }, stroke: { width: 1, color: &quot;#24292e&quot;, opacity: 0.4, dashArray: 3 }, xaxis: { min: void 0, max: void 0 }, yaxis: { min: void 0, max: void 0 } }, sparkline: { enabled: false }, brush: { enabled: false, autoScaleYaxis: true, target: void 0, targets: void 0 }, stacked: false, stackOnlyBar: true, stackType: &quot;normal&quot;, toolbar: { show: true, offsetX: 0, offsetY: 0, tools: { download: true, selection: true, zoom: true, zoomin: true, zoomout: true, pan: true, reset: true, customIcons: [] }, export: { csv: { filename: void 0, columnDelimiter: &quot;,&quot;, headerCategory: &quot;category&quot;, headerValue: &quot;value&quot;, categoryFormatter: void 0, valueFormatter: void 0 }, png: { filename: void 0 }, svg: { filename: void 0 }, scale: void 0, width: void 0 }, autoSelected: &quot;zoom&quot; }, type: &quot;line&quot;, width: &quot;100%&quot;, zoom: { enabled: true, type: &quot;x&quot;, autoScaleYaxis: false, allowMouseWheelZoom: true, zoomedArea: { fill: { color: &quot;#90CAF9&quot;, opacity: 0.4 }, stroke: { color: &quot;#0D47A1&quot;, opacity: 0.4, width: 1 } } } }, plotOptions: { line: { isSlopeChart: false, colors: { threshold: 0, colorAboveThreshold: void 0, colorBelowThreshold: void 0 } }, area: { fillTo: &quot;origin&quot; }, bar: { horizontal: false, columnWidth: &quot;70%&quot;, barHeight: &quot;70%&quot;, distributed: false, borderRadius: 0, borderRadiusApplication: &quot;around&quot;, borderRadiusWhenStacked: &quot;last&quot;, rangeBarOverlap: true, rangeBarGroupRows: false, hideZeroBarsWhenGrouped: false, isDumbbell: false, dumbbellColors: void 0, isFunnel: false, isFunnel3d: true, colors: { ranges: [], backgroundBarColors: [], backgroundBarOpacity: 1, backgroundBarRadius: 0 }, dataLabels: { position: &quot;top&quot;, maxItems: 100, hideOverflowingLabels: true, orientation: &quot;horizontal&quot;, total: { enabled: false, formatter: void 0, offsetX: 0, offsetY: 0, style: { color: &quot;#373d3f&quot;, fontSize: &quot;12px&quot;, fontFamily: void 0, fontWeight: 600 } } } }, bubble: { zScaling: true, minBubbleRadius: void 0, maxBubbleRadius: void 0 }, candlestick: { colors: { upward: &quot;#00B746&quot;, downward: &quot;#EF403C&quot; }, wick: { useFillColor: true } }, boxPlot: { colors: { upper: &quot;#00E396&quot;, lower: &quot;#008FFB&quot; } }, heatmap: { radius: 2, enableShades: true, shadeIntensity: 0.5, reverseNegativeShade: false, distributed: false, useFillColorAsStroke: false, colorScale: { inverse: false, ranges: [], min: void 0, max: void 0 } }, treemap: { enableShades: true, shadeIntensity: 0.5, distributed: false, reverseNegativeShade: false, useFillColorAsStroke: false, borderRadius: 4, dataLabels: { format: &quot;scale&quot; }, colorScale: { inverse: false, ranges: [], min: void 0, max: void 0 }, seriesTitle: { show: true, offsetY: 1, offsetX: 1, borderColor: &quot;#000&quot;, borderWidth: 1, borderRadius: 2, style: { background: &quot;rgba(0, 0, 0, 0.6)&quot;, color: &quot;#fff&quot;, fontSize: &quot;12px&quot;, fontFamily: void 0, fontWeight: 400, cssClass: &quot;&quot;, padding: { left: 6, right: 6, top: 2, bottom: 2 } } } }, radialBar: { inverseOrder: false, startAngle: 0, endAngle: 360, offsetX: 0, offsetY: 0, hollow: { margin: 5, size: &quot;50%&quot;, background: &quot;transparent&quot;, image: void 0, imageWidth: 150, imageHeight: 150, imageOffsetX: 0, imageOffsetY: 0, imageClipped: true, position: &quot;front&quot;, dropShadow: { enabled: false, top: 0, left: 0, blur: 3, color: &quot;#000&quot;, opacity: 0.5 } }, track: { show: true, startAngle: void 0, endAngle: void 0, background: &quot;#f2f2f2&quot;, strokeWidth: &quot;97%&quot;, opacity: 1, margin: 5, dropShadow: { enabled: false, top: 0, left: 0, blur: 3, color: &quot;#000&quot;, opacity: 0.5 } }, dataLabels: { show: true, name: { show: true, fontSize: &quot;16px&quot;, fontFamily: void 0, fontWeight: 600, color: void 0, offsetY: 0, formatter: function(t3) {
      return t3;
    } }, value: { show: true, fontSize: &quot;14px&quot;, fontFamily: void 0, fontWeight: 400, color: void 0, offsetY: 16, formatter: function(t3) {
      return t3 + &quot;%&quot;;
    } }, total: { show: false, label: &quot;Total&quot;, fontSize: &quot;16px&quot;, fontWeight: 600, fontFamily: void 0, color: void 0, formatter: function(t3) {
      return t3.globals.seriesTotals.reduce(function(t4, e2) {
        return t4 + e2;
      }, 0) / t3.globals.series.length + &quot;%&quot;;
    } } }, barLabels: { enabled: false, offsetX: 0, offsetY: 0, useSeriesColors: true, fontFamily: void 0, fontWeight: 600, fontSize: &quot;16px&quot;, formatter: function(t3) {
      return t3;
    }, onClick: void 0 } }, pie: { customScale: 1, offsetX: 0, offsetY: 0, startAngle: 0, endAngle: 360, expandOnClick: true, dataLabels: { offset: 0, minAngleToShowLabel: 10 }, donut: { size: &quot;65%&quot;, background: &quot;transparent&quot;, labels: { show: false, name: { show: true, fontSize: &quot;16px&quot;, fontFamily: void 0, fontWeight: 600, color: void 0, offsetY: -10, formatter: function(t3) {
      return t3;
    } }, value: { show: true, fontSize: &quot;20px&quot;, fontFamily: void 0, fontWeight: 400, color: void 0, offsetY: 10, formatter: function(t3) {
      return t3;
    } }, total: { show: false, showAlways: false, label: &quot;Total&quot;, fontSize: &quot;16px&quot;, fontWeight: 400, fontFamily: void 0, color: void 0, formatter: function(t3) {
      return t3.globals.seriesTotals.reduce(function(t4, e2) {
        return t4 + e2;
      }, 0);
    } } } } }, polarArea: { rings: { strokeWidth: 1, strokeColor: &quot;#e8e8e8&quot; }, spokes: { strokeWidth: 1, connectorColors: &quot;#e8e8e8&quot; } }, radar: { size: void 0, offsetX: 0, offsetY: 0, polygons: { strokeWidth: 1, strokeColors: &quot;#e8e8e8&quot;, connectorColors: &quot;#e8e8e8&quot;, fill: { colors: void 0 } } } }, colors: void 0, dataLabels: { enabled: true, enabledOnSeries: void 0, formatter: function(t3) {
      return null !== t3 ? t3 : &quot;&quot;;
    }, textAnchor: &quot;middle&quot;, distributed: false, offsetX: 0, offsetY: 0, style: { fontSize: &quot;12px&quot;, fontFamily: void 0, fontWeight: 600, colors: void 0 }, background: { enabled: true, foreColor: &quot;#fff&quot;, borderRadius: 2, padding: 4, opacity: 0.9, borderWidth: 1, borderColor: &quot;#fff&quot;, dropShadow: { enabled: false, top: 1, left: 1, blur: 1, color: &quot;#000&quot;, opacity: 0.8 } }, dropShadow: { enabled: false, top: 1, left: 1, blur: 1, color: &quot;#000&quot;, opacity: 0.8 } }, fill: { type: &quot;solid&quot;, colors: void 0, opacity: 0.85, gradient: { shade: &quot;dark&quot;, type: &quot;horizontal&quot;, shadeIntensity: 0.5, gradientToColors: void 0, inverseColors: true, opacityFrom: 1, opacityTo: 1, stops: [0, 50, 100], colorStops: [] }, image: { src: [], width: void 0, height: void 0 }, pattern: { style: &quot;squares&quot;, width: 6, height: 6, strokeWidth: 2 } }, forecastDataPoints: { count: 0, fillOpacity: 0.5, strokeWidth: void 0, dashArray: 4 }, grid: { show: true, borderColor: &quot;#e0e0e0&quot;, strokeDashArray: 0, position: &quot;back&quot;, xaxis: { lines: { show: false } }, yaxis: { lines: { show: true } }, row: { colors: void 0, opacity: 0.5 }, column: { colors: void 0, opacity: 0.5 }, padding: { top: 0, right: 10, bottom: 0, left: 12 } }, labels: [], legend: { show: true, showForSingleSeries: false, showForNullSeries: true, showForZeroSeries: true, floating: false, position: &quot;bottom&quot;, horizontalAlign: &quot;center&quot;, inverseOrder: false, fontSize: &quot;12px&quot;, fontFamily: void 0, fontWeight: 400, width: void 0, height: void 0, formatter: void 0, tooltipHoverFormatter: void 0, offsetX: -20, offsetY: 4, customLegendItems: [], clusterGroupedSeries: true, clusterGroupedSeriesOrientation: &quot;vertical&quot;, labels: { colors: void 0, useSeriesColors: false }, markers: { size: 7, fillColors: void 0, strokeWidth: 1, shape: void 0, offsetX: 0, offsetY: 0, customHTML: void 0, onClick: void 0 }, itemMargin: { horizontal: 5, vertical: 4 }, onItemClick: { toggleDataSeries: true }, onItemHover: { highlightDataSeries: true } }, markers: { discrete: [], size: 0, colors: void 0, strokeColors: &quot;#fff&quot;, strokeWidth: 2, strokeOpacity: 0.9, strokeDashArray: 0, fillOpacity: 1, shape: &quot;circle&quot;, offsetX: 0, offsetY: 0, showNullDataPoints: true, onClick: void 0, onDblClick: void 0, hover: { size: void 0, sizeOffset: 3 } }, noData: { text: void 0, align: &quot;center&quot;, verticalAlign: &quot;middle&quot;, offsetX: 0, offsetY: 0, style: { color: void 0, fontSize: &quot;14px&quot;, fontFamily: void 0 } }, responsive: [], series: void 0, states: { hover: { filter: { type: &quot;lighten&quot; } }, active: { allowMultipleDataPointsSelection: false, filter: { type: &quot;darken&quot; } } }, title: { text: void 0, align: &quot;left&quot;, margin: 5, offsetX: 0, offsetY: 0, floating: false, style: { fontSize: &quot;14px&quot;, fontWeight: 900, fontFamily: void 0, color: void 0 } }, subtitle: { text: void 0, align: &quot;left&quot;, margin: 5, offsetX: 0, offsetY: 30, floating: false, style: { fontSize: &quot;12px&quot;, fontWeight: 400, fontFamily: void 0, color: void 0 } }, stroke: { show: true, curve: &quot;smooth&quot;, lineCap: &quot;butt&quot;, width: 2, colors: void 0, dashArray: 0, fill: { type: &quot;solid&quot;, colors: void 0, opacity: 0.85, gradient: { shade: &quot;dark&quot;, type: &quot;horizontal&quot;, shadeIntensity: 0.5, gradientToColors: void 0, inverseColors: true, opacityFrom: 1, opacityTo: 1, stops: [0, 50, 100], colorStops: [] } } }, tooltip: { enabled: true, enabledOnSeries: void 0, shared: true, hideEmptySeries: false, followCursor: false, intersect: false, inverseOrder: false, custom: void 0, fillSeriesColor: false, theme: &quot;light&quot;, cssClass: &quot;&quot;, style: { fontSize: &quot;12px&quot;, fontFamily: void 0 }, onDatasetHover: { highlightDataSeries: false }, x: { show: true, format: &quot;dd MMM&quot;, formatter: void 0 }, y: { formatter: void 0, title: { formatter: function(t3) {
      return t3 ? t3 + &quot;: &quot; : &quot;&quot;;
    } } }, z: { formatter: void 0, title: &quot;Size: &quot; }, marker: { show: true, fillColors: void 0 }, items: { display: &quot;flex&quot; }, fixed: { enabled: false, position: &quot;topRight&quot;, offsetX: 0, offsetY: 0 } }, xaxis: { type: &quot;category&quot;, categories: [], convertedCatToNumeric: false, offsetX: 0, offsetY: 0, overwriteCategories: void 0, labels: { show: true, rotate: -45, rotateAlways: false, hideOverlappingLabels: true, trim: false, minHeight: void 0, maxHeight: 120, showDuplicates: true, style: { colors: [], fontSize: &quot;12px&quot;, fontWeight: 400, fontFamily: void 0, cssClass: &quot;&quot; }, offsetX: 0, offsetY: 0, format: void 0, formatter: void 0, datetimeUTC: true, datetimeFormatter: { year: &quot;yyyy&quot;, month: &quot;MMM &#x27;yy&quot;, day: &quot;dd MMM&quot;, hour: &quot;HH:mm&quot;, minute: &quot;HH:mm:ss&quot;, second: &quot;HH:mm:ss&quot; } }, group: { groups: [], style: { colors: [], fontSize: &quot;12px&quot;, fontWeight: 400, fontFamily: void 0, cssClass: &quot;&quot; } }, axisBorder: { show: true, color: &quot;#e0e0e0&quot;, width: &quot;100%&quot;, height: 1, offsetX: 0, offsetY: 0 }, axisTicks: { show: true, color: &quot;#e0e0e0&quot;, height: 6, offsetX: 0, offsetY: 0 }, stepSize: void 0, tickAmount: void 0, tickPlacement: &quot;on&quot;, min: void 0, max: void 0, range: void 0, floating: false, decimalsInFloat: void 0, position: &quot;bottom&quot;, title: { text: void 0, offsetX: 0, offsetY: 0, style: { color: void 0, fontSize: &quot;12px&quot;, fontWeight: 900, fontFamily: void 0, cssClass: &quot;&quot; } }, crosshairs: { show: true, width: 1, position: &quot;back&quot;, opacity: 0.9, stroke: { color: &quot;#b6b6b6&quot;, width: 1, dashArray: 3 }, fill: { type: &quot;solid&quot;, color: &quot;#B1B9C4&quot;, gradient: { colorFrom: &quot;#D8E3F0&quot;, colorTo: &quot;#BED1E6&quot;, stops: [0, 100], opacityFrom: 0.4, opacityTo: 0.5 } }, dropShadow: { enabled: false, left: 0, top: 0, blur: 1, opacity: 0.8 } }, tooltip: { enabled: true, offsetY: 0, formatter: void 0, style: { fontSize: &quot;12px&quot;, fontFamily: void 0 } } }, yaxis: this.yAxis, theme: { mode: &quot;&quot;, palette: &quot;palette1&quot;, monochrome: { enabled: false, color: &quot;#008FFB&quot;, shadeTo: &quot;light&quot;, shadeIntensity: 0.65 } } };
  } }]), t2;
}();
var Fi = function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w, this.graphics = new Mi(this.ctx), this.w.globals.isBarHorizontal &amp;&amp; (this.invertAxis = true), this.helpers = new Ii(this), this.xAxisAnnotations = new Ti(this), this.yAxisAnnotations = new Ei(this), this.pointsAnnotations = new Yi(this), this.w.globals.isBarHorizontal &amp;&amp; this.w.config.yaxis[0].reversed &amp;&amp; (this.inversedReversedAxis = true), this.xDivision = this.w.globals.gridWidth / this.w.globals.dataPoints;
  }
  return s(t2, [{ key: &quot;drawAxesAnnotations&quot;, value: function() {
    var t3 = this.w;
    if (t3.globals.axisCharts &amp;&amp; t3.globals.dataPoints) {
      for (var e2 = this.yAxisAnnotations.drawYAxisAnnotations(), i2 = this.xAxisAnnotations.drawXAxisAnnotations(), a2 = this.pointsAnnotations.drawPointAnnotations(), s2 = t3.config.chart.animations.enabled, r2 = [e2, i2, a2], n2 = [i2.node, e2.node, a2.node], o2 = 0; o2 &lt; 3; o2++) t3.globals.dom.elGraphical.add(r2[o2]), !s2 || t3.globals.resized || t3.globals.dataChanged || &quot;scatter&quot; !== t3.config.chart.type &amp;&amp; &quot;bubble&quot; !== t3.config.chart.type &amp;&amp; t3.globals.dataPoints &gt; 1 &amp;&amp; n2[o2].classList.add(&quot;apexcharts-element-hidden&quot;), t3.globals.delayedElements.push({ el: n2[o2], index: 0 });
      this.helpers.annotationsBackground();
    }
  } }, { key: &quot;drawImageAnnos&quot;, value: function() {
    var t3 = this;
    this.w.config.annotations.images.map(function(e2, i2) {
      t3.addImage(e2, i2);
    });
  } }, { key: &quot;drawTextAnnos&quot;, value: function() {
    var t3 = this;
    this.w.config.annotations.texts.map(function(e2, i2) {
      t3.addText(e2, i2);
    });
  } }, { key: &quot;addXaxisAnnotation&quot;, value: function(t3, e2, i2) {
    this.xAxisAnnotations.addXaxisAnnotation(t3, e2, i2);
  } }, { key: &quot;addYaxisAnnotation&quot;, value: function(t3, e2, i2) {
    this.yAxisAnnotations.addYaxisAnnotation(t3, e2, i2);
  } }, { key: &quot;addPointAnnotation&quot;, value: function(t3, e2, i2) {
    this.pointsAnnotations.addPointAnnotation(t3, e2, i2);
  } }, { key: &quot;addText&quot;, value: function(t3, e2) {
    var i2 = t3.x, a2 = t3.y, s2 = t3.text, r2 = t3.textAnchor, n2 = t3.foreColor, o2 = t3.fontSize, l2 = t3.fontFamily, h2 = t3.fontWeight, c2 = t3.cssClass, d2 = t3.backgroundColor, u2 = t3.borderWidth, g2 = t3.strokeDashArray, p2 = t3.borderRadius, f2 = t3.borderColor, x2 = t3.appendTo, b2 = void 0 === x2 ? &quot;.apexcharts-svg&quot; : x2, m2 = t3.paddingLeft, v2 = void 0 === m2 ? 4 : m2, y2 = t3.paddingRight, w2 = void 0 === y2 ? 4 : y2, k2 = t3.paddingBottom, A2 = void 0 === k2 ? 2 : k2, C2 = t3.paddingTop, S2 = void 0 === C2 ? 2 : C2, L2 = this.w, M2 = this.graphics.drawText({ x: i2, y: a2, text: s2, textAnchor: r2 || &quot;start&quot;, fontSize: o2 || &quot;12px&quot;, fontWeight: h2 || &quot;regular&quot;, fontFamily: l2 || L2.config.chart.fontFamily, foreColor: n2 || L2.config.chart.foreColor, cssClass: c2 }), P2 = L2.globals.dom.baseEl.querySelector(b2);
    P2 &amp;&amp; P2.appendChild(M2.node);
    var I2 = M2.bbox();
    if (s2) {
      var T2 = this.graphics.drawRect(I2.x - v2, I2.y - S2, I2.width + v2 + w2, I2.height + A2 + S2, p2, d2 || &quot;transparent&quot;, 1, u2, f2, g2);
      P2.insertBefore(T2.node, M2.node);
    }
  } }, { key: &quot;addImage&quot;, value: function(t3, e2) {
    var i2 = this.w, a2 = t3.path, s2 = t3.x, r2 = void 0 === s2 ? 0 : s2, n2 = t3.y, o2 = void 0 === n2 ? 0 : n2, l2 = t3.width, h2 = void 0 === l2 ? 20 : l2, c2 = t3.height, d2 = void 0 === c2 ? 20 : c2, u2 = t3.appendTo, g2 = void 0 === u2 ? &quot;.apexcharts-svg&quot; : u2, p2 = i2.globals.dom.Paper.image(a2);
    p2.size(h2, d2).move(r2, o2);
    var f2 = i2.globals.dom.baseEl.querySelector(g2);
    return f2 &amp;&amp; f2.appendChild(p2.node), p2;
  } }, { key: &quot;addXaxisAnnotationExternal&quot;, value: function(t3, e2, i2) {
    return this.addAnnotationExternal({ params: t3, pushToMemory: e2, context: i2, type: &quot;xaxis&quot;, contextMethod: i2.addXaxisAnnotation }), i2;
  } }, { key: &quot;addYaxisAnnotationExternal&quot;, value: function(t3, e2, i2) {
    return this.addAnnotationExternal({ params: t3, pushToMemory: e2, context: i2, type: &quot;yaxis&quot;, contextMethod: i2.addYaxisAnnotation }), i2;
  } }, { key: &quot;addPointAnnotationExternal&quot;, value: function(t3, e2, i2) {
    return void 0 === this.invertAxis &amp;&amp; (this.invertAxis = i2.w.globals.isBarHorizontal), this.addAnnotationExternal({ params: t3, pushToMemory: e2, context: i2, type: &quot;point&quot;, contextMethod: i2.addPointAnnotation }), i2;
  } }, { key: &quot;addAnnotationExternal&quot;, value: function(t3) {
    var e2 = t3.params, i2 = t3.pushToMemory, a2 = t3.context, s2 = t3.type, r2 = t3.contextMethod, n2 = a2, o2 = n2.w, l2 = o2.globals.dom.baseEl.querySelector(&quot;.apexcharts-&quot;.concat(s2, &quot;-annotations&quot;)), h2 = l2.childNodes.length + 1, c2 = new Oi(), d2 = Object.assign({}, &quot;xaxis&quot; === s2 ? c2.xAxisAnnotation : &quot;yaxis&quot; === s2 ? c2.yAxisAnnotation : c2.pointAnnotation), u2 = v.extend(d2, e2);
    switch (s2) {
      case &quot;xaxis&quot;:
        this.addXaxisAnnotation(u2, l2, h2);
        break;
      case &quot;yaxis&quot;:
        this.addYaxisAnnotation(u2, l2, h2);
        break;
      case &quot;point&quot;:
        this.addPointAnnotation(u2, l2, h2);
    }
    var g2 = o2.globals.dom.baseEl.querySelector(&quot;.apexcharts-&quot;.concat(s2, &quot;-annotations .apexcharts-&quot;).concat(s2, &quot;-annotation-label[rel=&#x27;&quot;).concat(h2, &quot;&#x27;]&quot;)), p2 = this.helpers.addBackgroundToAnno(g2, u2);
    return p2 &amp;&amp; l2.insertBefore(p2.node, g2), i2 &amp;&amp; o2.globals.memory.methodsToExec.push({ context: n2, id: u2.id ? u2.id : v.randomId(), method: r2, label: &quot;addAnnotation&quot;, params: e2 }), a2;
  } }, { key: &quot;clearAnnotations&quot;, value: function(t3) {
    for (var e2 = t3.w, i2 = e2.globals.dom.baseEl.querySelectorAll(&quot;.apexcharts-yaxis-annotations, .apexcharts-xaxis-annotations, .apexcharts-point-annotations&quot;), a2 = e2.globals.memory.methodsToExec.length - 1; a2 &gt;= 0; a2--) &quot;addText&quot; !== e2.globals.memory.methodsToExec[a2].label &amp;&amp; &quot;addAnnotation&quot; !== e2.globals.memory.methodsToExec[a2].label || e2.globals.memory.methodsToExec.splice(a2, 1);
    i2 = v.listToArray(i2), Array.prototype.forEach.call(i2, function(t4) {
      for (; t4.firstChild; ) t4.removeChild(t4.firstChild);
    });
  } }, { key: &quot;removeAnnotation&quot;, value: function(t3, e2) {
    var i2 = t3.w, a2 = i2.globals.dom.baseEl.querySelectorAll(&quot;.&quot;.concat(e2));
    a2 &amp;&amp; (i2.globals.memory.methodsToExec.map(function(t4, a3) {
      t4.id === e2 &amp;&amp; i2.globals.memory.methodsToExec.splice(a3, 1);
    }), Array.prototype.forEach.call(a2, function(t4) {
      t4.parentElement.removeChild(t4);
    }));
  } }]), t2;
}();
var Di = function(t2) {
  var e2, i2 = t2.isTimeline, a2 = t2.ctx, s2 = t2.seriesIndex, r2 = t2.dataPointIndex, n2 = t2.y1, o2 = t2.y2, l2 = t2.w, h2 = l2.globals.seriesRangeStart[s2][r2], c2 = l2.globals.seriesRangeEnd[s2][r2], d2 = l2.globals.labels[r2], u2 = l2.config.series[s2].name ? l2.config.series[s2].name : &quot;&quot;, g2 = l2.globals.ttKeyFormatter, p2 = l2.config.tooltip.y.title.formatter, f2 = { w: l2, seriesIndex: s2, dataPointIndex: r2, start: h2, end: c2 };
  (&quot;function&quot; == typeof p2 &amp;&amp; (u2 = p2(u2, f2)), null !== (e2 = l2.config.series[s2].data[r2]) &amp;&amp; void 0 !== e2 &amp;&amp; e2.x &amp;&amp; (d2 = l2.config.series[s2].data[r2].x), i2) || &quot;datetime&quot; === l2.config.xaxis.type &amp;&amp; (d2 = new Xi(a2).xLabelFormat(l2.globals.ttKeyFormatter, d2, d2, { i: void 0, dateFormatter: new zi(a2).formatDate, w: l2 }));
  &quot;function&quot; == typeof g2 &amp;&amp; (d2 = g2(d2, f2)), Number.isFinite(n2) &amp;&amp; Number.isFinite(o2) &amp;&amp; (h2 = n2, c2 = o2);
  var x2 = &quot;&quot;, b2 = &quot;&quot;, m2 = l2.globals.colors[s2];
  if (void 0 === l2.config.tooltip.x.formatter) if (&quot;datetime&quot; === l2.config.xaxis.type) {
    var v2 = new zi(a2);
    x2 = v2.formatDate(v2.getDate(h2), l2.config.tooltip.x.format), b2 = v2.formatDate(v2.getDate(c2), l2.config.tooltip.x.format);
  } else x2 = h2, b2 = c2;
  else x2 = l2.config.tooltip.x.formatter(h2), b2 = l2.config.tooltip.x.formatter(c2);
  return { start: h2, end: c2, startVal: x2, endVal: b2, ylabel: d2, color: m2, seriesName: u2 };
};
var _i = function(t2) {
  var e2 = t2.color, i2 = t2.seriesName, a2 = t2.ylabel, s2 = t2.start, r2 = t2.end, n2 = t2.seriesIndex, o2 = t2.dataPointIndex, l2 = t2.ctx.tooltip.tooltipLabels.getFormatters(n2);
  s2 = l2.yLbFormatter(s2), r2 = l2.yLbFormatter(r2);
  var h2 = l2.yLbFormatter(t2.w.globals.series[n2][o2]), c2 = &#x27;&lt;span class=&quot;value start-value&quot;&gt;\n  &#x27;.concat(s2, &#x27;\n  &lt;/span&gt; &lt;span class=&quot;separator&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;value end-value&quot;&gt;\n  &#x27;).concat(r2, &quot;\n  &lt;/span&gt;&quot;);
  return &#x27;&lt;div class=&quot;apexcharts-tooltip-rangebar&quot;&gt;&lt;div&gt; &lt;span class=&quot;series-name&quot; style=&quot;color: &#x27; + e2 + &#x27;&quot;&gt;&#x27; + (i2 || &quot;&quot;) + &#x27;&lt;/span&gt;&lt;/div&gt;&lt;div&gt; &lt;span class=&quot;category&quot;&gt;&#x27; + a2 + &quot;: &lt;/span&gt; &quot; + (t2.w.globals.comboCharts ? &quot;rangeArea&quot; === t2.w.config.series[n2].type || &quot;rangeBar&quot; === t2.w.config.series[n2].type ? c2 : &quot;&lt;span&gt;&quot;.concat(h2, &quot;&lt;/span&gt;&quot;) : c2) + &quot; &lt;/div&gt;&lt;/div&gt;&quot;;
};
var Ni = function() {
  function t2(e2) {
    i(this, t2), this.opts = e2;
  }
  return s(t2, [{ key: &quot;hideYAxis&quot;, value: function() {
    this.opts.yaxis[0].show = false, this.opts.yaxis[0].title.text = &quot;&quot;, this.opts.yaxis[0].axisBorder.show = false, this.opts.yaxis[0].axisTicks.show = false, this.opts.yaxis[0].floating = true;
  } }, { key: &quot;line&quot;, value: function() {
    return { dataLabels: { enabled: false }, stroke: { width: 5, curve: &quot;straight&quot; }, markers: { size: 0, hover: { sizeOffset: 6 } }, xaxis: { crosshairs: { width: 1 } } };
  } }, { key: &quot;sparkline&quot;, value: function(t3) {
    this.hideYAxis();
    return v.extend(t3, { grid: { show: false, padding: { left: 0, right: 0, top: 0, bottom: 0 } }, legend: { show: false }, xaxis: { labels: { show: false }, tooltip: { enabled: false }, axisBorder: { show: false }, axisTicks: { show: false } }, chart: { toolbar: { show: false }, zoom: { enabled: false } }, dataLabels: { enabled: false } });
  } }, { key: &quot;slope&quot;, value: function() {
    return this.hideYAxis(), { chart: { toolbar: { show: false }, zoom: { enabled: false } }, dataLabels: { enabled: true, formatter: function(t3, e2) {
      var i2 = e2.w.config.series[e2.seriesIndex].name;
      return null !== t3 ? i2 + &quot;: &quot; + t3 : &quot;&quot;;
    }, background: { enabled: false }, offsetX: -5 }, grid: { xaxis: { lines: { show: true } }, yaxis: { lines: { show: false } } }, xaxis: { position: &quot;top&quot;, labels: { style: { fontSize: 14, fontWeight: 900 } }, tooltip: { enabled: false }, crosshairs: { show: false } }, markers: { size: 8, hover: { sizeOffset: 1 } }, legend: { show: false }, tooltip: { shared: false, intersect: true, followCursor: true }, stroke: { width: 5, curve: &quot;straight&quot; } };
  } }, { key: &quot;bar&quot;, value: function() {
    return { chart: { stacked: false }, plotOptions: { bar: { dataLabels: { position: &quot;center&quot; } } }, dataLabels: { style: { colors: [&quot;#fff&quot;] }, background: { enabled: false } }, stroke: { width: 0, lineCap: &quot;square&quot; }, fill: { opacity: 0.85 }, legend: { markers: { shape: &quot;square&quot; } }, tooltip: { shared: false, intersect: true }, xaxis: { tooltip: { enabled: false }, tickPlacement: &quot;between&quot;, crosshairs: { width: &quot;barWidth&quot;, position: &quot;back&quot;, fill: { type: &quot;gradient&quot; }, dropShadow: { enabled: false }, stroke: { width: 0 } } } };
  } }, { key: &quot;funnel&quot;, value: function() {
    return this.hideYAxis(), u(u({}, this.bar()), {}, { chart: { animations: { speed: 800, animateGradually: { enabled: false } } }, plotOptions: { bar: { horizontal: true, borderRadiusApplication: &quot;around&quot;, borderRadius: 0, dataLabels: { position: &quot;center&quot; } } }, grid: { show: false, padding: { left: 0, right: 0 } }, xaxis: { labels: { show: false }, tooltip: { enabled: false }, axisBorder: { show: false }, axisTicks: { show: false } } });
  } }, { key: &quot;candlestick&quot;, value: function() {
    var t3 = this;
    return { stroke: { width: 1, colors: [&quot;#333&quot;] }, fill: { opacity: 1 }, dataLabels: { enabled: false }, tooltip: { shared: true, custom: function(e2) {
      var i2 = e2.seriesIndex, a2 = e2.dataPointIndex, s2 = e2.w;
      return t3._getBoxTooltip(s2, i2, a2, [&quot;Open&quot;, &quot;High&quot;, &quot;&quot;, &quot;Low&quot;, &quot;Close&quot;], &quot;candlestick&quot;);
    } }, states: { active: { filter: { type: &quot;none&quot; } } }, xaxis: { crosshairs: { width: 1 } } };
  } }, { key: &quot;boxPlot&quot;, value: function() {
    var t3 = this;
    return { chart: { animations: { dynamicAnimation: { enabled: false } } }, stroke: { width: 1, colors: [&quot;#24292e&quot;] }, dataLabels: { enabled: false }, tooltip: { shared: true, custom: function(e2) {
      var i2 = e2.seriesIndex, a2 = e2.dataPointIndex, s2 = e2.w;
      return t3._getBoxTooltip(s2, i2, a2, [&quot;Minimum&quot;, &quot;Q1&quot;, &quot;Median&quot;, &quot;Q3&quot;, &quot;Maximum&quot;], &quot;boxPlot&quot;);
    } }, markers: { size: 7, strokeWidth: 1, strokeColors: &quot;#111&quot; }, xaxis: { crosshairs: { width: 1 } } };
  } }, { key: &quot;rangeBar&quot;, value: function() {
    return { chart: { animations: { animateGradually: false } }, stroke: { width: 0, lineCap: &quot;square&quot; }, plotOptions: { bar: { borderRadius: 0, dataLabels: { position: &quot;center&quot; } } }, dataLabels: { enabled: false, formatter: function(t3, e2) {
      e2.ctx;
      var i2 = e2.seriesIndex, a2 = e2.dataPointIndex, s2 = e2.w, r2 = function() {
        var t4 = s2.globals.seriesRangeStart[i2][a2];
        return s2.globals.seriesRangeEnd[i2][a2] - t4;
      };
      return s2.globals.comboCharts ? &quot;rangeBar&quot; === s2.config.series[i2].type || &quot;rangeArea&quot; === s2.config.series[i2].type ? r2() : t3 : r2();
    }, background: { enabled: false }, style: { colors: [&quot;#fff&quot;] } }, markers: { size: 10 }, tooltip: { shared: false, followCursor: true, custom: function(t3) {
      return t3.w.config.plotOptions &amp;&amp; t3.w.config.plotOptions.bar &amp;&amp; t3.w.config.plotOptions.bar.horizontal ? function(t4) {
        var e2 = Di(u(u({}, t4), {}, { isTimeline: true })), i2 = e2.color, a2 = e2.seriesName, s2 = e2.ylabel, r2 = e2.startVal, n2 = e2.endVal;
        return _i(u(u({}, t4), {}, { color: i2, seriesName: a2, ylabel: s2, start: r2, end: n2 }));
      }(t3) : function(t4) {
        var e2 = Di(t4), i2 = e2.color, a2 = e2.seriesName, s2 = e2.ylabel, r2 = e2.start, n2 = e2.end;
        return _i(u(u({}, t4), {}, { color: i2, seriesName: a2, ylabel: s2, start: r2, end: n2 }));
      }(t3);
    } }, xaxis: { tickPlacement: &quot;between&quot;, tooltip: { enabled: false }, crosshairs: { stroke: { width: 0 } } } };
  } }, { key: &quot;dumbbell&quot;, value: function(t3) {
    var e2, i2;
    return null !== (e2 = t3.plotOptions.bar) &amp;&amp; void 0 !== e2 &amp;&amp; e2.barHeight || (t3.plotOptions.bar.barHeight = 2), null !== (i2 = t3.plotOptions.bar) &amp;&amp; void 0 !== i2 &amp;&amp; i2.columnWidth || (t3.plotOptions.bar.columnWidth = 2), t3;
  } }, { key: &quot;area&quot;, value: function() {
    return { stroke: { width: 4, fill: { type: &quot;solid&quot;, gradient: { inverseColors: false, shade: &quot;light&quot;, type: &quot;vertical&quot;, opacityFrom: 0.65, opacityTo: 0.5, stops: [0, 100, 100] } } }, fill: { type: &quot;gradient&quot;, gradient: { inverseColors: false, shade: &quot;light&quot;, type: &quot;vertical&quot;, opacityFrom: 0.65, opacityTo: 0.5, stops: [0, 100, 100] } }, markers: { size: 0, hover: { sizeOffset: 6 } }, tooltip: { followCursor: false } };
  } }, { key: &quot;rangeArea&quot;, value: function() {
    return { stroke: { curve: &quot;straight&quot;, width: 0 }, fill: { type: &quot;solid&quot;, opacity: 0.6 }, markers: { size: 0 }, states: { hover: { filter: { type: &quot;none&quot; } }, active: { filter: { type: &quot;none&quot; } } }, tooltip: { intersect: false, shared: true, followCursor: true, custom: function(t3) {
      return function(t4) {
        var e2 = Di(t4), i2 = e2.color, a2 = e2.seriesName, s2 = e2.ylabel, r2 = e2.start, n2 = e2.end;
        return _i(u(u({}, t4), {}, { color: i2, seriesName: a2, ylabel: s2, start: r2, end: n2 }));
      }(t3);
    } } };
  } }, { key: &quot;brush&quot;, value: function(t3) {
    return v.extend(t3, { chart: { toolbar: { autoSelected: &quot;selection&quot;, show: false }, zoom: { enabled: false } }, dataLabels: { enabled: false }, stroke: { width: 1 }, tooltip: { enabled: false }, xaxis: { tooltip: { enabled: false } } });
  } }, { key: &quot;stacked100&quot;, value: function(t3) {
    t3.dataLabels = t3.dataLabels || {}, t3.dataLabels.formatter = t3.dataLabels.formatter || void 0;
    var e2 = t3.dataLabels.formatter;
    return t3.yaxis.forEach(function(e3, i2) {
      t3.yaxis[i2].min = 0, t3.yaxis[i2].max = 100;
    }), &quot;bar&quot; === t3.chart.type &amp;&amp; (t3.dataLabels.formatter = e2 || function(t4) {
      return &quot;number&quot; == typeof t4 &amp;&amp; t4 ? t4.toFixed(0) + &quot;%&quot; : t4;
    }), t3;
  } }, { key: &quot;stackedBars&quot;, value: function() {
    var t3 = this.bar();
    return u(u({}, t3), {}, { plotOptions: u(u({}, t3.plotOptions), {}, { bar: u(u({}, t3.plotOptions.bar), {}, { borderRadiusApplication: &quot;end&quot;, borderRadiusWhenStacked: &quot;last&quot; }) }) });
  } }, { key: &quot;convertCatToNumeric&quot;, value: function(t3) {
    return t3.xaxis.convertedCatToNumeric = true, t3;
  } }, { key: &quot;convertCatToNumericXaxis&quot;, value: function(t3, e2, i2) {
    t3.xaxis.type = &quot;numeric&quot;, t3.xaxis.labels = t3.xaxis.labels || {}, t3.xaxis.labels.formatter = t3.xaxis.labels.formatter || function(t4) {
      return v.isNumber(t4) ? Math.floor(t4) : t4;
    };
    var a2 = t3.xaxis.labels.formatter, s2 = t3.xaxis.categories &amp;&amp; t3.xaxis.categories.length ? t3.xaxis.categories : t3.labels;
    return i2 &amp;&amp; i2.length &amp;&amp; (s2 = i2.map(function(t4) {
      return Array.isArray(t4) ? t4 : String(t4);
    })), s2 &amp;&amp; s2.length &amp;&amp; (t3.xaxis.labels.formatter = function(t4) {
      return v.isNumber(t4) ? a2(s2[Math.floor(t4) - 1]) : a2(t4);
    }), t3.xaxis.categories = [], t3.labels = [], t3.xaxis.tickAmount = t3.xaxis.tickAmount || &quot;dataPoints&quot;, t3;
  } }, { key: &quot;bubble&quot;, value: function() {
    return { dataLabels: { style: { colors: [&quot;#fff&quot;] } }, tooltip: { shared: false, intersect: true }, xaxis: { crosshairs: { width: 0 } }, fill: { type: &quot;solid&quot;, gradient: { shade: &quot;light&quot;, inverse: true, shadeIntensity: 0.55, opacityFrom: 0.4, opacityTo: 0.8 } } };
  } }, { key: &quot;scatter&quot;, value: function() {
    return { dataLabels: { enabled: false }, tooltip: { shared: false, intersect: true }, markers: { size: 6, strokeWidth: 1, hover: { sizeOffset: 2 } } };
  } }, { key: &quot;heatmap&quot;, value: function() {
    return { chart: { stacked: false }, fill: { opacity: 1 }, dataLabels: { style: { colors: [&quot;#fff&quot;] } }, stroke: { colors: [&quot;#fff&quot;] }, tooltip: { followCursor: true, marker: { show: false }, x: { show: false } }, legend: { position: &quot;top&quot;, markers: { shape: &quot;square&quot; } }, grid: { padding: { right: 20 } } };
  } }, { key: &quot;treemap&quot;, value: function() {
    return { chart: { zoom: { enabled: false } }, dataLabels: { style: { fontSize: 14, fontWeight: 600, colors: [&quot;#fff&quot;] } }, stroke: { show: true, width: 2, colors: [&quot;#fff&quot;] }, legend: { show: false }, fill: { opacity: 1, gradient: { stops: [0, 100] } }, tooltip: { followCursor: true, x: { show: false } }, grid: { padding: { left: 0, right: 0 } }, xaxis: { crosshairs: { show: false }, tooltip: { enabled: false } } };
  } }, { key: &quot;pie&quot;, value: function() {
    return { chart: { toolbar: { show: false } }, plotOptions: { pie: { donut: { labels: { show: false } } } }, dataLabels: { formatter: function(t3) {
      return t3.toFixed(1) + &quot;%&quot;;
    }, style: { colors: [&quot;#fff&quot;] }, background: { enabled: false }, dropShadow: { enabled: true } }, stroke: { colors: [&quot;#fff&quot;] }, fill: { opacity: 1, gradient: { shade: &quot;light&quot;, stops: [0, 100] } }, tooltip: { theme: &quot;dark&quot;, fillSeriesColor: true }, legend: { position: &quot;right&quot; }, grid: { padding: { left: 0, right: 0, top: 0, bottom: 0 } } };
  } }, { key: &quot;donut&quot;, value: function() {
    return { chart: { toolbar: { show: false } }, dataLabels: { formatter: function(t3) {
      return t3.toFixed(1) + &quot;%&quot;;
    }, style: { colors: [&quot;#fff&quot;] }, background: { enabled: false }, dropShadow: { enabled: true } }, stroke: { colors: [&quot;#fff&quot;] }, fill: { opacity: 1, gradient: { shade: &quot;light&quot;, shadeIntensity: 0.35, stops: [80, 100], opacityFrom: 1, opacityTo: 1 } }, tooltip: { theme: &quot;dark&quot;, fillSeriesColor: true }, legend: { position: &quot;right&quot; }, grid: { padding: { left: 0, right: 0, top: 0, bottom: 0 } } };
  } }, { key: &quot;polarArea&quot;, value: function() {
    return { chart: { toolbar: { show: false } }, dataLabels: { formatter: function(t3) {
      return t3.toFixed(1) + &quot;%&quot;;
    }, enabled: false }, stroke: { show: true, width: 2 }, fill: { opacity: 0.7 }, tooltip: { theme: &quot;dark&quot;, fillSeriesColor: true }, legend: { position: &quot;right&quot; }, grid: { padding: { left: 0, right: 0, top: 0, bottom: 0 } } };
  } }, { key: &quot;radar&quot;, value: function() {
    return this.opts.yaxis[0].labels.offsetY = this.opts.yaxis[0].labels.offsetY ? this.opts.yaxis[0].labels.offsetY : 6, { dataLabels: { enabled: false, style: { fontSize: &quot;11px&quot; } }, stroke: { width: 2 }, markers: { size: 5, strokeWidth: 1, strokeOpacity: 1 }, fill: { opacity: 0.2 }, tooltip: { shared: false, intersect: true, followCursor: true }, grid: { show: false, padding: { left: 0, right: 0, top: 0, bottom: 0 } }, xaxis: { labels: { formatter: function(t3) {
      return t3;
    }, style: { colors: [&quot;#a8a8a8&quot;], fontSize: &quot;11px&quot; } }, tooltip: { enabled: false }, crosshairs: { show: false } } };
  } }, { key: &quot;radialBar&quot;, value: function() {
    return { chart: { animations: { dynamicAnimation: { enabled: true, speed: 800 } }, toolbar: { show: false } }, fill: { gradient: { shade: &quot;dark&quot;, shadeIntensity: 0.4, inverseColors: false, type: &quot;diagonal2&quot;, opacityFrom: 1, opacityTo: 1, stops: [70, 98, 100] } }, legend: { show: false, position: &quot;right&quot; }, tooltip: { enabled: false, fillSeriesColor: true }, grid: { padding: { left: 0, right: 0, top: 0, bottom: 0 } } };
  } }, { key: &quot;_getBoxTooltip&quot;, value: function(t3, e2, i2, a2, s2) {
    var r2 = t3.globals.seriesCandleO[e2][i2], n2 = t3.globals.seriesCandleH[e2][i2], o2 = t3.globals.seriesCandleM[e2][i2], l2 = t3.globals.seriesCandleL[e2][i2], h2 = t3.globals.seriesCandleC[e2][i2];
    return t3.config.series[e2].type &amp;&amp; t3.config.series[e2].type !== s2 ? &#x27;&lt;div class=&quot;apexcharts-custom-tooltip&quot;&gt;\n          &#x27;.concat(t3.config.series[e2].name ? t3.config.series[e2].name : &quot;series-&quot; + (e2 + 1), &quot;: &lt;strong&gt;&quot;).concat(t3.globals.series[e2][i2], &quot;&lt;/strong&gt;\n        &lt;/div&gt;&quot;) : &#x27;&lt;div class=&quot;apexcharts-tooltip-box apexcharts-tooltip-&#x27;.concat(t3.config.chart.type, &#x27;&quot;&gt;&#x27;) + &quot;&lt;div&gt;&quot;.concat(a2[0], &#x27;: &lt;span class=&quot;value&quot;&gt;&#x27;) + r2 + &quot;&lt;/span&gt;&lt;/div&gt;&quot; + &quot;&lt;div&gt;&quot;.concat(a2[1], &#x27;: &lt;span class=&quot;value&quot;&gt;&#x27;) + n2 + &quot;&lt;/span&gt;&lt;/div&gt;&quot; + (o2 ? &quot;&lt;div&gt;&quot;.concat(a2[2], &#x27;: &lt;span class=&quot;value&quot;&gt;&#x27;) + o2 + &quot;&lt;/span&gt;&lt;/div&gt;&quot; : &quot;&quot;) + &quot;&lt;div&gt;&quot;.concat(a2[3], &#x27;: &lt;span class=&quot;value&quot;&gt;&#x27;) + l2 + &quot;&lt;/span&gt;&lt;/div&gt;&quot; + &quot;&lt;div&gt;&quot;.concat(a2[4], &#x27;: &lt;span class=&quot;value&quot;&gt;&#x27;) + h2 + &quot;&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;&quot;;
  } }]), t2;
}();
var Wi = function() {
  function t2(e2) {
    i(this, t2), this.opts = e2;
  }
  return s(t2, [{ key: &quot;init&quot;, value: function(t3) {
    var e2 = t3.responsiveOverride, i2 = this.opts, a2 = new Oi(), s2 = new Ni(i2);
    this.chartType = i2.chart.type, i2 = this.extendYAxis(i2), i2 = this.extendAnnotations(i2);
    var r2 = a2.init(), n2 = {};
    if (i2 &amp;&amp; &quot;object&quot; === b(i2)) {
      var o2, l2, h2, c2, d2, u2, g2, p2, f2, x2, m2 = {};
      m2 = -1 !== [&quot;line&quot;, &quot;area&quot;, &quot;bar&quot;, &quot;candlestick&quot;, &quot;boxPlot&quot;, &quot;rangeBar&quot;, &quot;rangeArea&quot;, &quot;bubble&quot;, &quot;scatter&quot;, &quot;heatmap&quot;, &quot;treemap&quot;, &quot;pie&quot;, &quot;polarArea&quot;, &quot;donut&quot;, &quot;radar&quot;, &quot;radialBar&quot;].indexOf(i2.chart.type) ? s2[i2.chart.type]() : s2.line(), null !== (o2 = i2.plotOptions) &amp;&amp; void 0 !== o2 &amp;&amp; null !== (l2 = o2.bar) &amp;&amp; void 0 !== l2 &amp;&amp; l2.isFunnel &amp;&amp; (m2 = s2.funnel()), i2.chart.stacked &amp;&amp; &quot;bar&quot; === i2.chart.type &amp;&amp; (m2 = s2.stackedBars()), null !== (h2 = i2.chart.brush) &amp;&amp; void 0 !== h2 &amp;&amp; h2.enabled &amp;&amp; (m2 = s2.brush(m2)), null !== (c2 = i2.plotOptions) &amp;&amp; void 0 !== c2 &amp;&amp; null !== (d2 = c2.line) &amp;&amp; void 0 !== d2 &amp;&amp; d2.isSlopeChart &amp;&amp; (m2 = s2.slope()), i2.chart.stacked &amp;&amp; &quot;100%&quot; === i2.chart.stackType &amp;&amp; (i2 = s2.stacked100(i2)), null !== (u2 = i2.plotOptions) &amp;&amp; void 0 !== u2 &amp;&amp; null !== (g2 = u2.bar) &amp;&amp; void 0 !== g2 &amp;&amp; g2.isDumbbell &amp;&amp; (i2 = s2.dumbbell(i2)), this.checkForDarkTheme(window.Apex), this.checkForDarkTheme(i2), i2.xaxis = i2.xaxis || window.Apex.xaxis || {}, e2 || (i2.xaxis.convertedCatToNumeric = false), (null !== (p2 = (i2 = this.checkForCatToNumericXAxis(this.chartType, m2, i2)).chart.sparkline) &amp;&amp; void 0 !== p2 &amp;&amp; p2.enabled || null !== (f2 = window.Apex.chart) &amp;&amp; void 0 !== f2 &amp;&amp; null !== (x2 = f2.sparkline) &amp;&amp; void 0 !== x2 &amp;&amp; x2.enabled) &amp;&amp; (m2 = s2.sparkline(m2)), n2 = v.extend(r2, m2);
    }
    var y2 = v.extend(n2, window.Apex);
    return r2 = v.extend(y2, i2), r2 = this.handleUserInputErrors(r2);
  } }, { key: &quot;checkForCatToNumericXAxis&quot;, value: function(t3, e2, i2) {
    var a2, s2, r2 = new Ni(i2), n2 = (&quot;bar&quot; === t3 || &quot;boxPlot&quot; === t3) &amp;&amp; (null === (a2 = i2.plotOptions) || void 0 === a2 || null === (s2 = a2.bar) || void 0 === s2 ? void 0 : s2.horizontal), o2 = &quot;pie&quot; === t3 || &quot;polarArea&quot; === t3 || &quot;donut&quot; === t3 || &quot;radar&quot; === t3 || &quot;radialBar&quot; === t3 || &quot;heatmap&quot; === t3, l2 = &quot;datetime&quot; !== i2.xaxis.type &amp;&amp; &quot;numeric&quot; !== i2.xaxis.type, h2 = i2.xaxis.tickPlacement ? i2.xaxis.tickPlacement : e2.xaxis &amp;&amp; e2.xaxis.tickPlacement;
    return n2 || o2 || !l2 || &quot;between&quot; === h2 || (i2 = r2.convertCatToNumeric(i2)), i2;
  } }, { key: &quot;extendYAxis&quot;, value: function(t3, e2) {
    var i2 = new Oi();
    (void 0 === t3.yaxis || !t3.yaxis || Array.isArray(t3.yaxis) &amp;&amp; 0 === t3.yaxis.length) &amp;&amp; (t3.yaxis = {}), t3.yaxis.constructor !== Array &amp;&amp; window.Apex.yaxis &amp;&amp; window.Apex.yaxis.constructor !== Array &amp;&amp; (t3.yaxis = v.extend(t3.yaxis, window.Apex.yaxis)), t3.yaxis.constructor !== Array ? t3.yaxis = [v.extend(i2.yAxis, t3.yaxis)] : t3.yaxis = v.extendArray(t3.yaxis, i2.yAxis);
    var a2 = false;
    t3.yaxis.forEach(function(t4) {
      t4.logarithmic &amp;&amp; (a2 = true);
    });
    var s2 = t3.series;
    return e2 &amp;&amp; !s2 &amp;&amp; (s2 = e2.config.series), a2 &amp;&amp; s2.length !== t3.yaxis.length &amp;&amp; s2.length &amp;&amp; (t3.yaxis = s2.map(function(e3, a3) {
      if (e3.name || (s2[a3].name = &quot;series-&quot;.concat(a3 + 1)), t3.yaxis[a3]) return t3.yaxis[a3].seriesName = s2[a3].name, t3.yaxis[a3];
      var r2 = v.extend(i2.yAxis, t3.yaxis[0]);
      return r2.show = false, r2;
    })), a2 &amp;&amp; s2.length &gt; 1 &amp;&amp; s2.length !== t3.yaxis.length &amp;&amp; console.warn(&quot;A multi-series logarithmic chart should have equal number of series and y-axes&quot;), t3;
  } }, { key: &quot;extendAnnotations&quot;, value: function(t3) {
    return void 0 === t3.annotations &amp;&amp; (t3.annotations = {}, t3.annotations.yaxis = [], t3.annotations.xaxis = [], t3.annotations.points = []), t3 = this.extendYAxisAnnotations(t3), t3 = this.extendXAxisAnnotations(t3), t3 = this.extendPointAnnotations(t3);
  } }, { key: &quot;extendYAxisAnnotations&quot;, value: function(t3) {
    var e2 = new Oi();
    return t3.annotations.yaxis = v.extendArray(void 0 !== t3.annotations.yaxis ? t3.annotations.yaxis : [], e2.yAxisAnnotation), t3;
  } }, { key: &quot;extendXAxisAnnotations&quot;, value: function(t3) {
    var e2 = new Oi();
    return t3.annotations.xaxis = v.extendArray(void 0 !== t3.annotations.xaxis ? t3.annotations.xaxis : [], e2.xAxisAnnotation), t3;
  } }, { key: &quot;extendPointAnnotations&quot;, value: function(t3) {
    var e2 = new Oi();
    return t3.annotations.points = v.extendArray(void 0 !== t3.annotations.points ? t3.annotations.points : [], e2.pointAnnotation), t3;
  } }, { key: &quot;checkForDarkTheme&quot;, value: function(t3) {
    t3.theme &amp;&amp; &quot;dark&quot; === t3.theme.mode &amp;&amp; (t3.tooltip || (t3.tooltip = {}), &quot;light&quot; !== t3.tooltip.theme &amp;&amp; (t3.tooltip.theme = &quot;dark&quot;), t3.chart.foreColor || (t3.chart.foreColor = &quot;#f6f7f8&quot;), t3.theme.palette || (t3.theme.palette = &quot;palette4&quot;));
  } }, { key: &quot;handleUserInputErrors&quot;, value: function(t3) {
    var e2 = t3;
    if (e2.tooltip.shared &amp;&amp; e2.tooltip.intersect) throw new Error(&quot;tooltip.shared cannot be enabled when tooltip.intersect is true. Turn off any other option by setting it to false.&quot;);
    if (&quot;bar&quot; === e2.chart.type &amp;&amp; e2.plotOptions.bar.horizontal) {
      if (e2.yaxis.length &gt; 1) throw new Error(&quot;Multiple Y Axis for bars are not supported. Switch to column chart by setting plotOptions.bar.horizontal=false&quot;);
      e2.yaxis[0].reversed &amp;&amp; (e2.yaxis[0].opposite = true), e2.xaxis.tooltip.enabled = false, e2.yaxis[0].tooltip.enabled = false, e2.chart.zoom.enabled = false;
    }
    return &quot;bar&quot; !== e2.chart.type &amp;&amp; &quot;rangeBar&quot; !== e2.chart.type || e2.tooltip.shared &amp;&amp; &quot;barWidth&quot; === e2.xaxis.crosshairs.width &amp;&amp; e2.series.length &gt; 1 &amp;&amp; (e2.xaxis.crosshairs.width = &quot;tickWidth&quot;), &quot;candlestick&quot; !== e2.chart.type &amp;&amp; &quot;boxPlot&quot; !== e2.chart.type || e2.yaxis[0].reversed &amp;&amp; (console.warn(&quot;Reversed y-axis in &quot;.concat(e2.chart.type, &quot; chart is not supported.&quot;)), e2.yaxis[0].reversed = false), e2;
  } }]), t2;
}();
var Bi = function() {
  function t2() {
    i(this, t2);
  }
  return s(t2, [{ key: &quot;initGlobalVars&quot;, value: function(t3) {
    t3.series = [], t3.seriesCandleO = [], t3.seriesCandleH = [], t3.seriesCandleM = [], t3.seriesCandleL = [], t3.seriesCandleC = [], t3.seriesRangeStart = [], t3.seriesRangeEnd = [], t3.seriesRange = [], t3.seriesPercent = [], t3.seriesGoals = [], t3.seriesX = [], t3.seriesZ = [], t3.seriesNames = [], t3.seriesTotals = [], t3.seriesLog = [], t3.seriesColors = [], t3.stackedSeriesTotals = [], t3.seriesXvalues = [], t3.seriesYvalues = [], t3.labels = [], t3.hasXaxisGroups = false, t3.groups = [], t3.barGroups = [], t3.lineGroups = [], t3.areaGroups = [], t3.hasSeriesGroups = false, t3.seriesGroups = [], t3.categoryLabels = [], t3.timescaleLabels = [], t3.noLabelsProvided = false, t3.resizeTimer = null, t3.selectionResizeTimer = null, t3.lastWheelExecution = 0, t3.delayedElements = [], t3.pointsArray = [], t3.dataLabelsRects = [], t3.isXNumeric = false, t3.skipLastTimelinelabel = false, t3.skipFirstTimelinelabel = false, t3.isDataXYZ = false, t3.isMultiLineX = false, t3.isMultipleYAxis = false, t3.maxY = -Number.MAX_VALUE, t3.minY = Number.MIN_VALUE, t3.minYArr = [], t3.maxYArr = [], t3.maxX = -Number.MAX_VALUE, t3.minX = Number.MAX_VALUE, t3.initialMaxX = -Number.MAX_VALUE, t3.initialMinX = Number.MAX_VALUE, t3.maxDate = 0, t3.minDate = Number.MAX_VALUE, t3.minZ = Number.MAX_VALUE, t3.maxZ = -Number.MAX_VALUE, t3.minXDiff = Number.MAX_VALUE, t3.yAxisScale = [], t3.xAxisScale = null, t3.xAxisTicksPositions = [], t3.yLabelsCoords = [], t3.yTitleCoords = [], t3.barPadForNumericAxis = 0, t3.padHorizontal = 0, t3.xRange = 0, t3.yRange = [], t3.zRange = 0, t3.dataPoints = 0, t3.xTickAmount = 0, t3.multiAxisTickAmount = 0;
  } }, { key: &quot;globalVars&quot;, value: function(t3) {
    return { chartID: null, cuid: null, events: { beforeMount: [], mounted: [], updated: [], clicked: [], selection: [], dataPointSelection: [], zoomed: [], scrolled: [] }, colors: [], clientX: null, clientY: null, fill: { colors: [] }, stroke: { colors: [] }, dataLabels: { style: { colors: [] } }, radarPolygons: { fill: { colors: [] } }, markers: { colors: [], size: t3.markers.size, largestSize: 0 }, animationEnded: false, isTouchDevice: &quot;ontouchstart&quot; in window || navigator.msMaxTouchPoints, isDirty: false, isExecCalled: false, initialConfig: null, initialSeries: [], lastXAxis: [], lastYAxis: [], columnSeries: null, labels: [], timescaleLabels: [], noLabelsProvided: false, allSeriesCollapsed: false, collapsedSeries: [], collapsedSeriesIndices: [], ancillaryCollapsedSeries: [], ancillaryCollapsedSeriesIndices: [], risingSeries: [], dataFormatXNumeric: false, capturedSeriesIndex: -1, capturedDataPointIndex: -1, selectedDataPoints: [], invalidLogScale: false, ignoreYAxisIndexes: [], maxValsInArrayIndex: 0, radialSize: 0, selection: void 0, zoomEnabled: &quot;zoom&quot; === t3.chart.toolbar.autoSelected &amp;&amp; t3.chart.toolbar.tools.zoom &amp;&amp; t3.chart.zoom.enabled, panEnabled: &quot;pan&quot; === t3.chart.toolbar.autoSelected &amp;&amp; t3.chart.toolbar.tools.pan, selectionEnabled: &quot;selection&quot; === t3.chart.toolbar.autoSelected &amp;&amp; t3.chart.toolbar.tools.selection, yaxis: null, mousedown: false, lastClientPosition: {}, visibleXRange: void 0, yValueDecimal: 0, total: 0, SVGNS: &quot;http://www.w3.org/2000/svg&quot;, svgWidth: 0, svgHeight: 0, noData: false, locale: {}, dom: {}, memory: { methodsToExec: [] }, shouldAnimate: true, skipLastTimelinelabel: false, skipFirstTimelinelabel: false, delayedElements: [], axisCharts: true, isDataXYZ: false, isSlopeChart: t3.plotOptions.line.isSlopeChart, resized: false, resizeTimer: null, comboCharts: false, dataChanged: false, previousPaths: [], allSeriesHasEqualX: true, pointsArray: [], dataLabelsRects: [], lastDrawnDataLabelsIndexes: [], hasNullValues: false, zoomed: false, gridWidth: 0, gridHeight: 0, rotateXLabels: false, defaultLabels: false, xLabelFormatter: void 0, yLabelFormatters: [], xaxisTooltipFormatter: void 0, ttKeyFormatter: void 0, ttVal: void 0, ttZFormatter: void 0, LINE_HEIGHT_RATIO: 1.618, xAxisLabelsHeight: 0, xAxisGroupLabelsHeight: 0, xAxisLabelsWidth: 0, yAxisLabelsWidth: 0, scaleX: 1, scaleY: 1, translateX: 0, translateY: 0, translateYAxisX: [], yAxisWidths: [], translateXAxisY: 0, translateXAxisX: 0, tooltip: null, niceScaleAllowedMagMsd: [[1, 1, 2, 5, 5, 5, 10, 10, 10, 10, 10], [1, 1, 2, 5, 5, 5, 10, 10, 10, 10, 10]], niceScaleDefaultTicks: [1, 2, 4, 4, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 12, 12, 12, 12, 12, 12, 12, 12, 12, 24], seriesYAxisMap: [], seriesYAxisReverseMap: [] };
  } }, { key: &quot;init&quot;, value: function(t3) {
    var e2 = this.globalVars(t3);
    return this.initGlobalVars(e2), e2.initialConfig = v.extend({}, t3), e2.initialSeries = v.clone(t3.series), e2.lastXAxis = v.clone(e2.initialConfig.xaxis), e2.lastYAxis = v.clone(e2.initialConfig.yaxis), e2;
  } }]), t2;
}();
var Gi = function() {
  function t2(e2) {
    i(this, t2), this.opts = e2;
  }
  return s(t2, [{ key: &quot;init&quot;, value: function() {
    var t3 = new Wi(this.opts).init({ responsiveOverride: false });
    return { config: t3, globals: new Bi().init(t3) };
  } }]), t2;
}();
var ji = function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w, this.opts = null, this.seriesIndex = 0, this.patternIDs = [];
  }
  return s(t2, [{ key: &quot;clippedImgArea&quot;, value: function(t3) {
    var e2 = this.w, i2 = e2.config, a2 = parseInt(e2.globals.gridWidth, 10), s2 = parseInt(e2.globals.gridHeight, 10), r2 = a2 &gt; s2 ? a2 : s2, n2 = t3.image, o2 = 0, l2 = 0;
    void 0 === t3.width &amp;&amp; void 0 === t3.height ? void 0 !== i2.fill.image.width &amp;&amp; void 0 !== i2.fill.image.height ? (o2 = i2.fill.image.width + 1, l2 = i2.fill.image.height) : (o2 = r2 + 1, l2 = r2) : (o2 = t3.width, l2 = t3.height);
    var h2 = document.createElementNS(e2.globals.SVGNS, &quot;pattern&quot;);
    Mi.setAttrs(h2, { id: t3.patternID, patternUnits: t3.patternUnits ? t3.patternUnits : &quot;userSpaceOnUse&quot;, width: o2 + &quot;px&quot;, height: l2 + &quot;px&quot; });
    var c2 = document.createElementNS(e2.globals.SVGNS, &quot;image&quot;);
    h2.appendChild(c2), c2.setAttributeNS(window.SVG.xlink, &quot;href&quot;, n2), Mi.setAttrs(c2, { x: 0, y: 0, preserveAspectRatio: &quot;none&quot;, width: o2 + &quot;px&quot;, height: l2 + &quot;px&quot; }), c2.style.opacity = t3.opacity, e2.globals.dom.elDefs.node.appendChild(h2);
  } }, { key: &quot;getSeriesIndex&quot;, value: function(t3) {
    var e2 = this.w, i2 = e2.config.chart.type;
    return (&quot;bar&quot; === i2 || &quot;rangeBar&quot; === i2) &amp;&amp; e2.config.plotOptions.bar.distributed || &quot;heatmap&quot; === i2 || &quot;treemap&quot; === i2 ? this.seriesIndex = t3.seriesNumber : this.seriesIndex = t3.seriesNumber % e2.globals.series.length, this.seriesIndex;
  } }, { key: &quot;computeColorStops&quot;, value: function(t3, e2) {
    var i2, a2 = this.w, s2 = null, n2 = null, o2 = r(t3);
    try {
      for (o2.s(); !(i2 = o2.n()).done; ) {
        var l2 = i2.value;
        l2 &gt;= e2.threshold ? (null === s2 || l2 &gt; s2) &amp;&amp; (s2 = l2) : (null === n2 || l2 &lt; n2) &amp;&amp; (n2 = l2);
      }
    } catch (t4) {
      o2.e(t4);
    } finally {
      o2.f();
    }
    null === s2 &amp;&amp; (s2 = e2.threshold), null === n2 &amp;&amp; (n2 = e2.threshold);
    var h2 = s2 - e2.threshold + (e2.threshold - n2);
    0 === h2 &amp;&amp; (h2 = 1);
    var c2 = 100 - (e2.threshold - n2) / h2 * 100;
    return [{ offset: c2 = Math.max(0, Math.min(c2, 100)), color: e2.colorAboveThreshold, opacity: a2.config.fill.opacity }, { offset: 0, color: e2.colorBelowThreshold, opacity: a2.config.fill.opacity }];
  } }, { key: &quot;fillPath&quot;, value: function(t3) {
    var e2, i2, a2, s2 = this.w;
    this.opts = t3;
    var r2, n2, o2, l2 = this.w.config;
    this.seriesIndex = this.getSeriesIndex(t3);
    var h2 = l2.plotOptions.line.colors.colorAboveThreshold &amp;&amp; l2.plotOptions.line.colors.colorBelowThreshold, c2 = this.getFillColors()[this.seriesIndex];
    void 0 !== s2.globals.seriesColors[this.seriesIndex] &amp;&amp; (c2 = s2.globals.seriesColors[this.seriesIndex]), &quot;function&quot; == typeof c2 &amp;&amp; (c2 = c2({ seriesIndex: this.seriesIndex, dataPointIndex: t3.dataPointIndex, value: t3.value, w: s2 }));
    var d2, u2, g2, p2 = t3.fillType ? t3.fillType : this.getFillType(this.seriesIndex), x2 = Array.isArray(l2.fill.opacity) ? l2.fill.opacity[this.seriesIndex] : l2.fill.opacity, b2 = &quot;gradient&quot; === p2 || h2;
    (t3.color &amp;&amp; (c2 = t3.color), null !== (e2 = s2.config.series[this.seriesIndex]) &amp;&amp; void 0 !== e2 &amp;&amp; null !== (i2 = e2.data) &amp;&amp; void 0 !== i2 &amp;&amp; null !== (a2 = i2[t3.dataPointIndex]) &amp;&amp; void 0 !== a2 &amp;&amp; a2.fillColor) &amp;&amp; (c2 = null === (d2 = s2.config.series[this.seriesIndex]) || void 0 === d2 || null === (u2 = d2.data) || void 0 === u2 || null === (g2 = u2[t3.dataPointIndex]) || void 0 === g2 ? void 0 : g2.fillColor);
    c2 || (c2 = &quot;#fff&quot;, console.warn(&quot;undefined color - ApexCharts&quot;));
    var m2 = c2;
    if (-1 === c2.indexOf(&quot;rgb&quot;) ? -1 === c2.indexOf(&quot;#&quot;) ? m2 = c2 : c2.length &lt; 9 &amp;&amp; (m2 = v.hexToRgba(c2, x2)) : c2.indexOf(&quot;rgba&quot;) &gt; -1 ? x2 = v.getOpacityFromRGBA(c2) : m2 = v.hexToRgba(v.rgb2hex(c2), x2), t3.opacity &amp;&amp; (x2 = t3.opacity), &quot;pattern&quot; === p2 &amp;&amp; (n2 = this.handlePatternFill({ fillConfig: t3.fillConfig, patternFill: n2, fillColor: c2, fillOpacity: x2, defaultColor: m2 })), b2) {
      var y2 = f(l2.fill.gradient.colorStops) || [], w2 = l2.fill.gradient.type;
      h2 &amp;&amp; (y2[this.seriesIndex] = this.computeColorStops(s2.globals.series[this.seriesIndex], l2.plotOptions.line.colors), w2 = &quot;vertical&quot;), o2 = this.handleGradientFill({ type: w2, fillConfig: t3.fillConfig, fillColor: c2, fillOpacity: x2, colorStops: y2, i: this.seriesIndex });
    }
    if (&quot;image&quot; === p2) {
      var k2 = l2.fill.image.src, A2 = t3.patternID ? t3.patternID : &quot;&quot;, C2 = &quot;pattern&quot;.concat(s2.globals.cuid).concat(t3.seriesNumber + 1).concat(A2);
      -1 === this.patternIDs.indexOf(C2) &amp;&amp; (this.clippedImgArea({ opacity: x2, image: Array.isArray(k2) ? t3.seriesNumber &lt; k2.length ? k2[t3.seriesNumber] : k2[0] : k2, width: t3.width ? t3.width : void 0, height: t3.height ? t3.height : void 0, patternUnits: t3.patternUnits, patternID: C2 }), this.patternIDs.push(C2)), r2 = &quot;url(#&quot;.concat(C2, &quot;)&quot;);
    } else r2 = b2 ? o2 : &quot;pattern&quot; === p2 ? n2 : m2;
    return t3.solid &amp;&amp; (r2 = m2), r2;
  } }, { key: &quot;getFillType&quot;, value: function(t3) {
    var e2 = this.w;
    return Array.isArray(e2.config.fill.type) ? e2.config.fill.type[t3] : e2.config.fill.type;
  } }, { key: &quot;getFillColors&quot;, value: function() {
    var t3 = this.w, e2 = t3.config, i2 = this.opts, a2 = [];
    return t3.globals.comboCharts ? &quot;line&quot; === t3.config.series[this.seriesIndex].type ? Array.isArray(t3.globals.stroke.colors) ? a2 = t3.globals.stroke.colors : a2.push(t3.globals.stroke.colors) : Array.isArray(t3.globals.fill.colors) ? a2 = t3.globals.fill.colors : a2.push(t3.globals.fill.colors) : &quot;line&quot; === e2.chart.type ? Array.isArray(t3.globals.stroke.colors) ? a2 = t3.globals.stroke.colors : a2.push(t3.globals.stroke.colors) : Array.isArray(t3.globals.fill.colors) ? a2 = t3.globals.fill.colors : a2.push(t3.globals.fill.colors), void 0 !== i2.fillColors &amp;&amp; (a2 = [], Array.isArray(i2.fillColors) ? a2 = i2.fillColors.slice() : a2.push(i2.fillColors)), a2;
  } }, { key: &quot;handlePatternFill&quot;, value: function(t3) {
    var e2 = t3.fillConfig, i2 = t3.patternFill, a2 = t3.fillColor, s2 = t3.fillOpacity, r2 = t3.defaultColor, n2 = this.w.config.fill;
    e2 &amp;&amp; (n2 = e2);
    var o2 = this.opts, l2 = new Mi(this.ctx), h2 = Array.isArray(n2.pattern.strokeWidth) ? n2.pattern.strokeWidth[this.seriesIndex] : n2.pattern.strokeWidth, c2 = a2;
    Array.isArray(n2.pattern.style) ? i2 = void 0 !== n2.pattern.style[o2.seriesNumber] ? l2.drawPattern(n2.pattern.style[o2.seriesNumber], n2.pattern.width, n2.pattern.height, c2, h2, s2) : r2 : i2 = l2.drawPattern(n2.pattern.style, n2.pattern.width, n2.pattern.height, c2, h2, s2);
    return i2;
  } }, { key: &quot;handleGradientFill&quot;, value: function(t3) {
    var e2 = t3.type, i2 = t3.fillColor, a2 = t3.fillOpacity, s2 = t3.fillConfig, r2 = t3.colorStops, n2 = t3.i, o2 = this.w.config.fill;
    s2 &amp;&amp; (o2 = u(u({}, o2), s2));
    var l2 = this.opts, h2 = new Mi(this.ctx), c2 = new v();
    e2 = e2 || o2.gradient.type;
    var d2, g2 = i2, p2 = void 0 === o2.gradient.opacityFrom ? a2 : Array.isArray(o2.gradient.opacityFrom) ? o2.gradient.opacityFrom[n2] : o2.gradient.opacityFrom;
    g2.indexOf(&quot;rgba&quot;) &gt; -1 &amp;&amp; (p2 = v.getOpacityFromRGBA(g2));
    var f2 = void 0 === o2.gradient.opacityTo ? a2 : Array.isArray(o2.gradient.opacityTo) ? o2.gradient.opacityTo[n2] : o2.gradient.opacityTo;
    if (void 0 === o2.gradient.gradientToColors || 0 === o2.gradient.gradientToColors.length) d2 = &quot;dark&quot; === o2.gradient.shade ? c2.shadeColor(-1 * parseFloat(o2.gradient.shadeIntensity), i2.indexOf(&quot;rgb&quot;) &gt; -1 ? v.rgb2hex(i2) : i2) : c2.shadeColor(parseFloat(o2.gradient.shadeIntensity), i2.indexOf(&quot;rgb&quot;) &gt; -1 ? v.rgb2hex(i2) : i2);
    else if (o2.gradient.gradientToColors[l2.seriesNumber]) {
      var x2 = o2.gradient.gradientToColors[l2.seriesNumber];
      d2 = x2, x2.indexOf(&quot;rgba&quot;) &gt; -1 &amp;&amp; (f2 = v.getOpacityFromRGBA(x2));
    } else d2 = i2;
    if (o2.gradient.gradientFrom &amp;&amp; (g2 = o2.gradient.gradientFrom), o2.gradient.gradientTo &amp;&amp; (d2 = o2.gradient.gradientTo), o2.gradient.inverseColors) {
      var b2 = g2;
      g2 = d2, d2 = b2;
    }
    return g2.indexOf(&quot;rgb&quot;) &gt; -1 &amp;&amp; (g2 = v.rgb2hex(g2)), d2.indexOf(&quot;rgb&quot;) &gt; -1 &amp;&amp; (d2 = v.rgb2hex(d2)), h2.drawGradient(e2, g2, d2, p2, f2, l2.size, o2.gradient.stops, r2, n2);
  } }]), t2;
}();
var Vi = function() {
  function t2(e2, a2) {
    i(this, t2), this.ctx = e2, this.w = e2.w;
  }
  return s(t2, [{ key: &quot;setGlobalMarkerSize&quot;, value: function() {
    var t3 = this.w;
    if (t3.globals.markers.size = Array.isArray(t3.config.markers.size) ? t3.config.markers.size : [t3.config.markers.size], t3.globals.markers.size.length &gt; 0) {
      if (t3.globals.markers.size.length &lt; t3.globals.series.length + 1) for (var e2 = 0; e2 &lt;= t3.globals.series.length; e2++) void 0 === t3.globals.markers.size[e2] &amp;&amp; t3.globals.markers.size.push(t3.globals.markers.size[0]);
    } else t3.globals.markers.size = t3.config.series.map(function(e3) {
      return t3.config.markers.size;
    });
  } }, { key: &quot;plotChartMarkers&quot;, value: function(t3) {
    var e2 = t3.pointsPos, i2 = t3.seriesIndex, a2 = t3.j, s2 = t3.pSize, r2 = t3.alwaysDrawMarker, n2 = void 0 !== r2 &amp;&amp; r2, o2 = t3.isVirtualPoint, l2 = void 0 !== o2 &amp;&amp; o2, h2 = this.w, c2 = i2, d2 = e2, u2 = null, g2 = new Mi(this.ctx), p2 = h2.config.markers.discrete &amp;&amp; h2.config.markers.discrete.length;
    if (Array.isArray(d2.x)) for (var f2 = 0; f2 &lt; d2.x.length; f2++) {
      var x2 = void 0, b2 = a2, m2 = !v.isNumber(d2.y[f2]);
      0 === h2.globals.markers.largestSize &amp;&amp; h2.globals.hasNullValues &amp;&amp; null !== h2.globals.series[c2][a2 + 1] &amp;&amp; !l2 &amp;&amp; (m2 = true), 1 === a2 &amp;&amp; 0 === f2 &amp;&amp; (b2 = 0), 1 === a2 &amp;&amp; 1 === f2 &amp;&amp; (b2 = 1);
      var y2 = &quot;apexcharts-marker&quot;;
      if (&quot;line&quot; !== h2.config.chart.type &amp;&amp; &quot;area&quot; !== h2.config.chart.type || h2.globals.comboCharts || h2.config.tooltip.intersect || (y2 += &quot; no-pointer-events&quot;), (Array.isArray(h2.config.markers.size) ? h2.globals.markers.size[i2] &gt; 0 : h2.config.markers.size &gt; 0) || n2 || p2) {
        m2 || (y2 += &quot; w&quot;.concat(v.randomId()));
        var w2 = this.getMarkerConfig({ cssClass: y2, seriesIndex: i2, dataPointIndex: b2 });
        if (h2.config.series[c2].data[b2] &amp;&amp; (h2.config.series[c2].data[b2].fillColor &amp;&amp; (w2.pointFillColor = h2.config.series[c2].data[b2].fillColor), h2.config.series[c2].data[b2].strokeColor &amp;&amp; (w2.pointStrokeColor = h2.config.series[c2].data[b2].strokeColor)), void 0 !== s2 &amp;&amp; (w2.pSize = s2), (d2.x[f2] &lt; -h2.globals.markers.largestSize || d2.x[f2] &gt; h2.globals.gridWidth + h2.globals.markers.largestSize || d2.y[f2] &lt; -h2.globals.markers.largestSize || d2.y[f2] &gt; h2.globals.gridHeight + h2.globals.markers.largestSize) &amp;&amp; (w2.pSize = 0), !m2) (h2.globals.markers.size[i2] &gt; 0 || n2 || p2) &amp;&amp; !u2 &amp;&amp; (u2 = g2.group({ class: n2 || p2 ? &quot;&quot; : &quot;apexcharts-series-markers&quot; })).attr(&quot;clip-path&quot;, &quot;url(#gridRectMarkerMask&quot;.concat(h2.globals.cuid, &quot;)&quot;)), (x2 = g2.drawMarker(d2.x[f2], d2.y[f2], w2)).attr(&quot;rel&quot;, b2), x2.attr(&quot;j&quot;, b2), x2.attr(&quot;index&quot;, i2), x2.node.setAttribute(&quot;default-marker-size&quot;, w2.pSize), new Li(this.ctx).setSelectionFilter(x2, i2, b2), this.addEvents(x2), u2 &amp;&amp; u2.add(x2);
      } else void 0 === h2.globals.pointsArray[i2] &amp;&amp; (h2.globals.pointsArray[i2] = []), h2.globals.pointsArray[i2].push([d2.x[f2], d2.y[f2]]);
    }
    return u2;
  } }, { key: &quot;getMarkerConfig&quot;, value: function(t3) {
    var e2 = t3.cssClass, i2 = t3.seriesIndex, a2 = t3.dataPointIndex, s2 = void 0 === a2 ? null : a2, r2 = t3.radius, n2 = void 0 === r2 ? null : r2, o2 = t3.size, l2 = void 0 === o2 ? null : o2, h2 = t3.strokeWidth, c2 = void 0 === h2 ? null : h2, d2 = this.w, u2 = this.getMarkerStyle(i2), g2 = null === l2 ? d2.globals.markers.size[i2] : l2, p2 = d2.config.markers;
    return null !== s2 &amp;&amp; p2.discrete.length &amp;&amp; p2.discrete.map(function(t4) {
      t4.seriesIndex === i2 &amp;&amp; t4.dataPointIndex === s2 &amp;&amp; (u2.pointStrokeColor = t4.strokeColor, u2.pointFillColor = t4.fillColor, g2 = t4.size, u2.pointShape = t4.shape);
    }), { pSize: null === n2 ? g2 : n2, pRadius: null !== n2 ? n2 : p2.radius, pointStrokeWidth: null !== c2 ? c2 : Array.isArray(p2.strokeWidth) ? p2.strokeWidth[i2] : p2.strokeWidth, pointStrokeColor: u2.pointStrokeColor, pointFillColor: u2.pointFillColor, shape: u2.pointShape || (Array.isArray(p2.shape) ? p2.shape[i2] : p2.shape), class: e2, pointStrokeOpacity: Array.isArray(p2.strokeOpacity) ? p2.strokeOpacity[i2] : p2.strokeOpacity, pointStrokeDashArray: Array.isArray(p2.strokeDashArray) ? p2.strokeDashArray[i2] : p2.strokeDashArray, pointFillOpacity: Array.isArray(p2.fillOpacity) ? p2.fillOpacity[i2] : p2.fillOpacity, seriesIndex: i2 };
  } }, { key: &quot;addEvents&quot;, value: function(t3) {
    var e2 = this.w, i2 = new Mi(this.ctx);
    t3.node.addEventListener(&quot;mouseenter&quot;, i2.pathMouseEnter.bind(this.ctx, t3)), t3.node.addEventListener(&quot;mouseleave&quot;, i2.pathMouseLeave.bind(this.ctx, t3)), t3.node.addEventListener(&quot;mousedown&quot;, i2.pathMouseDown.bind(this.ctx, t3)), t3.node.addEventListener(&quot;click&quot;, e2.config.markers.onClick), t3.node.addEventListener(&quot;dblclick&quot;, e2.config.markers.onDblClick), t3.node.addEventListener(&quot;touchstart&quot;, i2.pathMouseDown.bind(this.ctx, t3), { passive: true });
  } }, { key: &quot;getMarkerStyle&quot;, value: function(t3) {
    var e2 = this.w, i2 = e2.globals.markers.colors, a2 = e2.config.markers.strokeColor || e2.config.markers.strokeColors;
    return { pointStrokeColor: Array.isArray(a2) ? a2[t3] : a2, pointFillColor: Array.isArray(i2) ? i2[t3] : i2 };
  } }]), t2;
}();
var Ui = function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w, this.initialAnim = this.w.config.chart.animations.enabled;
  }
  return s(t2, [{ key: &quot;draw&quot;, value: function(t3, e2, i2) {
    var a2 = this.w, s2 = new Mi(this.ctx), r2 = i2.realIndex, n2 = i2.pointsPos, o2 = i2.zRatio, l2 = i2.elParent, h2 = s2.group({ class: &quot;apexcharts-series-markers apexcharts-series-&quot;.concat(a2.config.chart.type) });
    if (h2.attr(&quot;clip-path&quot;, &quot;url(#gridRectMarkerMask&quot;.concat(a2.globals.cuid, &quot;)&quot;)), Array.isArray(n2.x)) for (var c2 = 0; c2 &lt; n2.x.length; c2++) {
      var d2 = e2 + 1, u2 = true;
      0 === e2 &amp;&amp; 0 === c2 &amp;&amp; (d2 = 0), 0 === e2 &amp;&amp; 1 === c2 &amp;&amp; (d2 = 1);
      var g2 = a2.globals.markers.size[r2];
      if (o2 !== 1 / 0) {
        var p2 = a2.config.plotOptions.bubble;
        g2 = a2.globals.seriesZ[r2][d2], p2.zScaling &amp;&amp; (g2 /= o2), p2.minBubbleRadius &amp;&amp; g2 &lt; p2.minBubbleRadius &amp;&amp; (g2 = p2.minBubbleRadius), p2.maxBubbleRadius &amp;&amp; g2 &gt; p2.maxBubbleRadius &amp;&amp; (g2 = p2.maxBubbleRadius);
      }
      var f2 = n2.x[c2], x2 = n2.y[c2];
      if (g2 = g2 || 0, null !== x2 &amp;&amp; void 0 !== a2.globals.series[r2][d2] || (u2 = false), u2) {
        var b2 = this.drawPoint(f2, x2, g2, r2, d2, e2);
        h2.add(b2);
      }
      l2.add(h2);
    }
  } }, { key: &quot;drawPoint&quot;, value: function(t3, e2, i2, a2, s2, r2) {
    var n2 = this.w, o2 = a2, l2 = new y(this.ctx), h2 = new Li(this.ctx), c2 = new ji(this.ctx), d2 = new Vi(this.ctx), u2 = new Mi(this.ctx), g2 = d2.getMarkerConfig({ cssClass: &quot;apexcharts-marker&quot;, seriesIndex: o2, dataPointIndex: s2, radius: &quot;bubble&quot; === n2.config.chart.type || n2.globals.comboCharts &amp;&amp; n2.config.series[a2] &amp;&amp; &quot;bubble&quot; === n2.config.series[a2].type ? i2 : null }), p2 = c2.fillPath({ seriesNumber: a2, dataPointIndex: s2, color: g2.pointFillColor, patternUnits: &quot;objectBoundingBox&quot;, value: n2.globals.series[a2][r2] }), f2 = u2.drawMarker(t3, e2, g2);
    if (n2.config.series[o2].data[s2] &amp;&amp; n2.config.series[o2].data[s2].fillColor &amp;&amp; (p2 = n2.config.series[o2].data[s2].fillColor), f2.attr({ fill: p2 }), n2.config.chart.dropShadow.enabled) {
      var x2 = n2.config.chart.dropShadow;
      h2.dropShadow(f2, x2, a2);
    }
    if (!this.initialAnim || n2.globals.dataChanged || n2.globals.resized) n2.globals.animationEnded = true;
    else {
      var b2 = n2.config.chart.animations.speed;
      l2.animateMarker(f2, b2, n2.globals.easing, function() {
        window.setTimeout(function() {
          l2.animationCompleted(f2);
        }, 100);
      });
    }
    return f2.attr({ rel: s2, j: s2, index: a2, &quot;default-marker-size&quot;: g2.pSize }), h2.setSelectionFilter(f2, a2, s2), d2.addEvents(f2), f2.node.classList.add(&quot;apexcharts-marker&quot;), f2;
  } }, { key: &quot;centerTextInBubble&quot;, value: function(t3) {
    var e2 = this.w;
    return { y: t3 += parseInt(e2.config.dataLabels.style.fontSize, 10) / 4 };
  } }]), t2;
}();
var qi = function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w;
  }
  return s(t2, [{ key: &quot;dataLabelsCorrection&quot;, value: function(t3, e2, i2, a2, s2, r2, n2) {
    var o2 = this.w, l2 = false, h2 = new Mi(this.ctx).getTextRects(i2, n2), c2 = h2.width, d2 = h2.height;
    e2 &lt; 0 &amp;&amp; (e2 = 0), e2 &gt; o2.globals.gridHeight + d2 &amp;&amp; (e2 = o2.globals.gridHeight + d2 / 2), void 0 === o2.globals.dataLabelsRects[a2] &amp;&amp; (o2.globals.dataLabelsRects[a2] = []), o2.globals.dataLabelsRects[a2].push({ x: t3, y: e2, width: c2, height: d2 });
    var u2 = o2.globals.dataLabelsRects[a2].length - 2, g2 = void 0 !== o2.globals.lastDrawnDataLabelsIndexes[a2] ? o2.globals.lastDrawnDataLabelsIndexes[a2][o2.globals.lastDrawnDataLabelsIndexes[a2].length - 1] : 0;
    if (void 0 !== o2.globals.dataLabelsRects[a2][u2]) {
      var p2 = o2.globals.dataLabelsRects[a2][g2];
      (t3 &gt; p2.x + p2.width || e2 &gt; p2.y + p2.height || e2 + d2 &lt; p2.y || t3 + c2 &lt; p2.x) &amp;&amp; (l2 = true);
    }
    return (0 === s2 || r2) &amp;&amp; (l2 = true), { x: t3, y: e2, textRects: h2, drawnextLabel: l2 };
  } }, { key: &quot;drawDataLabel&quot;, value: function(t3) {
    var e2 = this, i2 = t3.type, a2 = t3.pos, s2 = t3.i, r2 = t3.j, n2 = t3.isRangeStart, o2 = t3.strokeWidth, l2 = void 0 === o2 ? 2 : o2, h2 = this.w, c2 = new Mi(this.ctx), d2 = h2.config.dataLabels, u2 = 0, g2 = 0, p2 = r2, f2 = null;
    if (-1 !== h2.globals.collapsedSeriesIndices.indexOf(s2) || !d2.enabled || !Array.isArray(a2.x)) return f2;
    f2 = c2.group({ class: &quot;apexcharts-data-labels&quot; });
    for (var x2 = 0; x2 &lt; a2.x.length; x2++) if (u2 = a2.x[x2] + d2.offsetX, g2 = a2.y[x2] + d2.offsetY + l2, !isNaN(u2)) {
      1 === r2 &amp;&amp; 0 === x2 &amp;&amp; (p2 = 0), 1 === r2 &amp;&amp; 1 === x2 &amp;&amp; (p2 = 1);
      var b2 = h2.globals.series[s2][p2];
      &quot;rangeArea&quot; === i2 &amp;&amp; (b2 = n2 ? h2.globals.seriesRangeStart[s2][p2] : h2.globals.seriesRangeEnd[s2][p2]);
      var m2 = &quot;&quot;, v2 = function(t4) {
        return h2.config.dataLabels.formatter(t4, { ctx: e2.ctx, seriesIndex: s2, dataPointIndex: p2, w: h2 });
      };
      if (&quot;bubble&quot; === h2.config.chart.type) m2 = v2(b2 = h2.globals.seriesZ[s2][p2]), g2 = a2.y[x2], g2 = new Ui(this.ctx).centerTextInBubble(g2, s2, p2).y;
      else void 0 !== b2 &amp;&amp; (m2 = v2(b2));
      var y2 = h2.config.dataLabels.textAnchor;
      h2.globals.isSlopeChart &amp;&amp; (y2 = 0 === p2 ? &quot;end&quot; : p2 === h2.config.series[s2].data.length - 1 ? &quot;start&quot; : &quot;middle&quot;), this.plotDataLabelsText({ x: u2, y: g2, text: m2, i: s2, j: p2, parent: f2, offsetCorrection: true, dataLabelsConfig: h2.config.dataLabels, textAnchor: y2 });
    }
    return f2;
  } }, { key: &quot;plotDataLabelsText&quot;, value: function(t3) {
    var e2 = this.w, i2 = new Mi(this.ctx), a2 = t3.x, s2 = t3.y, r2 = t3.i, n2 = t3.j, o2 = t3.text, l2 = t3.textAnchor, h2 = t3.fontSize, c2 = t3.parent, d2 = t3.dataLabelsConfig, u2 = t3.color, g2 = t3.alwaysDrawDataLabel, p2 = t3.offsetCorrection, f2 = t3.className, x2 = null;
    if (Array.isArray(e2.config.dataLabels.enabledOnSeries) &amp;&amp; e2.config.dataLabels.enabledOnSeries.indexOf(r2) &lt; 0) return x2;
    var b2 = { x: a2, y: s2, drawnextLabel: true, textRects: null };
    p2 &amp;&amp; (b2 = this.dataLabelsCorrection(a2, s2, o2, r2, n2, g2, parseInt(d2.style.fontSize, 10))), e2.globals.zoomed || (a2 = b2.x, s2 = b2.y), b2.textRects &amp;&amp; (a2 &lt; -20 - b2.textRects.width || a2 &gt; e2.globals.gridWidth + b2.textRects.width + 30) &amp;&amp; (o2 = &quot;&quot;);
    var m2 = e2.globals.dataLabels.style.colors[r2];
    ((&quot;bar&quot; === e2.config.chart.type || &quot;rangeBar&quot; === e2.config.chart.type) &amp;&amp; e2.config.plotOptions.bar.distributed || e2.config.dataLabels.distributed) &amp;&amp; (m2 = e2.globals.dataLabels.style.colors[n2]), &quot;function&quot; == typeof m2 &amp;&amp; (m2 = m2({ series: e2.globals.series, seriesIndex: r2, dataPointIndex: n2, w: e2 })), u2 &amp;&amp; (m2 = u2);
    var v2 = d2.offsetX, y2 = d2.offsetY;
    if (&quot;bar&quot; !== e2.config.chart.type &amp;&amp; &quot;rangeBar&quot; !== e2.config.chart.type || (v2 = 0, y2 = 0), e2.globals.isSlopeChart &amp;&amp; (0 !== n2 &amp;&amp; (v2 = -2 * d2.offsetX + 5), 0 !== n2 &amp;&amp; n2 !== e2.config.series[r2].data.length - 1 &amp;&amp; (v2 = 0)), b2.drawnextLabel) {
      if ((x2 = i2.drawText({ width: 100, height: parseInt(d2.style.fontSize, 10), x: a2 + v2, y: s2 + y2, foreColor: m2, textAnchor: l2 || d2.textAnchor, text: o2, fontSize: h2 || d2.style.fontSize, fontFamily: d2.style.fontFamily, fontWeight: d2.style.fontWeight || &quot;normal&quot; })).attr({ class: f2 || &quot;apexcharts-datalabel&quot;, cx: a2, cy: s2 }), d2.dropShadow.enabled) {
        var w2 = d2.dropShadow;
        new Li(this.ctx).dropShadow(x2, w2);
      }
      c2.add(x2), void 0 === e2.globals.lastDrawnDataLabelsIndexes[r2] &amp;&amp; (e2.globals.lastDrawnDataLabelsIndexes[r2] = []), e2.globals.lastDrawnDataLabelsIndexes[r2].push(n2);
    }
    return x2;
  } }, { key: &quot;addBackgroundToDataLabel&quot;, value: function(t3, e2) {
    var i2 = this.w, a2 = i2.config.dataLabels.background, s2 = a2.padding, r2 = a2.padding / 2, n2 = e2.width, o2 = e2.height, l2 = new Mi(this.ctx).drawRect(e2.x - s2, e2.y - r2 / 2, n2 + 2 * s2, o2 + r2, a2.borderRadius, &quot;transparent&quot; !== i2.config.chart.background &amp;&amp; i2.config.chart.background ? i2.config.chart.background : &quot;#fff&quot;, a2.opacity, a2.borderWidth, a2.borderColor);
    a2.dropShadow.enabled &amp;&amp; new Li(this.ctx).dropShadow(l2, a2.dropShadow);
    return l2;
  } }, { key: &quot;dataLabelsBackground&quot;, value: function() {
    var t3 = this.w;
    if (&quot;bubble&quot; !== t3.config.chart.type) for (var e2 = t3.globals.dom.baseEl.querySelectorAll(&quot;.apexcharts-datalabels text&quot;), i2 = 0; i2 &lt; e2.length; i2++) {
      var a2 = e2[i2], s2 = a2.getBBox(), r2 = null;
      if (s2.width &amp;&amp; s2.height &amp;&amp; (r2 = this.addBackgroundToDataLabel(a2, s2)), r2) {
        a2.parentNode.insertBefore(r2.node, a2);
        var n2 = a2.getAttribute(&quot;fill&quot;);
        t3.config.chart.animations.enabled &amp;&amp; !t3.globals.resized &amp;&amp; !t3.globals.dataChanged ? r2.animate().attr({ fill: n2 }) : r2.attr({ fill: n2 }), a2.setAttribute(&quot;fill&quot;, t3.config.dataLabels.background.foreColor);
      }
    }
  } }, { key: &quot;bringForward&quot;, value: function() {
    for (var t3 = this.w, e2 = t3.globals.dom.baseEl.querySelectorAll(&quot;.apexcharts-datalabels&quot;), i2 = t3.globals.dom.baseEl.querySelector(&quot;.apexcharts-plot-series:last-child&quot;), a2 = 0; a2 &lt; e2.length; a2++) i2 &amp;&amp; i2.insertBefore(e2[a2], i2.nextSibling);
  } }]), t2;
}();
var Zi = function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w, this.legendInactiveClass = &quot;legend-mouseover-inactive&quot;;
  }
  return s(t2, [{ key: &quot;getAllSeriesEls&quot;, value: function() {
    return this.w.globals.dom.baseEl.getElementsByClassName(&quot;apexcharts-series&quot;);
  } }, { key: &quot;getSeriesByName&quot;, value: function(t3) {
    return this.w.globals.dom.baseEl.querySelector(&quot;.apexcharts-inner .apexcharts-series[seriesName=&#x27;&quot;.concat(v.escapeString(t3), &quot;&#x27;]&quot;));
  } }, { key: &quot;isSeriesHidden&quot;, value: function(t3) {
    var e2 = this.getSeriesByName(t3), i2 = parseInt(e2.getAttribute(&quot;data:realIndex&quot;), 10);
    return { isHidden: e2.classList.contains(&quot;apexcharts-series-collapsed&quot;), realIndex: i2 };
  } }, { key: &quot;addCollapsedClassToSeries&quot;, value: function(t3, e2) {
    var i2 = this.w;
    function a2(i3) {
      for (var a3 = 0; a3 &lt; i3.length; a3++) i3[a3].index === e2 &amp;&amp; t3.node.classList.add(&quot;apexcharts-series-collapsed&quot;);
    }
    a2(i2.globals.collapsedSeries), a2(i2.globals.ancillaryCollapsedSeries);
  } }, { key: &quot;toggleSeries&quot;, value: function(t3) {
    var e2 = this.isSeriesHidden(t3);
    return this.ctx.legend.legendHelpers.toggleDataSeries(e2.realIndex, e2.isHidden), e2.isHidden;
  } }, { key: &quot;showSeries&quot;, value: function(t3) {
    var e2 = this.isSeriesHidden(t3);
    e2.isHidden &amp;&amp; this.ctx.legend.legendHelpers.toggleDataSeries(e2.realIndex, true);
  } }, { key: &quot;hideSeries&quot;, value: function(t3) {
    var e2 = this.isSeriesHidden(t3);
    e2.isHidden || this.ctx.legend.legendHelpers.toggleDataSeries(e2.realIndex, false);
  } }, { key: &quot;resetSeries&quot;, value: function() {
    var t3 = !(arguments.length &gt; 0 &amp;&amp; void 0 !== arguments[0]) || arguments[0], e2 = !(arguments.length &gt; 1 &amp;&amp; void 0 !== arguments[1]) || arguments[1], i2 = !(arguments.length &gt; 2 &amp;&amp; void 0 !== arguments[2]) || arguments[2], a2 = this.w, s2 = v.clone(a2.globals.initialSeries);
    a2.globals.previousPaths = [], i2 ? (a2.globals.collapsedSeries = [], a2.globals.ancillaryCollapsedSeries = [], a2.globals.collapsedSeriesIndices = [], a2.globals.ancillaryCollapsedSeriesIndices = []) : s2 = this.emptyCollapsedSeries(s2), a2.config.series = s2, t3 &amp;&amp; (e2 &amp;&amp; (a2.globals.zoomed = false, this.ctx.updateHelpers.revertDefaultAxisMinMax()), this.ctx.updateHelpers._updateSeries(s2, a2.config.chart.animations.dynamicAnimation.enabled));
  } }, { key: &quot;emptyCollapsedSeries&quot;, value: function(t3) {
    for (var e2 = this.w, i2 = 0; i2 &lt; t3.length; i2++) e2.globals.collapsedSeriesIndices.indexOf(i2) &gt; -1 &amp;&amp; (t3[i2].data = []);
    return t3;
  } }, { key: &quot;highlightSeries&quot;, value: function(t3) {
    var e2 = this.w, i2 = this.getSeriesByName(t3), a2 = parseInt(null == i2 ? void 0 : i2.getAttribute(&quot;data:realIndex&quot;), 10), s2 = e2.globals.dom.baseEl.querySelectorAll(&quot;.apexcharts-series, .apexcharts-datalabels, .apexcharts-yaxis&quot;), r2 = null, n2 = null, o2 = null;
    if (e2.globals.axisCharts || &quot;radialBar&quot; === e2.config.chart.type) if (e2.globals.axisCharts) {
      r2 = e2.globals.dom.baseEl.querySelector(&quot;.apexcharts-series[data\\:realIndex=&#x27;&quot;.concat(a2, &quot;&#x27;]&quot;)), n2 = e2.globals.dom.baseEl.querySelector(&quot;.apexcharts-datalabels[data\\:realIndex=&#x27;&quot;.concat(a2, &quot;&#x27;]&quot;));
      var l2 = e2.globals.seriesYAxisReverseMap[a2];
      o2 = e2.globals.dom.baseEl.querySelector(&quot;.apexcharts-yaxis[rel=&#x27;&quot;.concat(l2, &quot;&#x27;]&quot;));
    } else r2 = e2.globals.dom.baseEl.querySelector(&quot;.apexcharts-series[rel=&#x27;&quot;.concat(a2 + 1, &quot;&#x27;]&quot;));
    else r2 = e2.globals.dom.baseEl.querySelector(&quot;.apexcharts-series[rel=&#x27;&quot;.concat(a2 + 1, &quot;&#x27;] path&quot;));
    for (var h2 = 0; h2 &lt; s2.length; h2++) s2[h2].classList.add(this.legendInactiveClass);
    if (r2) e2.globals.axisCharts || r2.parentNode.classList.remove(this.legendInactiveClass), r2.classList.remove(this.legendInactiveClass), null !== n2 &amp;&amp; n2.classList.remove(this.legendInactiveClass), null !== o2 &amp;&amp; o2.classList.remove(this.legendInactiveClass);
    else for (var c2 = 0; c2 &lt; s2.length; c2++) s2[c2].classList.remove(this.legendInactiveClass);
  } }, { key: &quot;toggleSeriesOnHover&quot;, value: function(t3, e2) {
    var i2 = this.w;
    e2 || (e2 = t3.target);
    var a2 = i2.globals.dom.baseEl.querySelectorAll(&quot;.apexcharts-series, .apexcharts-datalabels, .apexcharts-yaxis&quot;);
    if (&quot;mousemove&quot; === t3.type) {
      var s2 = parseInt(e2.getAttribute(&quot;rel&quot;), 10) - 1;
      this.highlightSeries(i2.globals.seriesNames[s2]);
    } else if (&quot;mouseout&quot; === t3.type) for (var r2 = 0; r2 &lt; a2.length; r2++) a2[r2].classList.remove(this.legendInactiveClass);
  } }, { key: &quot;highlightRangeInSeries&quot;, value: function(t3, e2) {
    var i2 = this, a2 = this.w, s2 = a2.globals.dom.baseEl.getElementsByClassName(&quot;apexcharts-heatmap-rect&quot;), r2 = function(t4) {
      for (var e3 = 0; e3 &lt; s2.length; e3++) s2[e3].classList[t4](i2.legendInactiveClass);
    };
    if (&quot;mousemove&quot; === t3.type) {
      var n2 = parseInt(e2.getAttribute(&quot;rel&quot;), 10) - 1;
      r2(&quot;add&quot;);
      var o2 = a2.config.plotOptions.heatmap.colorScale.ranges;
      !function(t4, e3) {
        for (var a3 = 0; a3 &lt; s2.length; a3++) {
          var r3 = Number(s2[a3].getAttribute(&quot;val&quot;));
          r3 &gt;= t4.from &amp;&amp; (r3 &lt; t4.to || t4.to === e3 &amp;&amp; r3 === e3) &amp;&amp; s2[a3].classList.remove(i2.legendInactiveClass);
        }
      }(o2[n2], o2.reduce(function(t4, e3) {
        return Math.max(t4, e3.to);
      }, 0));
    } else &quot;mouseout&quot; === t3.type &amp;&amp; r2(&quot;remove&quot;);
  } }, { key: &quot;getActiveConfigSeriesIndex&quot;, value: function() {
    var t3 = arguments.length &gt; 0 &amp;&amp; void 0 !== arguments[0] ? arguments[0] : &quot;asc&quot;, e2 = arguments.length &gt; 1 &amp;&amp; void 0 !== arguments[1] ? arguments[1] : [], i2 = this.w, a2 = 0;
    if (i2.config.series.length &gt; 1) {
      for (var s2 = i2.config.series.map(function(t4, a3) {
        return t4.data &amp;&amp; t4.data.length &gt; 0 &amp;&amp; -1 === i2.globals.collapsedSeriesIndices.indexOf(a3) &amp;&amp; (!i2.globals.comboCharts || 0 === e2.length || e2.length &amp;&amp; e2.indexOf(i2.config.series[a3].type) &gt; -1) ? a3 : -1;
      }), r2 = &quot;asc&quot; === t3 ? 0 : s2.length - 1; &quot;asc&quot; === t3 ? r2 &lt; s2.length : r2 &gt;= 0; &quot;asc&quot; === t3 ? r2++ : r2--) if (-1 !== s2[r2]) {
        a2 = s2[r2];
        break;
      }
    }
    return a2;
  } }, { key: &quot;getBarSeriesIndices&quot;, value: function() {
    return this.w.globals.comboCharts ? this.w.config.series.map(function(t3, e2) {
      return &quot;bar&quot; === t3.type || &quot;column&quot; === t3.type ? e2 : -1;
    }).filter(function(t3) {
      return -1 !== t3;
    }) : this.w.config.series.map(function(t3, e2) {
      return e2;
    });
  } }, { key: &quot;getPreviousPaths&quot;, value: function() {
    var t3 = this.w;
    function e2(e3, i3, a3) {
      for (var s3 = e3[i3].childNodes, r2 = { type: a3, paths: [], realIndex: e3[i3].getAttribute(&quot;data:realIndex&quot;) }, n2 = 0; n2 &lt; s3.length; n2++) if (s3[n2].hasAttribute(&quot;pathTo&quot;)) {
        var o2 = s3[n2].getAttribute(&quot;pathTo&quot;);
        r2.paths.push({ d: o2 });
      }
      t3.globals.previousPaths.push(r2);
    }
    t3.globals.previousPaths = [];
    [&quot;line&quot;, &quot;area&quot;, &quot;bar&quot;, &quot;rangebar&quot;, &quot;rangeArea&quot;, &quot;candlestick&quot;, &quot;radar&quot;].forEach(function(i3) {
      for (var a3, s3 = (a3 = i3, t3.globals.dom.baseEl.querySelectorAll(&quot;.apexcharts-&quot;.concat(a3, &quot;-series .apexcharts-series&quot;))), r2 = 0; r2 &lt; s3.length; r2++) e2(s3, r2, i3);
    });
    var i2 = t3.globals.dom.baseEl.querySelectorAll(&quot;.apexcharts-&quot;.concat(t3.config.chart.type, &quot; .apexcharts-series&quot;));
    if (i2.length &gt; 0) for (var a2 = function(e3) {
      for (var i3 = t3.globals.dom.baseEl.querySelectorAll(&quot;.apexcharts-&quot;.concat(t3.config.chart.type, &quot; .apexcharts-series[data\\:realIndex=&#x27;&quot;).concat(e3, &quot;&#x27;] rect&quot;)), a3 = [], s3 = function(t4) {
        var e4 = function(e5) {
          return i3[t4].getAttribute(e5);
        }, s4 = { x: parseFloat(e4(&quot;x&quot;)), y: parseFloat(e4(&quot;y&quot;)), width: parseFloat(e4(&quot;width&quot;)), height: parseFloat(e4(&quot;height&quot;)) };
        a3.push({ rect: s4, color: i3[t4].getAttribute(&quot;color&quot;) });
      }, r2 = 0; r2 &lt; i3.length; r2++) s3(r2);
      t3.globals.previousPaths.push(a3);
    }, s2 = 0; s2 &lt; i2.length; s2++) a2(s2);
    t3.globals.axisCharts || (t3.globals.previousPaths = t3.globals.series);
  } }, { key: &quot;clearPreviousPaths&quot;, value: function() {
    var t3 = this.w;
    t3.globals.previousPaths = [], t3.globals.allSeriesCollapsed = false;
  } }, { key: &quot;handleNoData&quot;, value: function() {
    var t3 = this.w, e2 = t3.config.noData, i2 = new Mi(this.ctx), a2 = t3.globals.svgWidth / 2, s2 = t3.globals.svgHeight / 2, r2 = &quot;middle&quot;;
    if (t3.globals.noData = true, t3.globals.animationEnded = true, &quot;left&quot; === e2.align ? (a2 = 10, r2 = &quot;start&quot;) : &quot;right&quot; === e2.align &amp;&amp; (a2 = t3.globals.svgWidth - 10, r2 = &quot;end&quot;), &quot;top&quot; === e2.verticalAlign ? s2 = 50 : &quot;bottom&quot; === e2.verticalAlign &amp;&amp; (s2 = t3.globals.svgHeight - 50), a2 += e2.offsetX, s2 = s2 + parseInt(e2.style.fontSize, 10) + 2 + e2.offsetY, void 0 !== e2.text &amp;&amp; &quot;&quot; !== e2.text) {
      var n2 = i2.drawText({ x: a2, y: s2, text: e2.text, textAnchor: r2, fontSize: e2.style.fontSize, fontFamily: e2.style.fontFamily, foreColor: e2.style.color, opacity: 1, class: &quot;apexcharts-text-nodata&quot; });
      t3.globals.dom.Paper.add(n2);
    }
  } }, { key: &quot;setNullSeriesToZeroValues&quot;, value: function(t3) {
    for (var e2 = this.w, i2 = 0; i2 &lt; t3.length; i2++) if (0 === t3[i2].length) for (var a2 = 0; a2 &lt; t3[e2.globals.maxValsInArrayIndex].length; a2++) t3[i2].push(0);
    return t3;
  } }, { key: &quot;hasAllSeriesEqualX&quot;, value: function() {
    for (var t3 = true, e2 = this.w, i2 = this.filteredSeriesX(), a2 = 0; a2 &lt; i2.length - 1; a2++) if (i2[a2][0] !== i2[a2 + 1][0]) {
      t3 = false;
      break;
    }
    return e2.globals.allSeriesHasEqualX = t3, t3;
  } }, { key: &quot;filteredSeriesX&quot;, value: function() {
    var t3 = this.w.globals.seriesX.map(function(t4) {
      return t4.length &gt; 0 ? t4 : [];
    });
    return t3;
  } }]), t2;
}();
var $i = function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w, this.twoDSeries = [], this.threeDSeries = [], this.twoDSeriesX = [], this.seriesGoals = [], this.coreUtils = new Pi(this.ctx);
  }
  return s(t2, [{ key: &quot;isMultiFormat&quot;, value: function() {
    return this.isFormatXY() || this.isFormat2DArray();
  } }, { key: &quot;isFormatXY&quot;, value: function() {
    var t3 = this.w.config.series.slice(), e2 = new Zi(this.ctx);
    if (this.activeSeriesIndex = e2.getActiveConfigSeriesIndex(), void 0 !== t3[this.activeSeriesIndex].data &amp;&amp; t3[this.activeSeriesIndex].data.length &gt; 0 &amp;&amp; null !== t3[this.activeSeriesIndex].data[0] &amp;&amp; void 0 !== t3[this.activeSeriesIndex].data[0].x &amp;&amp; null !== t3[this.activeSeriesIndex].data[0]) return true;
  } }, { key: &quot;isFormat2DArray&quot;, value: function() {
    var t3 = this.w.config.series.slice(), e2 = new Zi(this.ctx);
    if (this.activeSeriesIndex = e2.getActiveConfigSeriesIndex(), void 0 !== t3[this.activeSeriesIndex].data &amp;&amp; t3[this.activeSeriesIndex].data.length &gt; 0 &amp;&amp; void 0 !== t3[this.activeSeriesIndex].data[0] &amp;&amp; null !== t3[this.activeSeriesIndex].data[0] &amp;&amp; t3[this.activeSeriesIndex].data[0].constructor === Array) return true;
  } }, { key: &quot;handleFormat2DArray&quot;, value: function(t3, e2) {
    for (var i2 = this.w.config, a2 = this.w.globals, s2 = &quot;boxPlot&quot; === i2.chart.type || &quot;boxPlot&quot; === i2.series[e2].type, r2 = 0; r2 &lt; t3[e2].data.length; r2++) if (void 0 !== t3[e2].data[r2][1] &amp;&amp; (Array.isArray(t3[e2].data[r2][1]) &amp;&amp; 4 === t3[e2].data[r2][1].length &amp;&amp; !s2 ? this.twoDSeries.push(v.parseNumber(t3[e2].data[r2][1][3])) : t3[e2].data[r2].length &gt;= 5 ? this.twoDSeries.push(v.parseNumber(t3[e2].data[r2][4])) : this.twoDSeries.push(v.parseNumber(t3[e2].data[r2][1])), a2.dataFormatXNumeric = true), &quot;datetime&quot; === i2.xaxis.type) {
      var n2 = new Date(t3[e2].data[r2][0]);
      n2 = new Date(n2).getTime(), this.twoDSeriesX.push(n2);
    } else this.twoDSeriesX.push(t3[e2].data[r2][0]);
    for (var o2 = 0; o2 &lt; t3[e2].data.length; o2++) void 0 !== t3[e2].data[o2][2] &amp;&amp; (this.threeDSeries.push(t3[e2].data[o2][2]), a2.isDataXYZ = true);
  } }, { key: &quot;handleFormatXY&quot;, value: function(t3, e2) {
    var i2 = this.w.config, a2 = this.w.globals, s2 = new zi(this.ctx), r2 = e2;
    a2.collapsedSeriesIndices.indexOf(e2) &gt; -1 &amp;&amp; (r2 = this.activeSeriesIndex);
    for (var n2 = 0; n2 &lt; t3[e2].data.length; n2++) void 0 !== t3[e2].data[n2].y &amp;&amp; (Array.isArray(t3[e2].data[n2].y) ? this.twoDSeries.push(v.parseNumber(t3[e2].data[n2].y[t3[e2].data[n2].y.length - 1])) : this.twoDSeries.push(v.parseNumber(t3[e2].data[n2].y))), void 0 !== t3[e2].data[n2].goals &amp;&amp; Array.isArray(t3[e2].data[n2].goals) ? (void 0 === this.seriesGoals[e2] &amp;&amp; (this.seriesGoals[e2] = []), this.seriesGoals[e2].push(t3[e2].data[n2].goals)) : (void 0 === this.seriesGoals[e2] &amp;&amp; (this.seriesGoals[e2] = []), this.seriesGoals[e2].push(null));
    for (var o2 = 0; o2 &lt; t3[r2].data.length; o2++) {
      var l2 = &quot;string&quot; == typeof t3[r2].data[o2].x, h2 = Array.isArray(t3[r2].data[o2].x), c2 = !h2 &amp;&amp; !!s2.isValidDate(t3[r2].data[o2].x);
      if (l2 || c2) if (l2 || i2.xaxis.convertedCatToNumeric) {
        var d2 = a2.isBarHorizontal &amp;&amp; a2.isRangeData;
        &quot;datetime&quot; !== i2.xaxis.type || d2 ? (this.fallbackToCategory = true, this.twoDSeriesX.push(t3[r2].data[o2].x), isNaN(t3[r2].data[o2].x) || &quot;category&quot; === this.w.config.xaxis.type || &quot;string&quot; == typeof t3[r2].data[o2].x || (a2.isXNumeric = true)) : this.twoDSeriesX.push(s2.parseDate(t3[r2].data[o2].x));
      } else &quot;datetime&quot; === i2.xaxis.type ? this.twoDSeriesX.push(s2.parseDate(t3[r2].data[o2].x.toString())) : (a2.dataFormatXNumeric = true, a2.isXNumeric = true, this.twoDSeriesX.push(parseFloat(t3[r2].data[o2].x)));
      else h2 ? (this.fallbackToCategory = true, this.twoDSeriesX.push(t3[r2].data[o2].x)) : (a2.isXNumeric = true, a2.dataFormatXNumeric = true, this.twoDSeriesX.push(t3[r2].data[o2].x));
    }
    if (t3[e2].data[0] &amp;&amp; void 0 !== t3[e2].data[0].z) {
      for (var u2 = 0; u2 &lt; t3[e2].data.length; u2++) this.threeDSeries.push(t3[e2].data[u2].z);
      a2.isDataXYZ = true;
    }
  } }, { key: &quot;handleRangeData&quot;, value: function(t3, e2) {
    var i2 = this.w.globals, a2 = {};
    return this.isFormat2DArray() ? a2 = this.handleRangeDataFormat(&quot;array&quot;, t3, e2) : this.isFormatXY() &amp;&amp; (a2 = this.handleRangeDataFormat(&quot;xy&quot;, t3, e2)), i2.seriesRangeStart.push(void 0 === a2.start ? [] : a2.start), i2.seriesRangeEnd.push(void 0 === a2.end ? [] : a2.end), i2.seriesRange.push(a2.rangeUniques), i2.seriesRange.forEach(function(t4, e3) {
      t4 &amp;&amp; t4.forEach(function(t5, e4) {
        t5.y.forEach(function(e5, i3) {
          for (var a3 = 0; a3 &lt; t5.y.length; a3++) if (i3 !== a3) {
            var s2 = e5.y1, r2 = e5.y2, n2 = t5.y[a3].y1;
            s2 &lt;= t5.y[a3].y2 &amp;&amp; n2 &lt;= r2 &amp;&amp; (t5.overlaps.indexOf(e5.rangeName) &lt; 0 &amp;&amp; t5.overlaps.push(e5.rangeName), t5.overlaps.indexOf(t5.y[a3].rangeName) &lt; 0 &amp;&amp; t5.overlaps.push(t5.y[a3].rangeName));
          }
        });
      });
    }), a2;
  } }, { key: &quot;handleCandleStickBoxData&quot;, value: function(t3, e2) {
    var i2 = this.w.globals, a2 = {};
    return this.isFormat2DArray() ? a2 = this.handleCandleStickBoxDataFormat(&quot;array&quot;, t3, e2) : this.isFormatXY() &amp;&amp; (a2 = this.handleCandleStickBoxDataFormat(&quot;xy&quot;, t3, e2)), i2.seriesCandleO[e2] = a2.o, i2.seriesCandleH[e2] = a2.h, i2.seriesCandleM[e2] = a2.m, i2.seriesCandleL[e2] = a2.l, i2.seriesCandleC[e2] = a2.c, a2;
  } }, { key: &quot;handleRangeDataFormat&quot;, value: function(t3, e2, i2) {
    var a2 = [], s2 = [], r2 = e2[i2].data.filter(function(t4, e3, i3) {
      return e3 === i3.findIndex(function(e4) {
        return e4.x === t4.x;
      });
    }).map(function(t4, e3) {
      return { x: t4.x, overlaps: [], y: [] };
    });
    if (&quot;array&quot; === t3) for (var n2 = 0; n2 &lt; e2[i2].data.length; n2++) Array.isArray(e2[i2].data[n2]) ? (a2.push(e2[i2].data[n2][1][0]), s2.push(e2[i2].data[n2][1][1])) : (a2.push(e2[i2].data[n2]), s2.push(e2[i2].data[n2]));
    else if (&quot;xy&quot; === t3) for (var o2 = function(t4) {
      var n3 = Array.isArray(e2[i2].data[t4].y), o3 = v.randomId(), l3 = e2[i2].data[t4].x, h2 = { y1: n3 ? e2[i2].data[t4].y[0] : e2[i2].data[t4].y, y2: n3 ? e2[i2].data[t4].y[1] : e2[i2].data[t4].y, rangeName: o3 };
      e2[i2].data[t4].rangeName = o3;
      var c2 = r2.findIndex(function(t5) {
        return t5.x === l3;
      });
      r2[c2].y.push(h2), a2.push(h2.y1), s2.push(h2.y2);
    }, l2 = 0; l2 &lt; e2[i2].data.length; l2++) o2(l2);
    return { start: a2, end: s2, rangeUniques: r2 };
  } }, { key: &quot;handleCandleStickBoxDataFormat&quot;, value: function(t3, e2, i2) {
    var a2 = this.w, s2 = &quot;boxPlot&quot; === a2.config.chart.type || &quot;boxPlot&quot; === a2.config.series[i2].type, r2 = [], n2 = [], o2 = [], l2 = [], h2 = [];
    if (&quot;array&quot; === t3) if (s2 &amp;&amp; 6 === e2[i2].data[0].length || !s2 &amp;&amp; 5 === e2[i2].data[0].length) for (var c2 = 0; c2 &lt; e2[i2].data.length; c2++) r2.push(e2[i2].data[c2][1]), n2.push(e2[i2].data[c2][2]), s2 ? (o2.push(e2[i2].data[c2][3]), l2.push(e2[i2].data[c2][4]), h2.push(e2[i2].data[c2][5])) : (l2.push(e2[i2].data[c2][3]), h2.push(e2[i2].data[c2][4]));
    else for (var d2 = 0; d2 &lt; e2[i2].data.length; d2++) Array.isArray(e2[i2].data[d2][1]) &amp;&amp; (r2.push(e2[i2].data[d2][1][0]), n2.push(e2[i2].data[d2][1][1]), s2 ? (o2.push(e2[i2].data[d2][1][2]), l2.push(e2[i2].data[d2][1][3]), h2.push(e2[i2].data[d2][1][4])) : (l2.push(e2[i2].data[d2][1][2]), h2.push(e2[i2].data[d2][1][3])));
    else if (&quot;xy&quot; === t3) for (var u2 = 0; u2 &lt; e2[i2].data.length; u2++) Array.isArray(e2[i2].data[u2].y) &amp;&amp; (r2.push(e2[i2].data[u2].y[0]), n2.push(e2[i2].data[u2].y[1]), s2 ? (o2.push(e2[i2].data[u2].y[2]), l2.push(e2[i2].data[u2].y[3]), h2.push(e2[i2].data[u2].y[4])) : (l2.push(e2[i2].data[u2].y[2]), h2.push(e2[i2].data[u2].y[3])));
    return { o: r2, h: n2, m: o2, l: l2, c: h2 };
  } }, { key: &quot;parseDataAxisCharts&quot;, value: function(t3) {
    var e2 = this, i2 = arguments.length &gt; 1 &amp;&amp; void 0 !== arguments[1] ? arguments[1] : this.ctx, a2 = this.w.config, s2 = this.w.globals, r2 = new zi(i2), n2 = a2.labels.length &gt; 0 ? a2.labels.slice() : a2.xaxis.categories.slice();
    s2.isRangeBar = &quot;rangeBar&quot; === a2.chart.type &amp;&amp; s2.isBarHorizontal, s2.hasXaxisGroups = &quot;category&quot; === a2.xaxis.type &amp;&amp; a2.xaxis.group.groups.length &gt; 0, s2.hasXaxisGroups &amp;&amp; (s2.groups = a2.xaxis.group.groups), t3.forEach(function(t4, e3) {
      void 0 !== t4.name ? s2.seriesNames.push(t4.name) : s2.seriesNames.push(&quot;series-&quot; + parseInt(e3 + 1, 10));
    }), this.coreUtils.setSeriesYAxisMappings();
    var o2 = [], l2 = f(new Set(a2.series.map(function(t4) {
      return t4.group;
    })));
    a2.series.forEach(function(t4, e3) {
      var i3 = l2.indexOf(t4.group);
      o2[i3] || (o2[i3] = []), o2[i3].push(s2.seriesNames[e3]);
    }), s2.seriesGroups = o2;
    for (var h2 = function() {
      for (var t4 = 0; t4 &lt; n2.length; t4++) if (&quot;string&quot; == typeof n2[t4]) {
        if (!r2.isValidDate(n2[t4])) throw new Error(&quot;You have provided invalid Date format. Please provide a valid JavaScript Date&quot;);
        e2.twoDSeriesX.push(r2.parseDate(n2[t4]));
      } else e2.twoDSeriesX.push(n2[t4]);
    }, c2 = 0; c2 &lt; t3.length; c2++) {
      if (this.twoDSeries = [], this.twoDSeriesX = [], this.threeDSeries = [], void 0 === t3[c2].data) return void console.error(&quot;It is a possibility that you may have not included &#x27;data&#x27; property in series.&quot;);
      if (&quot;rangeBar&quot; !== a2.chart.type &amp;&amp; &quot;rangeArea&quot; !== a2.chart.type &amp;&amp; &quot;rangeBar&quot; !== t3[c2].type &amp;&amp; &quot;rangeArea&quot; !== t3[c2].type || (s2.isRangeData = true, &quot;rangeBar&quot; !== a2.chart.type &amp;&amp; &quot;rangeArea&quot; !== a2.chart.type || this.handleRangeData(t3, c2)), this.isMultiFormat()) this.isFormat2DArray() ? this.handleFormat2DArray(t3, c2) : this.isFormatXY() &amp;&amp; this.handleFormatXY(t3, c2), &quot;candlestick&quot; !== a2.chart.type &amp;&amp; &quot;candlestick&quot; !== t3[c2].type &amp;&amp; &quot;boxPlot&quot; !== a2.chart.type &amp;&amp; &quot;boxPlot&quot; !== t3[c2].type || this.handleCandleStickBoxData(t3, c2), s2.series.push(this.twoDSeries), s2.labels.push(this.twoDSeriesX), s2.seriesX.push(this.twoDSeriesX), s2.seriesGoals = this.seriesGoals, c2 !== this.activeSeriesIndex || this.fallbackToCategory || (s2.isXNumeric = true);
      else {
        &quot;datetime&quot; === a2.xaxis.type ? (s2.isXNumeric = true, h2(), s2.seriesX.push(this.twoDSeriesX)) : &quot;numeric&quot; === a2.xaxis.type &amp;&amp; (s2.isXNumeric = true, n2.length &gt; 0 &amp;&amp; (this.twoDSeriesX = n2, s2.seriesX.push(this.twoDSeriesX))), s2.labels.push(this.twoDSeriesX);
        var d2 = t3[c2].data.map(function(t4) {
          return v.parseNumber(t4);
        });
        s2.series.push(d2);
      }
      s2.seriesZ.push(this.threeDSeries), void 0 !== t3[c2].color ? s2.seriesColors.push(t3[c2].color) : s2.seriesColors.push(void 0);
    }
    return this.w;
  } }, { key: &quot;parseDataNonAxisCharts&quot;, value: function(t3) {
    var e2 = this.w.globals, i2 = this.w.config;
    e2.series = t3.slice(), e2.seriesNames = i2.labels.slice();
    for (var a2 = 0; a2 &lt; e2.series.length; a2++) void 0 === e2.seriesNames[a2] &amp;&amp; e2.seriesNames.push(&quot;series-&quot; + (a2 + 1));
    return this.w;
  } }, { key: &quot;handleExternalLabelsData&quot;, value: function(t3) {
    var e2 = this.w.config, i2 = this.w.globals;
    if (e2.xaxis.categories.length &gt; 0) i2.labels = e2.xaxis.categories;
    else if (e2.labels.length &gt; 0) i2.labels = e2.labels.slice();
    else if (this.fallbackToCategory) {
      if (i2.labels = i2.labels[0], i2.seriesRange.length &amp;&amp; (i2.seriesRange.map(function(t4) {
        t4.forEach(function(t5) {
          i2.labels.indexOf(t5.x) &lt; 0 &amp;&amp; t5.x &amp;&amp; i2.labels.push(t5.x);
        });
      }), i2.labels = Array.from(new Set(i2.labels.map(JSON.stringify)), JSON.parse)), e2.xaxis.convertedCatToNumeric) new Ni(e2).convertCatToNumericXaxis(e2, this.ctx, i2.seriesX[0]), this._generateExternalLabels(t3);
    } else this._generateExternalLabels(t3);
  } }, { key: &quot;_generateExternalLabels&quot;, value: function(t3) {
    var e2 = this.w.globals, i2 = this.w.config, a2 = [];
    if (e2.axisCharts) {
      if (e2.series.length &gt; 0) if (this.isFormatXY()) for (var s2 = i2.series.map(function(t4, e3) {
        return t4.data.filter(function(t5, e4, i3) {
          return i3.findIndex(function(e5) {
            return e5.x === t5.x;
          }) === e4;
        });
      }), r2 = s2.reduce(function(t4, e3, i3, a3) {
        return a3[t4].length &gt; e3.length ? t4 : i3;
      }, 0), n2 = 0; n2 &lt; s2[r2].length; n2++) a2.push(n2 + 1);
      else for (var o2 = 0; o2 &lt; e2.series[e2.maxValsInArrayIndex].length; o2++) a2.push(o2 + 1);
      e2.seriesX = [];
      for (var l2 = 0; l2 &lt; t3.length; l2++) e2.seriesX.push(a2);
      this.w.globals.isBarHorizontal || (e2.isXNumeric = true);
    }
    if (0 === a2.length) {
      a2 = e2.axisCharts ? [] : e2.series.map(function(t4, e3) {
        return e3 + 1;
      });
      for (var h2 = 0; h2 &lt; t3.length; h2++) e2.seriesX.push(a2);
    }
    e2.labels = a2, i2.xaxis.convertedCatToNumeric &amp;&amp; (e2.categoryLabels = a2.map(function(t4) {
      return i2.xaxis.labels.formatter(t4);
    })), e2.noLabelsProvided = true;
  } }, { key: &quot;parseData&quot;, value: function(t3) {
    var e2 = this.w, i2 = e2.config, a2 = e2.globals;
    if (this.excludeCollapsedSeriesInYAxis(), this.fallbackToCategory = false, this.ctx.core.resetGlobals(), this.ctx.core.isMultipleY(), a2.axisCharts ? (this.parseDataAxisCharts(t3), this.coreUtils.getLargestSeries()) : this.parseDataNonAxisCharts(t3), i2.chart.stacked) {
      var s2 = new Zi(this.ctx);
      a2.series = s2.setNullSeriesToZeroValues(a2.series);
    }
    this.coreUtils.getSeriesTotals(), a2.axisCharts &amp;&amp; (a2.stackedSeriesTotals = this.coreUtils.getStackedSeriesTotals(), a2.stackedSeriesTotalsByGroups = this.coreUtils.getStackedSeriesTotalsByGroups()), this.coreUtils.getPercentSeries(), a2.dataFormatXNumeric || a2.isXNumeric &amp;&amp; (&quot;numeric&quot; !== i2.xaxis.type || 0 !== i2.labels.length || 0 !== i2.xaxis.categories.length) || this.handleExternalLabelsData(t3);
    for (var r2 = this.coreUtils.getCategoryLabels(a2.labels), n2 = 0; n2 &lt; r2.length; n2++) if (Array.isArray(r2[n2])) {
      a2.isMultiLineX = true;
      break;
    }
  } }, { key: &quot;excludeCollapsedSeriesInYAxis&quot;, value: function() {
    var t3 = this.w, e2 = [];
    t3.globals.seriesYAxisMap.forEach(function(i2, a2) {
      var s2 = 0;
      i2.forEach(function(e3) {
        -1 !== t3.globals.collapsedSeriesIndices.indexOf(e3) &amp;&amp; s2++;
      }), s2 &gt; 0 &amp;&amp; s2 == i2.length &amp;&amp; e2.push(a2);
    }), t3.globals.ignoreYAxisIndexes = e2.map(function(t4) {
      return t4;
    });
  } }]), t2;
}();
var Ji = function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w;
  }
  return s(t2, [{ key: &quot;svgStringToNode&quot;, value: function(t3) {
    return new DOMParser().parseFromString(t3, &quot;image/svg+xml&quot;).documentElement;
  } }, { key: &quot;scaleSvgNode&quot;, value: function(t3, e2) {
    var i2 = parseFloat(t3.getAttributeNS(null, &quot;width&quot;)), a2 = parseFloat(t3.getAttributeNS(null, &quot;height&quot;));
    t3.setAttributeNS(null, &quot;width&quot;, i2 * e2), t3.setAttributeNS(null, &quot;height&quot;, a2 * e2), t3.setAttributeNS(null, &quot;viewBox&quot;, &quot;0 0 &quot; + i2 + &quot; &quot; + a2);
  } }, { key: &quot;getSvgString&quot;, value: function(t3) {
    var e2 = this;
    return new Promise(function(i2) {
      var a2 = e2.w, s2 = t3 || a2.config.chart.toolbar.export.scale || a2.config.chart.toolbar.export.width / a2.globals.svgWidth;
      s2 || (s2 = 1);
      var r2 = a2.globals.svgWidth * s2, n2 = a2.globals.svgHeight * s2, o2 = a2.globals.dom.elWrap.cloneNode(true);
      o2.style.width = r2 + &quot;px&quot;, o2.style.height = n2 + &quot;px&quot;;
      var l2 = new XMLSerializer().serializeToString(o2), h2 = &#x27;\n        &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot;\n          version=&quot;1.1&quot;\n          xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot;\n          class=&quot;apexcharts-svg&quot;\n          xmlns:data=&quot;ApexChartsNS&quot;\n          transform=&quot;translate(0, 0)&quot;\n          width=&quot;&#x27;.concat(a2.globals.svgWidth, &#x27;px&quot; height=&quot;&#x27;).concat(a2.globals.svgHeight, &#x27;px&quot;&gt;\n          &lt;foreignObject width=&quot;100%&quot; height=&quot;100%&quot;&gt;\n            &lt;div xmlns=&quot;http://www.w3.org/1999/xhtml&quot; style=&quot;width:&#x27;).concat(r2, &quot;px; height:&quot;).concat(n2, &#x27;px;&quot;&gt;\n            &lt;style type=&quot;text/css&quot;&gt;\n              .apexcharts-tooltip, .apexcharts-toolbar, .apexcharts-xaxistooltip, .apexcharts-yaxistooltip, .apexcharts-xcrosshairs, .apexcharts-ycrosshairs, .apexcharts-zoom-rect, .apexcharts-selection-rect {\n                display: none;\n              }\n            &lt;/style&gt;\n              &#x27;).concat(l2, &quot;\n            &lt;/div&gt;\n          &lt;/foreignObject&gt;\n        &lt;/svg&gt;\n      &quot;), c2 = e2.svgStringToNode(h2);
      1 !== s2 &amp;&amp; e2.scaleSvgNode(c2, s2), e2.convertImagesToBase64(c2).then(function() {
        h2 = new XMLSerializer().serializeToString(c2), i2(h2.replace(/&amp;nbsp;/g, &quot;&amp;#160;&quot;));
      });
    });
  } }, { key: &quot;convertImagesToBase64&quot;, value: function(t3) {
    var e2 = this, i2 = t3.getElementsByTagName(&quot;image&quot;), a2 = Array.from(i2).map(function(t4) {
      var i3 = t4.getAttributeNS(&quot;http://www.w3.org/1999/xlink&quot;, &quot;href&quot;);
      return i3 &amp;&amp; !i3.startsWith(&quot;data:&quot;) ? e2.getBase64FromUrl(i3).then(function(e3) {
        t4.setAttributeNS(&quot;http://www.w3.org/1999/xlink&quot;, &quot;href&quot;, e3);
      }).catch(function(t5) {
        console.error(&quot;Error converting image to base64:&quot;, t5);
      }) : Promise.resolve();
    });
    return Promise.all(a2);
  } }, { key: &quot;getBase64FromUrl&quot;, value: function(t3) {
    return new Promise(function(e2, i2) {
      var a2 = new Image();
      a2.crossOrigin = &quot;Anonymous&quot;, a2.onload = function() {
        var t4 = document.createElement(&quot;canvas&quot;);
        t4.width = a2.width, t4.height = a2.height, t4.getContext(&quot;2d&quot;).drawImage(a2, 0, 0), e2(t4.toDataURL());
      }, a2.onerror = i2, a2.src = t3;
    });
  } }, { key: &quot;svgUrl&quot;, value: function() {
    var t3 = this;
    return new Promise(function(e2) {
      t3.getSvgString().then(function(t4) {
        var i2 = new Blob([t4], { type: &quot;image/svg+xml;charset=utf-8&quot; });
        e2(URL.createObjectURL(i2));
      });
    });
  } }, { key: &quot;dataURI&quot;, value: function(t3) {
    var e2 = this;
    return new Promise(function(i2) {
      var a2 = e2.w, s2 = t3 ? t3.scale || t3.width / a2.globals.svgWidth : 1, r2 = document.createElement(&quot;canvas&quot;);
      r2.width = a2.globals.svgWidth * s2, r2.height = parseInt(a2.globals.dom.elWrap.style.height, 10) * s2;
      var n2 = &quot;transparent&quot; !== a2.config.chart.background &amp;&amp; a2.config.chart.background ? a2.config.chart.background : &quot;#fff&quot;, o2 = r2.getContext(&quot;2d&quot;);
      o2.fillStyle = n2, o2.fillRect(0, 0, r2.width * s2, r2.height * s2), e2.getSvgString(s2).then(function(t4) {
        var e3 = &quot;data:image/svg+xml,&quot; + encodeURIComponent(t4), a3 = new Image();
        a3.crossOrigin = &quot;anonymous&quot;, a3.onload = function() {
          if (o2.drawImage(a3, 0, 0), r2.msToBlob) {
            var t5 = r2.msToBlob();
            i2({ blob: t5 });
          } else {
            var e4 = r2.toDataURL(&quot;image/png&quot;);
            i2({ imgURI: e4 });
          }
        }, a3.src = e3;
      });
    });
  } }, { key: &quot;exportToSVG&quot;, value: function() {
    var t3 = this;
    this.svgUrl().then(function(e2) {
      t3.triggerDownload(e2, t3.w.config.chart.toolbar.export.svg.filename, &quot;.svg&quot;);
    });
  } }, { key: &quot;exportToPng&quot;, value: function() {
    var t3 = this, e2 = this.w.config.chart.toolbar.export.scale, i2 = this.w.config.chart.toolbar.export.width, a2 = e2 ? { scale: e2 } : i2 ? { width: i2 } : void 0;
    this.dataURI(a2).then(function(e3) {
      var i3 = e3.imgURI, a3 = e3.blob;
      a3 ? navigator.msSaveOrOpenBlob(a3, t3.w.globals.chartID + &quot;.png&quot;) : t3.triggerDownload(i3, t3.w.config.chart.toolbar.export.png.filename, &quot;.png&quot;);
    });
  } }, { key: &quot;exportToCSV&quot;, value: function(t3) {
    var e2 = this, i2 = t3.series, a2 = t3.fileName, s2 = t3.columnDelimiter, r2 = void 0 === s2 ? &quot;,&quot; : s2, n2 = t3.lineDelimiter, o2 = void 0 === n2 ? &quot;\n&quot; : n2, l2 = this.w;
    i2 || (i2 = l2.config.series);
    var h2 = [], c2 = [], d2 = &quot;&quot;, u2 = l2.globals.series.map(function(t4, e3) {
      return -1 === l2.globals.collapsedSeriesIndices.indexOf(e3) ? t4 : [];
    }), g2 = function(t4) {
      return &quot;function&quot; == typeof l2.config.chart.toolbar.export.csv.categoryFormatter ? l2.config.chart.toolbar.export.csv.categoryFormatter(t4) : &quot;datetime&quot; === l2.config.xaxis.type &amp;&amp; String(t4).length &gt;= 10 ? new Date(t4).toDateString() : v.isNumber(t4) ? t4 : t4.split(r2).join(&quot;&quot;);
    }, p2 = function(t4) {
      return &quot;function&quot; == typeof l2.config.chart.toolbar.export.csv.valueFormatter ? l2.config.chart.toolbar.export.csv.valueFormatter(t4) : t4;
    }, x2 = Math.max.apply(Math, f(i2.map(function(t4) {
      return t4.data ? t4.data.length : 0;
    }))), b2 = new $i(this.ctx), m2 = new Ri(this.ctx), y2 = function(t4) {
      var i3 = &quot;&quot;;
      if (l2.globals.axisCharts) {
        if (&quot;category&quot; === l2.config.xaxis.type || l2.config.xaxis.convertedCatToNumeric) if (l2.globals.isBarHorizontal) {
          var a3 = l2.globals.yLabelFormatters[0], s3 = new Zi(e2.ctx).getActiveConfigSeriesIndex();
          i3 = a3(l2.globals.labels[t4], { seriesIndex: s3, dataPointIndex: t4, w: l2 });
        } else i3 = m2.getLabel(l2.globals.labels, l2.globals.timescaleLabels, 0, t4).text;
        &quot;datetime&quot; === l2.config.xaxis.type &amp;&amp; (l2.config.xaxis.categories.length ? i3 = l2.config.xaxis.categories[t4] : l2.config.labels.length &amp;&amp; (i3 = l2.config.labels[t4]));
      } else i3 = l2.config.labels[t4];
      return null === i3 ? &quot;nullvalue&quot; : (Array.isArray(i3) &amp;&amp; (i3 = i3.join(&quot; &quot;)), v.isNumber(i3) ? i3 : i3.split(r2).join(&quot;&quot;));
    }, w2 = function(t4, e3) {
      if (h2.length &amp;&amp; 0 === e3 &amp;&amp; c2.push(h2.join(r2)), t4.data) {
        t4.data = t4.data.length &amp;&amp; t4.data || f(Array(x2)).map(function() {
          return &quot;&quot;;
        });
        for (var a3 = 0; a3 &lt; t4.data.length; a3++) {
          h2 = [];
          var s3 = y2(a3);
          if (&quot;nullvalue&quot; !== s3) {
            if (s3 || (b2.isFormatXY() ? s3 = i2[e3].data[a3].x : b2.isFormat2DArray() &amp;&amp; (s3 = i2[e3].data[a3] ? i2[e3].data[a3][0] : &quot;&quot;)), 0 === e3) {
              h2.push(g2(s3));
              for (var n3 = 0; n3 &lt; l2.globals.series.length; n3++) {
                var o3, d3 = b2.isFormatXY() ? null === (o3 = i2[n3].data[a3]) || void 0 === o3 ? void 0 : o3.y : u2[n3][a3];
                h2.push(p2(d3));
              }
            }
            (&quot;candlestick&quot; === l2.config.chart.type || t4.type &amp;&amp; &quot;candlestick&quot; === t4.type) &amp;&amp; (h2.pop(), h2.push(l2.globals.seriesCandleO[e3][a3]), h2.push(l2.globals.seriesCandleH[e3][a3]), h2.push(l2.globals.seriesCandleL[e3][a3]), h2.push(l2.globals.seriesCandleC[e3][a3])), (&quot;boxPlot&quot; === l2.config.chart.type || t4.type &amp;&amp; &quot;boxPlot&quot; === t4.type) &amp;&amp; (h2.pop(), h2.push(l2.globals.seriesCandleO[e3][a3]), h2.push(l2.globals.seriesCandleH[e3][a3]), h2.push(l2.globals.seriesCandleM[e3][a3]), h2.push(l2.globals.seriesCandleL[e3][a3]), h2.push(l2.globals.seriesCandleC[e3][a3])), &quot;rangeBar&quot; === l2.config.chart.type &amp;&amp; (h2.pop(), h2.push(l2.globals.seriesRangeStart[e3][a3]), h2.push(l2.globals.seriesRangeEnd[e3][a3])), h2.length &amp;&amp; c2.push(h2.join(r2));
          }
        }
      }
    };
    h2.push(l2.config.chart.toolbar.export.csv.headerCategory), &quot;boxPlot&quot; === l2.config.chart.type ? (h2.push(&quot;minimum&quot;), h2.push(&quot;q1&quot;), h2.push(&quot;median&quot;), h2.push(&quot;q3&quot;), h2.push(&quot;maximum&quot;)) : &quot;candlestick&quot; === l2.config.chart.type ? (h2.push(&quot;open&quot;), h2.push(&quot;high&quot;), h2.push(&quot;low&quot;), h2.push(&quot;close&quot;)) : &quot;rangeBar&quot; === l2.config.chart.type ? (h2.push(&quot;minimum&quot;), h2.push(&quot;maximum&quot;)) : i2.map(function(t4, e3) {
      var i3 = (t4.name ? t4.name : &quot;series-&quot;.concat(e3)) + &quot;&quot;;
      l2.globals.axisCharts &amp;&amp; h2.push(i3.split(r2).join(&quot;&quot;) ? i3.split(r2).join(&quot;&quot;) : &quot;series-&quot;.concat(e3));
    }), l2.globals.axisCharts || (h2.push(l2.config.chart.toolbar.export.csv.headerValue), c2.push(h2.join(r2))), l2.globals.allSeriesHasEqualX || !l2.globals.axisCharts || l2.config.xaxis.categories.length || l2.config.labels.length ? i2.map(function(t4, e3) {
      l2.globals.axisCharts ? w2(t4, e3) : ((h2 = []).push(g2(l2.globals.labels[e3])), h2.push(p2(u2[e3])), c2.push(h2.join(r2)));
    }) : function() {
      var t4 = /* @__PURE__ */ new Set(), e3 = {};
      i2.forEach(function(a3, s3) {
        null == a3 || a3.data.forEach(function(a4) {
          var r3, n3;
          if (b2.isFormatXY()) r3 = a4.x, n3 = a4.y;
          else {
            if (!b2.isFormat2DArray()) return;
            r3 = a4[0], n3 = a4[1];
          }
          e3[r3] || (e3[r3] = Array(i2.length).fill(&quot;&quot;)), e3[r3][s3] = p2(n3), t4.add(r3);
        });
      }), h2.length &amp;&amp; c2.push(h2.join(r2)), Array.from(t4).sort().forEach(function(t5) {
        c2.push([g2(t5), e3[t5].join(r2)]);
      });
    }(), d2 += c2.join(o2), this.triggerDownload(&quot;data:text/csv; charset=utf-8,&quot; + encodeURIComponent(&quot;\uFEFF&quot; + d2), a2 || l2.config.chart.toolbar.export.csv.filename, &quot;.csv&quot;);
  } }, { key: &quot;triggerDownload&quot;, value: function(t3, e2, i2) {
    var a2 = document.createElement(&quot;a&quot;);
    a2.href = t3, a2.download = (e2 || this.w.globals.chartID) + i2, document.body.appendChild(a2), a2.click(), document.body.removeChild(a2);
  } }]), t2;
}();
var Qi = function() {
  function t2(e2, a2) {
    i(this, t2), this.ctx = e2, this.elgrid = a2, this.w = e2.w;
    var s2 = this.w;
    this.axesUtils = new Ri(e2), this.xaxisLabels = s2.globals.labels.slice(), s2.globals.timescaleLabels.length &gt; 0 &amp;&amp; !s2.globals.isBarHorizontal &amp;&amp; (this.xaxisLabels = s2.globals.timescaleLabels.slice()), s2.config.xaxis.overwriteCategories &amp;&amp; (this.xaxisLabels = s2.config.xaxis.overwriteCategories), this.drawnLabels = [], this.drawnLabelsRects = [], &quot;top&quot; === s2.config.xaxis.position ? this.offY = 0 : this.offY = s2.globals.gridHeight, this.offY = this.offY + s2.config.xaxis.axisBorder.offsetY, this.isCategoryBarHorizontal = &quot;bar&quot; === s2.config.chart.type &amp;&amp; s2.config.plotOptions.bar.horizontal, this.xaxisFontSize = s2.config.xaxis.labels.style.fontSize, this.xaxisFontFamily = s2.config.xaxis.labels.style.fontFamily, this.xaxisForeColors = s2.config.xaxis.labels.style.colors, this.xaxisBorderWidth = s2.config.xaxis.axisBorder.width, this.isCategoryBarHorizontal &amp;&amp; (this.xaxisBorderWidth = s2.config.yaxis[0].axisBorder.width.toString()), this.xaxisBorderWidth.indexOf(&quot;%&quot;) &gt; -1 ? this.xaxisBorderWidth = s2.globals.gridWidth * parseInt(this.xaxisBorderWidth, 10) / 100 : this.xaxisBorderWidth = parseInt(this.xaxisBorderWidth, 10), this.xaxisBorderHeight = s2.config.xaxis.axisBorder.height, this.yaxis = s2.config.yaxis[0];
  }
  return s(t2, [{ key: &quot;drawXaxis&quot;, value: function() {
    var t3 = this.w, e2 = new Mi(this.ctx), i2 = e2.group({ class: &quot;apexcharts-xaxis&quot;, transform: &quot;translate(&quot;.concat(t3.config.xaxis.offsetX, &quot;, &quot;).concat(t3.config.xaxis.offsetY, &quot;)&quot;) }), a2 = e2.group({ class: &quot;apexcharts-xaxis-texts-g&quot;, transform: &quot;translate(&quot;.concat(t3.globals.translateXAxisX, &quot;, &quot;).concat(t3.globals.translateXAxisY, &quot;)&quot;) });
    i2.add(a2);
    for (var s2 = [], r2 = 0; r2 &lt; this.xaxisLabels.length; r2++) s2.push(this.xaxisLabels[r2]);
    if (this.drawXAxisLabelAndGroup(true, e2, a2, s2, t3.globals.isXNumeric, function(t4, e3) {
      return e3;
    }), t3.globals.hasXaxisGroups) {
      var n2 = t3.globals.groups;
      s2 = [];
      for (var o2 = 0; o2 &lt; n2.length; o2++) s2.push(n2[o2].title);
      var l2 = {};
      t3.config.xaxis.group.style &amp;&amp; (l2.xaxisFontSize = t3.config.xaxis.group.style.fontSize, l2.xaxisFontFamily = t3.config.xaxis.group.style.fontFamily, l2.xaxisForeColors = t3.config.xaxis.group.style.colors, l2.fontWeight = t3.config.xaxis.group.style.fontWeight, l2.cssClass = t3.config.xaxis.group.style.cssClass), this.drawXAxisLabelAndGroup(false, e2, a2, s2, false, function(t4, e3) {
        return n2[t4].cols * e3;
      }, l2);
    }
    if (void 0 !== t3.config.xaxis.title.text) {
      var h2 = e2.group({ class: &quot;apexcharts-xaxis-title&quot; }), c2 = e2.drawText({ x: t3.globals.gridWidth / 2 + t3.config.xaxis.title.offsetX, y: this.offY + parseFloat(this.xaxisFontSize) + (&quot;bottom&quot; === t3.config.xaxis.position ? t3.globals.xAxisLabelsHeight : -t3.globals.xAxisLabelsHeight - 10) + t3.config.xaxis.title.offsetY, text: t3.config.xaxis.title.text, textAnchor: &quot;middle&quot;, fontSize: t3.config.xaxis.title.style.fontSize, fontFamily: t3.config.xaxis.title.style.fontFamily, fontWeight: t3.config.xaxis.title.style.fontWeight, foreColor: t3.config.xaxis.title.style.color, cssClass: &quot;apexcharts-xaxis-title-text &quot; + t3.config.xaxis.title.style.cssClass });
      h2.add(c2), i2.add(h2);
    }
    if (t3.config.xaxis.axisBorder.show) {
      var d2 = t3.globals.barPadForNumericAxis, u2 = e2.drawLine(t3.globals.padHorizontal + t3.config.xaxis.axisBorder.offsetX - d2, this.offY, this.xaxisBorderWidth + d2, this.offY, t3.config.xaxis.axisBorder.color, 0, this.xaxisBorderHeight);
      this.elgrid &amp;&amp; this.elgrid.elGridBorders &amp;&amp; t3.config.grid.show ? this.elgrid.elGridBorders.add(u2) : i2.add(u2);
    }
    return i2;
  } }, { key: &quot;drawXAxisLabelAndGroup&quot;, value: function(t3, e2, i2, a2, s2, r2) {
    var n2, o2 = this, l2 = arguments.length &gt; 6 &amp;&amp; void 0 !== arguments[6] ? arguments[6] : {}, h2 = [], c2 = [], d2 = this.w, u2 = l2.xaxisFontSize || this.xaxisFontSize, g2 = l2.xaxisFontFamily || this.xaxisFontFamily, p2 = l2.xaxisForeColors || this.xaxisForeColors, f2 = l2.fontWeight || d2.config.xaxis.labels.style.fontWeight, x2 = l2.cssClass || d2.config.xaxis.labels.style.cssClass, b2 = d2.globals.padHorizontal, m2 = a2.length, v2 = &quot;category&quot; === d2.config.xaxis.type ? d2.globals.dataPoints : m2;
    if (0 === v2 &amp;&amp; m2 &gt; v2 &amp;&amp; (v2 = m2), s2) {
      var y2 = Math.max(Number(d2.config.xaxis.tickAmount) || 1, v2 &gt; 1 ? v2 - 1 : v2);
      n2 = d2.globals.gridWidth / Math.min(y2, m2 - 1), b2 = b2 + r2(0, n2) / 2 + d2.config.xaxis.labels.offsetX;
    } else n2 = d2.globals.gridWidth / v2, b2 = b2 + r2(0, n2) + d2.config.xaxis.labels.offsetX;
    for (var w2 = function(s3) {
      var l3 = b2 - r2(s3, n2) / 2 + d2.config.xaxis.labels.offsetX;
      0 === s3 &amp;&amp; 1 === m2 &amp;&amp; n2 / 2 === b2 &amp;&amp; 1 === v2 &amp;&amp; (l3 = d2.globals.gridWidth / 2);
      var y3 = o2.axesUtils.getLabel(a2, d2.globals.timescaleLabels, l3, s3, h2, u2, t3), w3 = 28;
      d2.globals.rotateXLabels &amp;&amp; t3 &amp;&amp; (w3 = 22), d2.config.xaxis.title.text &amp;&amp; &quot;top&quot; === d2.config.xaxis.position &amp;&amp; (w3 += parseFloat(d2.config.xaxis.title.style.fontSize) + 2), t3 || (w3 = w3 + parseFloat(u2) + (d2.globals.xAxisLabelsHeight - d2.globals.xAxisGroupLabelsHeight) + (d2.globals.rotateXLabels ? 10 : 0)), y3 = void 0 !== d2.config.xaxis.tickAmount &amp;&amp; &quot;dataPoints&quot; !== d2.config.xaxis.tickAmount &amp;&amp; &quot;datetime&quot; !== d2.config.xaxis.type ? o2.axesUtils.checkLabelBasedOnTickamount(s3, y3, m2) : o2.axesUtils.checkForOverflowingLabels(s3, y3, m2, h2, c2);
      if (d2.config.xaxis.labels.show) {
        var k3 = e2.drawText({ x: y3.x, y: o2.offY + d2.config.xaxis.labels.offsetY + w3 - (&quot;top&quot; === d2.config.xaxis.position ? d2.globals.xAxisHeight + d2.config.xaxis.axisTicks.height - 2 : 0), text: y3.text, textAnchor: &quot;middle&quot;, fontWeight: y3.isBold ? 600 : f2, fontSize: u2, fontFamily: g2, foreColor: Array.isArray(p2) ? t3 &amp;&amp; d2.config.xaxis.convertedCatToNumeric ? p2[d2.globals.minX + s3 - 1] : p2[s3] : p2, isPlainText: false, cssClass: (t3 ? &quot;apexcharts-xaxis-label &quot; : &quot;apexcharts-xaxis-group-label &quot;) + x2 });
        if (i2.add(k3), k3.on(&quot;click&quot;, function(t4) {
          if (&quot;function&quot; == typeof d2.config.chart.events.xAxisLabelClick) {
            var e3 = Object.assign({}, d2, { labelIndex: s3 });
            d2.config.chart.events.xAxisLabelClick(t4, o2.ctx, e3);
          }
        }), t3) {
          var A2 = document.createElementNS(d2.globals.SVGNS, &quot;title&quot;);
          A2.textContent = Array.isArray(y3.text) ? y3.text.join(&quot; &quot;) : y3.text, k3.node.appendChild(A2), &quot;&quot; !== y3.text &amp;&amp; (h2.push(y3.text), c2.push(y3));
        }
      }
      s3 &lt; m2 - 1 &amp;&amp; (b2 += r2(s3 + 1, n2));
    }, k2 = 0; k2 &lt;= m2 - 1; k2++) w2(k2);
  } }, { key: &quot;drawXaxisInversed&quot;, value: function(t3) {
    var e2, i2, a2 = this, s2 = this.w, r2 = new Mi(this.ctx), n2 = s2.config.yaxis[0].opposite ? s2.globals.translateYAxisX[t3] : 0, o2 = r2.group({ class: &quot;apexcharts-yaxis apexcharts-xaxis-inversed&quot;, rel: t3 }), l2 = r2.group({ class: &quot;apexcharts-yaxis-texts-g apexcharts-xaxis-inversed-texts-g&quot;, transform: &quot;translate(&quot; + n2 + &quot;, 0)&quot; });
    o2.add(l2);
    var h2 = [];
    if (s2.config.yaxis[t3].show) for (var c2 = 0; c2 &lt; this.xaxisLabels.length; c2++) h2.push(this.xaxisLabels[c2]);
    e2 = s2.globals.gridHeight / h2.length, i2 = -e2 / 2.2;
    var d2 = s2.globals.yLabelFormatters[0], u2 = s2.config.yaxis[0].labels;
    if (u2.show) for (var g2 = function(n3) {
      var o3 = void 0 === h2[n3] ? &quot;&quot; : h2[n3];
      o3 = d2(o3, { seriesIndex: t3, dataPointIndex: n3, w: s2 });
      var c3 = a2.axesUtils.getYAxisForeColor(u2.style.colors, t3), g3 = 0;
      Array.isArray(o3) &amp;&amp; (g3 = o3.length / 2 * parseInt(u2.style.fontSize, 10));
      var p3 = u2.offsetX - 15, f3 = &quot;end&quot;;
      a2.yaxis.opposite &amp;&amp; (f3 = &quot;start&quot;), &quot;left&quot; === s2.config.yaxis[0].labels.align ? (p3 = u2.offsetX, f3 = &quot;start&quot;) : &quot;center&quot; === s2.config.yaxis[0].labels.align ? (p3 = u2.offsetX, f3 = &quot;middle&quot;) : &quot;right&quot; === s2.config.yaxis[0].labels.align &amp;&amp; (f3 = &quot;end&quot;);
      var x3 = r2.drawText({ x: p3, y: i2 + e2 + u2.offsetY - g3, text: o3, textAnchor: f3, foreColor: Array.isArray(c3) ? c3[n3] : c3, fontSize: u2.style.fontSize, fontFamily: u2.style.fontFamily, fontWeight: u2.style.fontWeight, isPlainText: false, cssClass: &quot;apexcharts-yaxis-label &quot; + u2.style.cssClass, maxWidth: u2.maxWidth });
      l2.add(x3), x3.on(&quot;click&quot;, function(t4) {
        if (&quot;function&quot; == typeof s2.config.chart.events.xAxisLabelClick) {
          var e3 = Object.assign({}, s2, { labelIndex: n3 });
          s2.config.chart.events.xAxisLabelClick(t4, a2.ctx, e3);
        }
      });
      var b3 = document.createElementNS(s2.globals.SVGNS, &quot;title&quot;);
      if (b3.textContent = Array.isArray(o3) ? o3.join(&quot; &quot;) : o3, x3.node.appendChild(b3), 0 !== s2.config.yaxis[t3].labels.rotate) {
        var m3 = r2.rotateAroundCenter(x3.node);
        x3.node.setAttribute(&quot;transform&quot;, &quot;rotate(&quot;.concat(s2.config.yaxis[t3].labels.rotate, &quot; 0 &quot;).concat(m3.y, &quot;)&quot;));
      }
      i2 += e2;
    }, p2 = 0; p2 &lt;= h2.length - 1; p2++) g2(p2);
    if (void 0 !== s2.config.yaxis[0].title.text) {
      var f2 = r2.group({ class: &quot;apexcharts-yaxis-title apexcharts-xaxis-title-inversed&quot;, transform: &quot;translate(&quot; + n2 + &quot;, 0)&quot; }), x2 = r2.drawText({ x: s2.config.yaxis[0].title.offsetX, y: s2.globals.gridHeight / 2 + s2.config.yaxis[0].title.offsetY, text: s2.config.yaxis[0].title.text, textAnchor: &quot;middle&quot;, foreColor: s2.config.yaxis[0].title.style.color, fontSize: s2.config.yaxis[0].title.style.fontSize, fontWeight: s2.config.yaxis[0].title.style.fontWeight, fontFamily: s2.config.yaxis[0].title.style.fontFamily, cssClass: &quot;apexcharts-yaxis-title-text &quot; + s2.config.yaxis[0].title.style.cssClass });
      f2.add(x2), o2.add(f2);
    }
    var b2 = 0;
    this.isCategoryBarHorizontal &amp;&amp; s2.config.yaxis[0].opposite &amp;&amp; (b2 = s2.globals.gridWidth);
    var m2 = s2.config.xaxis.axisBorder;
    if (m2.show) {
      var v2 = r2.drawLine(s2.globals.padHorizontal + m2.offsetX + b2, 1 + m2.offsetY, s2.globals.padHorizontal + m2.offsetX + b2, s2.globals.gridHeight + m2.offsetY, m2.color, 0);
      this.elgrid &amp;&amp; this.elgrid.elGridBorders &amp;&amp; s2.config.grid.show ? this.elgrid.elGridBorders.add(v2) : o2.add(v2);
    }
    return s2.config.yaxis[0].axisTicks.show &amp;&amp; this.axesUtils.drawYAxisTicks(b2, h2.length, s2.config.yaxis[0].axisBorder, s2.config.yaxis[0].axisTicks, 0, e2, o2), o2;
  } }, { key: &quot;drawXaxisTicks&quot;, value: function(t3, e2, i2) {
    var a2 = this.w, s2 = t3;
    if (!(t3 &lt; 0 || t3 - 2 &gt; a2.globals.gridWidth)) {
      var r2 = this.offY + a2.config.xaxis.axisTicks.offsetY;
      if (e2 = e2 + r2 + a2.config.xaxis.axisTicks.height, &quot;top&quot; === a2.config.xaxis.position &amp;&amp; (e2 = r2 - a2.config.xaxis.axisTicks.height), a2.config.xaxis.axisTicks.show) {
        var n2 = new Mi(this.ctx).drawLine(t3 + a2.config.xaxis.axisTicks.offsetX, r2 + a2.config.xaxis.offsetY, s2 + a2.config.xaxis.axisTicks.offsetX, e2 + a2.config.xaxis.offsetY, a2.config.xaxis.axisTicks.color);
        i2.add(n2), n2.node.classList.add(&quot;apexcharts-xaxis-tick&quot;);
      }
    }
  } }, { key: &quot;getXAxisTicksPositions&quot;, value: function() {
    var t3 = this.w, e2 = [], i2 = this.xaxisLabels.length, a2 = t3.globals.padHorizontal;
    if (t3.globals.timescaleLabels.length &gt; 0) for (var s2 = 0; s2 &lt; i2; s2++) a2 = this.xaxisLabels[s2].position, e2.push(a2);
    else for (var r2 = i2, n2 = 0; n2 &lt; r2; n2++) {
      var o2 = r2;
      t3.globals.isXNumeric &amp;&amp; &quot;bar&quot; !== t3.config.chart.type &amp;&amp; (o2 -= 1), a2 += t3.globals.gridWidth / o2, e2.push(a2);
    }
    return e2;
  } }, { key: &quot;xAxisLabelCorrections&quot;, value: function() {
    var t3 = this.w, e2 = new Mi(this.ctx), i2 = t3.globals.dom.baseEl.querySelector(&quot;.apexcharts-xaxis-texts-g&quot;), a2 = t3.globals.dom.baseEl.querySelectorAll(&quot;.apexcharts-xaxis-texts-g text:not(.apexcharts-xaxis-group-label)&quot;), s2 = t3.globals.dom.baseEl.querySelectorAll(&quot;.apexcharts-yaxis-inversed text&quot;), r2 = t3.globals.dom.baseEl.querySelectorAll(&quot;.apexcharts-xaxis-inversed-texts-g text tspan&quot;);
    if (t3.globals.rotateXLabels || t3.config.xaxis.labels.rotateAlways) for (var n2 = 0; n2 &lt; a2.length; n2++) {
      var o2 = e2.rotateAroundCenter(a2[n2]);
      o2.y = o2.y - 1, o2.x = o2.x + 1, a2[n2].setAttribute(&quot;transform&quot;, &quot;rotate(&quot;.concat(t3.config.xaxis.labels.rotate, &quot; &quot;).concat(o2.x, &quot; &quot;).concat(o2.y, &quot;)&quot;)), a2[n2].setAttribute(&quot;text-anchor&quot;, &quot;end&quot;);
      i2.setAttribute(&quot;transform&quot;, &quot;translate(0, &quot;.concat(-10, &quot;)&quot;));
      var l2 = a2[n2].childNodes;
      t3.config.xaxis.labels.trim &amp;&amp; Array.prototype.forEach.call(l2, function(i3) {
        e2.placeTextWithEllipsis(i3, i3.textContent, t3.globals.xAxisLabelsHeight - (&quot;bottom&quot; === t3.config.legend.position ? 20 : 10));
      });
    }
    else !function() {
      for (var i3 = t3.globals.gridWidth / (t3.globals.labels.length + 1), s3 = 0; s3 &lt; a2.length; s3++) {
        var r3 = a2[s3].childNodes;
        t3.config.xaxis.labels.trim &amp;&amp; &quot;datetime&quot; !== t3.config.xaxis.type &amp;&amp; Array.prototype.forEach.call(r3, function(t4) {
          e2.placeTextWithEllipsis(t4, t4.textContent, i3);
        });
      }
    }();
    if (s2.length &gt; 0) {
      var h2 = s2[s2.length - 1].getBBox(), c2 = s2[0].getBBox();
      h2.x &lt; -20 &amp;&amp; s2[s2.length - 1].parentNode.removeChild(s2[s2.length - 1]), c2.x + c2.width &gt; t3.globals.gridWidth &amp;&amp; !t3.globals.isBarHorizontal &amp;&amp; s2[0].parentNode.removeChild(s2[0]);
      for (var d2 = 0; d2 &lt; r2.length; d2++) e2.placeTextWithEllipsis(r2[d2], r2[d2].textContent, t3.config.yaxis[0].labels.maxWidth - (t3.config.yaxis[0].title.text ? 2 * parseFloat(t3.config.yaxis[0].title.style.fontSize) : 0) - 15);
    }
  } }]), t2;
}();
var Ki = function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w;
    var a2 = this.w;
    this.xaxisLabels = a2.globals.labels.slice(), this.axesUtils = new Ri(e2), this.isRangeBar = a2.globals.seriesRange.length &amp;&amp; a2.globals.isBarHorizontal, a2.globals.timescaleLabels.length &gt; 0 &amp;&amp; (this.xaxisLabels = a2.globals.timescaleLabels.slice());
  }
  return s(t2, [{ key: &quot;drawGridArea&quot;, value: function() {
    var t3 = arguments.length &gt; 0 &amp;&amp; void 0 !== arguments[0] ? arguments[0] : null, e2 = this.w, i2 = new Mi(this.ctx);
    t3 || (t3 = i2.group({ class: &quot;apexcharts-grid&quot; }));
    var a2 = i2.drawLine(e2.globals.padHorizontal, 1, e2.globals.padHorizontal, e2.globals.gridHeight, &quot;transparent&quot;), s2 = i2.drawLine(e2.globals.padHorizontal, e2.globals.gridHeight, e2.globals.gridWidth, e2.globals.gridHeight, &quot;transparent&quot;);
    return t3.add(s2), t3.add(a2), t3;
  } }, { key: &quot;drawGrid&quot;, value: function() {
    if (this.w.globals.axisCharts) {
      var t3 = this.renderGrid();
      return this.drawGridArea(t3.el), t3;
    }
    return null;
  } }, { key: &quot;createGridMask&quot;, value: function() {
    var t3 = this.w, e2 = t3.globals, i2 = new Mi(this.ctx), a2 = Array.isArray(t3.config.stroke.width) ? Math.max.apply(Math, f(t3.config.stroke.width)) : t3.config.stroke.width, s2 = function(t4) {
      var i3 = document.createElementNS(e2.SVGNS, &quot;clipPath&quot;);
      return i3.setAttribute(&quot;id&quot;, t4), i3;
    };
    e2.dom.elGridRectMask = s2(&quot;gridRectMask&quot;.concat(e2.cuid)), e2.dom.elGridRectBarMask = s2(&quot;gridRectBarMask&quot;.concat(e2.cuid)), e2.dom.elGridRectMarkerMask = s2(&quot;gridRectMarkerMask&quot;.concat(e2.cuid)), e2.dom.elForecastMask = s2(&quot;forecastMask&quot;.concat(e2.cuid)), e2.dom.elNonForecastMask = s2(&quot;nonForecastMask&quot;.concat(e2.cuid));
    var r2 = 0, n2 = 0;
    ([&quot;bar&quot;, &quot;rangeBar&quot;, &quot;candlestick&quot;, &quot;boxPlot&quot;].includes(t3.config.chart.type) || t3.globals.comboBarCount &gt; 0) &amp;&amp; t3.globals.isXNumeric &amp;&amp; !t3.globals.isBarHorizontal &amp;&amp; (r2 = Math.max(t3.config.grid.padding.left, e2.barPadForNumericAxis), n2 = Math.max(t3.config.grid.padding.right, e2.barPadForNumericAxis)), e2.dom.elGridRect = i2.drawRect(-a2 / 2 - 2, -a2 / 2 - 2, e2.gridWidth + a2 + 4, e2.gridHeight + a2 + 4, 0, &quot;#fff&quot;), e2.dom.elGridRectBar = i2.drawRect(-a2 / 2 - r2 - 2, -a2 / 2 - 2, e2.gridWidth + a2 + n2 + r2 + 4, e2.gridHeight + a2 + 4, 0, &quot;#fff&quot;);
    var o2 = t3.globals.markers.largestSize;
    e2.dom.elGridRectMarker = i2.drawRect(-o2, -o2, e2.gridWidth + 2 * o2, e2.gridHeight + 2 * o2, 0, &quot;#fff&quot;), e2.dom.elGridRectMask.appendChild(e2.dom.elGridRect.node), e2.dom.elGridRectBarMask.appendChild(e2.dom.elGridRectBar.node), e2.dom.elGridRectMarkerMask.appendChild(e2.dom.elGridRectMarker.node);
    var l2 = e2.dom.baseEl.querySelector(&quot;defs&quot;);
    l2.appendChild(e2.dom.elGridRectMask), l2.appendChild(e2.dom.elGridRectBarMask), l2.appendChild(e2.dom.elGridRectMarkerMask), l2.appendChild(e2.dom.elForecastMask), l2.appendChild(e2.dom.elNonForecastMask);
  } }, { key: &quot;_drawGridLines&quot;, value: function(t3) {
    var e2 = t3.i, i2 = t3.x1, a2 = t3.y1, s2 = t3.x2, r2 = t3.y2, n2 = t3.xCount, o2 = t3.parent, l2 = this.w;
    if (!(0 === e2 &amp;&amp; l2.globals.skipFirstTimelinelabel || e2 === n2 - 1 &amp;&amp; l2.globals.skipLastTimelinelabel &amp;&amp; !l2.config.xaxis.labels.formatter || &quot;radar&quot; === l2.config.chart.type)) {
      l2.config.grid.xaxis.lines.show &amp;&amp; this._drawGridLine({ i: e2, x1: i2, y1: a2, x2: s2, y2: r2, xCount: n2, parent: o2 });
      var h2 = 0;
      if (l2.globals.hasXaxisGroups &amp;&amp; &quot;between&quot; === l2.config.xaxis.tickPlacement) {
        var c2 = l2.globals.groups;
        if (c2) {
          for (var d2 = 0, u2 = 0; d2 &lt; e2 &amp;&amp; u2 &lt; c2.length; u2++) d2 += c2[u2].cols;
          d2 === e2 &amp;&amp; (h2 = 0.6 * l2.globals.xAxisLabelsHeight);
        }
      }
      new Qi(this.ctx).drawXaxisTicks(i2, h2, l2.globals.dom.elGraphical);
    }
  } }, { key: &quot;_drawGridLine&quot;, value: function(t3) {
    var e2 = t3.i, i2 = t3.x1, a2 = t3.y1, s2 = t3.x2, r2 = t3.y2, n2 = t3.xCount, o2 = t3.parent, l2 = this.w, h2 = o2.node.classList.contains(&quot;apexcharts-gridlines-horizontal&quot;), c2 = l2.globals.barPadForNumericAxis, d2 = 0 === a2 &amp;&amp; 0 === r2 || 0 === i2 &amp;&amp; 0 === s2 || a2 === l2.globals.gridHeight &amp;&amp; r2 === l2.globals.gridHeight || l2.globals.isBarHorizontal &amp;&amp; (0 === e2 || e2 === n2 - 1), u2 = new Mi(this).drawLine(i2 - (h2 ? c2 : 0), a2, s2 + (h2 ? c2 : 0), r2, l2.config.grid.borderColor, l2.config.grid.strokeDashArray);
    u2.node.classList.add(&quot;apexcharts-gridline&quot;), d2 &amp;&amp; l2.config.grid.show ? this.elGridBorders.add(u2) : o2.add(u2);
  } }, { key: &quot;_drawGridBandRect&quot;, value: function(t3) {
    var e2 = t3.c, i2 = t3.x1, a2 = t3.y1, s2 = t3.x2, r2 = t3.y2, n2 = t3.type, o2 = this.w, l2 = new Mi(this.ctx), h2 = o2.globals.barPadForNumericAxis, c2 = o2.config.grid[n2].colors[e2], d2 = l2.drawRect(i2 - (&quot;row&quot; === n2 ? h2 : 0), a2, s2 + (&quot;row&quot; === n2 ? 2 * h2 : 0), r2, 0, c2, o2.config.grid[n2].opacity);
    this.elg.add(d2), d2.attr(&quot;clip-path&quot;, &quot;url(#gridRectMask&quot;.concat(o2.globals.cuid, &quot;)&quot;)), d2.node.classList.add(&quot;apexcharts-grid-&quot;.concat(n2));
  } }, { key: &quot;_drawXYLines&quot;, value: function(t3) {
    var e2 = this, i2 = t3.xCount, a2 = t3.tickAmount, s2 = this.w;
    if (s2.config.grid.xaxis.lines.show || s2.config.xaxis.axisTicks.show) {
      var r2, n2 = s2.globals.padHorizontal, o2 = s2.globals.gridHeight;
      s2.globals.timescaleLabels.length ? function(t4) {
        for (var a3 = t4.xC, s3 = t4.x1, r3 = t4.y1, n3 = t4.x2, o3 = t4.y2, l3 = 0; l3 &lt; a3; l3++) s3 = e2.xaxisLabels[l3].position, n3 = e2.xaxisLabels[l3].position, e2._drawGridLines({ i: l3, x1: s3, y1: r3, x2: n3, y2: o3, xCount: i2, parent: e2.elgridLinesV });
      }({ xC: i2, x1: n2, y1: 0, x2: r2, y2: o2 }) : (s2.globals.isXNumeric &amp;&amp; (i2 = s2.globals.xAxisScale.result.length), function(t4) {
        for (var a3 = t4.xC, r3 = t4.x1, n3 = t4.y1, o3 = t4.x2, l3 = t4.y2, h3 = 0; h3 &lt; a3 + (s2.globals.isXNumeric ? 0 : 1); h3++) 0 === h3 &amp;&amp; 1 === a3 &amp;&amp; 1 === s2.globals.dataPoints &amp;&amp; (o3 = r3 = s2.globals.gridWidth / 2), e2._drawGridLines({ i: h3, x1: r3, y1: n3, x2: o3, y2: l3, xCount: i2, parent: e2.elgridLinesV }), o3 = r3 += s2.globals.gridWidth / (s2.globals.isXNumeric ? a3 - 1 : a3);
      }({ xC: i2, x1: n2, y1: 0, x2: r2, y2: o2 }));
    }
    if (s2.config.grid.yaxis.lines.show) {
      var l2 = 0, h2 = 0, c2 = s2.globals.gridWidth, d2 = a2 + 1;
      this.isRangeBar &amp;&amp; (d2 = s2.globals.labels.length);
      for (var u2 = 0; u2 &lt; d2 + (this.isRangeBar ? 1 : 0); u2++) this._drawGridLine({ i: u2, xCount: d2 + (this.isRangeBar ? 1 : 0), x1: 0, y1: l2, x2: c2, y2: h2, parent: this.elgridLinesH }), h2 = l2 += s2.globals.gridHeight / (this.isRangeBar ? d2 : a2);
    }
  } }, { key: &quot;_drawInvertedXYLines&quot;, value: function(t3) {
    var e2 = t3.xCount, i2 = this.w;
    if (i2.config.grid.xaxis.lines.show || i2.config.xaxis.axisTicks.show) for (var a2, s2 = i2.globals.padHorizontal, r2 = i2.globals.gridHeight, n2 = 0; n2 &lt; e2 + 1; n2++) {
      i2.config.grid.xaxis.lines.show &amp;&amp; this._drawGridLine({ i: n2, xCount: e2 + 1, x1: s2, y1: 0, x2: a2, y2: r2, parent: this.elgridLinesV }), new Qi(this.ctx).drawXaxisTicks(s2, 0, i2.globals.dom.elGraphical), a2 = s2 += i2.globals.gridWidth / e2;
    }
    if (i2.config.grid.yaxis.lines.show) for (var o2 = 0, l2 = 0, h2 = i2.globals.gridWidth, c2 = 0; c2 &lt; i2.globals.dataPoints + 1; c2++) this._drawGridLine({ i: c2, xCount: i2.globals.dataPoints + 1, x1: 0, y1: o2, x2: h2, y2: l2, parent: this.elgridLinesH }), l2 = o2 += i2.globals.gridHeight / i2.globals.dataPoints;
  } }, { key: &quot;renderGrid&quot;, value: function() {
    var t3 = this.w, e2 = t3.globals, i2 = new Mi(this.ctx);
    this.elg = i2.group({ class: &quot;apexcharts-grid&quot; }), this.elgridLinesH = i2.group({ class: &quot;apexcharts-gridlines-horizontal&quot; }), this.elgridLinesV = i2.group({ class: &quot;apexcharts-gridlines-vertical&quot; }), this.elGridBorders = i2.group({ class: &quot;apexcharts-grid-borders&quot; }), this.elg.add(this.elgridLinesH), this.elg.add(this.elgridLinesV), t3.config.grid.show || (this.elgridLinesV.hide(), this.elgridLinesH.hide(), this.elGridBorders.hide());
    for (var a2 = 0; a2 &lt; e2.seriesYAxisMap.length &amp;&amp; e2.ignoreYAxisIndexes.includes(a2); ) a2++;
    a2 === e2.seriesYAxisMap.length &amp;&amp; (a2 = 0);
    var s2, r2 = e2.yAxisScale[a2].result.length - 1;
    if (!e2.isBarHorizontal || this.isRangeBar) {
      var n2, o2, l2;
      if (s2 = this.xaxisLabels.length, this.isRangeBar) r2 = e2.labels.length, t3.config.xaxis.tickAmount &amp;&amp; t3.config.xaxis.labels.formatter &amp;&amp; (s2 = t3.config.xaxis.tickAmount), (null === (n2 = e2.yAxisScale) || void 0 === n2 || null === (o2 = n2[a2]) || void 0 === o2 || null === (l2 = o2.result) || void 0 === l2 ? void 0 : l2.length) &gt; 0 &amp;&amp; &quot;datetime&quot; !== t3.config.xaxis.type &amp;&amp; (s2 = e2.yAxisScale[a2].result.length - 1);
      this._drawXYLines({ xCount: s2, tickAmount: r2 });
    } else s2 = r2, r2 = e2.xTickAmount, this._drawInvertedXYLines({ xCount: s2, tickAmount: r2 });
    return this.drawGridBands(s2, r2), { el: this.elg, elGridBorders: this.elGridBorders, xAxisTickWidth: e2.gridWidth / s2 };
  } }, { key: &quot;drawGridBands&quot;, value: function(t3, e2) {
    var i2, a2, s2 = this, r2 = this.w;
    if ((null === (i2 = r2.config.grid.row.colors) || void 0 === i2 ? void 0 : i2.length) &gt; 0 &amp;&amp; function(t4, i3, a3, n3, o3, l3) {
      for (var h3 = 0, c3 = 0; h3 &lt; i3; h3++, c3++) c3 &gt;= r2.config.grid[t4].colors.length &amp;&amp; (c3 = 0), s2._drawGridBandRect({ c: c3, x1: a3, y1: n3, x2: o3, y2: l3, type: t4 }), n3 += r2.globals.gridHeight / e2;
    }(&quot;row&quot;, e2, 0, 0, r2.globals.gridWidth, r2.globals.gridHeight / e2), (null === (a2 = r2.config.grid.column.colors) || void 0 === a2 ? void 0 : a2.length) &gt; 0) {
      var n2 = r2.globals.isBarHorizontal || &quot;on&quot; !== r2.config.xaxis.tickPlacement || &quot;category&quot; !== r2.config.xaxis.type &amp;&amp; !r2.config.xaxis.convertedCatToNumeric ? t3 : t3 - 1;
      r2.globals.isXNumeric &amp;&amp; (n2 = r2.globals.xAxisScale.result.length - 1);
      for (var o2 = r2.globals.padHorizontal, l2 = r2.globals.padHorizontal + r2.globals.gridWidth / n2, h2 = r2.globals.gridHeight, c2 = 0, d2 = 0; c2 &lt; t3; c2++, d2++) {
        var u2;
        if (d2 &gt;= r2.config.grid.column.colors.length &amp;&amp; (d2 = 0), &quot;datetime&quot; === r2.config.xaxis.type) o2 = this.xaxisLabels[c2].position, l2 = ((null === (u2 = this.xaxisLabels[c2 + 1]) || void 0 === u2 ? void 0 : u2.position) || r2.globals.gridWidth) - this.xaxisLabels[c2].position;
        this._drawGridBandRect({ c: d2, x1: o2, y1: 0, x2: l2, y2: h2, type: &quot;column&quot; }), o2 += r2.globals.gridWidth / n2;
      }
    }
  } }]), t2;
}();
var ta = function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w, this.coreUtils = new Pi(this.ctx);
  }
  return s(t2, [{ key: &quot;niceScale&quot;, value: function(t3, e2) {
    var i2, a2, s2, r2, n2 = arguments.length &gt; 2 &amp;&amp; void 0 !== arguments[2] ? arguments[2] : 0, o2 = 1e-11, l2 = this.w, h2 = l2.globals;
    h2.isBarHorizontal ? (i2 = l2.config.xaxis, a2 = Math.max((h2.svgWidth - 100) / 25, 2)) : (i2 = l2.config.yaxis[n2], a2 = Math.max((h2.svgHeight - 100) / 15, 2)), v.isNumber(a2) || (a2 = 10), s2 = void 0 !== i2.min &amp;&amp; null !== i2.min, r2 = void 0 !== i2.max &amp;&amp; null !== i2.min;
    var c2 = void 0 !== i2.stepSize &amp;&amp; null !== i2.stepSize, d2 = void 0 !== i2.tickAmount &amp;&amp; null !== i2.tickAmount, u2 = d2 ? i2.tickAmount : h2.niceScaleDefaultTicks[Math.min(Math.round(a2 / 2), h2.niceScaleDefaultTicks.length - 1)];
    if (h2.isMultipleYAxis &amp;&amp; !d2 &amp;&amp; h2.multiAxisTickAmount &gt; 0 &amp;&amp; (u2 = h2.multiAxisTickAmount, d2 = true), u2 = &quot;dataPoints&quot; === u2 ? h2.dataPoints - 1 : Math.abs(Math.round(u2)), (t3 === Number.MIN_VALUE &amp;&amp; 0 === e2 || !v.isNumber(t3) &amp;&amp; !v.isNumber(e2) || t3 === Number.MIN_VALUE &amp;&amp; e2 === -Number.MAX_VALUE) &amp;&amp; (t3 = v.isNumber(i2.min) ? i2.min : 0, e2 = v.isNumber(i2.max) ? i2.max : t3 + u2, h2.allSeriesCollapsed = false), t3 &gt; e2) {
      console.warn(&quot;axis.min cannot be greater than axis.max: swapping min and max&quot;);
      var g2 = e2;
      e2 = t3, t3 = g2;
    } else t3 === e2 &amp;&amp; (t3 = 0 === t3 ? 0 : t3 - 1, e2 = 0 === e2 ? 2 : e2 + 1);
    var p2 = [];
    u2 &lt; 1 &amp;&amp; (u2 = 1);
    var f2 = u2, x2 = Math.abs(e2 - t3);
    !s2 &amp;&amp; t3 &gt; 0 &amp;&amp; t3 / x2 &lt; 0.15 &amp;&amp; (t3 = 0, s2 = true), !r2 &amp;&amp; e2 &lt; 0 &amp;&amp; -e2 / x2 &lt; 0.15 &amp;&amp; (e2 = 0, r2 = true);
    var b2 = (x2 = Math.abs(e2 - t3)) / f2, m2 = b2, y2 = Math.floor(Math.log10(m2)), w2 = Math.pow(10, y2), k2 = Math.ceil(m2 / w2);
    if (b2 = m2 = (k2 = h2.niceScaleAllowedMagMsd[0 === h2.yValueDecimal ? 0 : 1][k2]) * w2, h2.isBarHorizontal &amp;&amp; i2.stepSize &amp;&amp; &quot;datetime&quot; !== i2.type ? (b2 = i2.stepSize, c2 = true) : c2 &amp;&amp; (b2 = i2.stepSize), c2 &amp;&amp; i2.forceNiceScale) {
      var A2 = Math.floor(Math.log10(b2));
      b2 *= Math.pow(10, y2 - A2);
    }
    if (s2 &amp;&amp; r2) {
      var C2 = x2 / f2;
      if (d2) if (c2) if (0 != v.mod(x2, b2)) {
        var S2 = v.getGCD(b2, C2);
        b2 = C2 / S2 &lt; 10 ? S2 : C2;
      } else 0 == v.mod(b2, C2) ? b2 = C2 : (C2 = b2, d2 = false);
      else b2 = C2;
      else if (c2) 0 == v.mod(x2, b2) ? C2 = b2 : b2 = C2;
      else if (0 == v.mod(x2, b2)) C2 = b2;
      else {
        C2 = x2 / (f2 = Math.ceil(x2 / b2));
        var L2 = v.getGCD(x2, b2);
        x2 / L2 &lt; a2 &amp;&amp; (C2 = L2), b2 = C2;
      }
      f2 = Math.round(x2 / b2);
    } else {
      if (s2 || r2) {
        if (r2) if (d2) t3 = e2 - b2 * f2;
        else {
          var M2 = t3;
          t3 = b2 * Math.floor(t3 / b2), Math.abs(e2 - t3) / v.getGCD(x2, b2) &gt; a2 &amp;&amp; (t3 = e2 - b2 * u2, t3 += b2 * Math.floor((M2 - t3) / b2));
        }
        else if (s2) if (d2) e2 = t3 + b2 * f2;
        else {
          var P2 = e2;
          e2 = b2 * Math.ceil(e2 / b2), Math.abs(e2 - t3) / v.getGCD(x2, b2) &gt; a2 &amp;&amp; (e2 = t3 + b2 * u2, e2 += b2 * Math.ceil((P2 - e2) / b2));
        }
      } else if (h2.isMultipleYAxis &amp;&amp; d2) {
        var I2 = b2 * Math.floor(t3 / b2), T2 = I2 + b2 * f2;
        T2 &lt; e2 &amp;&amp; (b2 *= 2), T2 = e2, e2 = (t3 = I2) + b2 * f2, x2 = Math.abs(e2 - t3), t3 &gt; 0 &amp;&amp; t3 &lt; Math.abs(T2 - e2) &amp;&amp; (t3 = 0, e2 = b2 * f2), e2 &lt; 0 &amp;&amp; -e2 &lt; Math.abs(I2 - t3) &amp;&amp; (e2 = 0, t3 = -b2 * f2);
      } else t3 = b2 * Math.floor(t3 / b2), e2 = b2 * Math.ceil(e2 / b2);
      x2 = Math.abs(e2 - t3), b2 = v.getGCD(x2, b2), f2 = Math.round(x2 / b2);
    }
    if (d2 || s2 || r2 || (f2 = Math.ceil((x2 - o2) / (b2 + o2))) &gt; 16 &amp;&amp; v.getPrimeFactors(f2).length &lt; 2 &amp;&amp; f2++, !d2 &amp;&amp; i2.forceNiceScale &amp;&amp; 0 === h2.yValueDecimal &amp;&amp; f2 &gt; x2 &amp;&amp; (f2 = x2, b2 = Math.round(x2 / f2)), f2 &gt; a2 &amp;&amp; (!d2 &amp;&amp; !c2 || i2.forceNiceScale)) {
      var z2 = v.getPrimeFactors(f2), X2 = z2.length - 1, R2 = f2;
      t: for (var E2 = 0; E2 &lt; X2; E2++) for (var Y2 = 0; Y2 &lt;= X2 - E2; Y2++) {
        for (var H2 = Math.min(Y2 + E2, X2), O2 = R2, F2 = 1, D2 = Y2; D2 &lt;= H2; D2++) F2 *= z2[D2];
        if ((O2 /= F2) &lt; a2) {
          R2 = O2;
          break t;
        }
      }
      b2 = R2 === f2 ? x2 : x2 / R2, f2 = Math.round(x2 / b2);
    }
    h2.isMultipleYAxis &amp;&amp; 0 == h2.multiAxisTickAmount &amp;&amp; h2.ignoreYAxisIndexes.indexOf(n2) &lt; 0 &amp;&amp; (h2.multiAxisTickAmount = f2);
    var _2 = t3 - b2, N2 = b2 * o2;
    do {
      _2 += b2, p2.push(v.stripNumber(_2, 7));
    } while (e2 - _2 &gt; N2);
    return { result: p2, niceMin: p2[0], niceMax: p2[p2.length - 1] };
  } }, { key: &quot;linearScale&quot;, value: function(t3, e2) {
    var i2 = arguments.length &gt; 2 &amp;&amp; void 0 !== arguments[2] ? arguments[2] : 10, a2 = arguments.length &gt; 3 &amp;&amp; void 0 !== arguments[3] ? arguments[3] : 0, s2 = arguments.length &gt; 4 &amp;&amp; void 0 !== arguments[4] ? arguments[4] : void 0, r2 = Math.abs(e2 - t3), n2 = [];
    if (t3 === e2) return { result: n2 = [t3], niceMin: n2[0], niceMax: n2[n2.length - 1] };
    &quot;dataPoints&quot; === (i2 = this._adjustTicksForSmallRange(i2, a2, r2)) &amp;&amp; (i2 = this.w.globals.dataPoints - 1), s2 || (s2 = r2 / i2), s2 = Math.round(100 * (s2 + Number.EPSILON)) / 100, i2 === Number.MAX_VALUE &amp;&amp; (i2 = 5, s2 = 1);
    for (var o2 = t3; i2 &gt;= 0; ) n2.push(o2), o2 = v.preciseAddition(o2, s2), i2 -= 1;
    return { result: n2, niceMin: n2[0], niceMax: n2[n2.length - 1] };
  } }, { key: &quot;logarithmicScaleNice&quot;, value: function(t3, e2, i2) {
    e2 &lt;= 0 &amp;&amp; (e2 = Math.max(t3, i2)), t3 &lt;= 0 &amp;&amp; (t3 = Math.min(e2, i2));
    for (var a2 = [], s2 = Math.ceil(Math.log(e2) / Math.log(i2) + 1), r2 = Math.floor(Math.log(t3) / Math.log(i2)); r2 &lt; s2; r2++) a2.push(Math.pow(i2, r2));
    return { result: a2, niceMin: a2[0], niceMax: a2[a2.length - 1] };
  } }, { key: &quot;logarithmicScale&quot;, value: function(t3, e2, i2) {
    e2 &lt;= 0 &amp;&amp; (e2 = Math.max(t3, i2)), t3 &lt;= 0 &amp;&amp; (t3 = Math.min(e2, i2));
    for (var a2 = [], s2 = Math.log(e2) / Math.log(i2), r2 = Math.log(t3) / Math.log(i2), n2 = s2 - r2, o2 = Math.round(n2), l2 = n2 / o2, h2 = 0, c2 = r2; h2 &lt; o2; h2++, c2 += l2) a2.push(Math.pow(i2, c2));
    return a2.push(Math.pow(i2, s2)), { result: a2, niceMin: t3, niceMax: e2 };
  } }, { key: &quot;_adjustTicksForSmallRange&quot;, value: function(t3, e2, i2) {
    var a2 = t3;
    if (void 0 !== e2 &amp;&amp; this.w.config.yaxis[e2].labels.formatter &amp;&amp; void 0 === this.w.config.yaxis[e2].tickAmount) {
      var s2 = Number(this.w.config.yaxis[e2].labels.formatter(1));
      v.isNumber(s2) &amp;&amp; 0 === this.w.globals.yValueDecimal &amp;&amp; (a2 = Math.ceil(i2));
    }
    return a2 &lt; t3 ? a2 : t3;
  } }, { key: &quot;setYScaleForIndex&quot;, value: function(t3, e2, i2) {
    var a2 = this.w.globals, s2 = this.w.config, r2 = a2.isBarHorizontal ? s2.xaxis : s2.yaxis[t3];
    void 0 === a2.yAxisScale[t3] &amp;&amp; (a2.yAxisScale[t3] = []);
    var n2 = Math.abs(i2 - e2);
    r2.logarithmic &amp;&amp; n2 &lt;= 5 &amp;&amp; (a2.invalidLogScale = true), r2.logarithmic &amp;&amp; n2 &gt; 5 ? (a2.allSeriesCollapsed = false, a2.yAxisScale[t3] = r2.forceNiceScale ? this.logarithmicScaleNice(e2, i2, r2.logBase) : this.logarithmicScale(e2, i2, r2.logBase)) : i2 !== -Number.MAX_VALUE &amp;&amp; v.isNumber(i2) &amp;&amp; e2 !== Number.MAX_VALUE &amp;&amp; v.isNumber(e2) ? (a2.allSeriesCollapsed = false, a2.yAxisScale[t3] = this.niceScale(e2, i2, t3)) : a2.yAxisScale[t3] = this.niceScale(Number.MIN_VALUE, 0, t3);
  } }, { key: &quot;setXScale&quot;, value: function(t3, e2) {
    var i2 = this.w, a2 = i2.globals;
    if (e2 !== -Number.MAX_VALUE &amp;&amp; v.isNumber(e2)) {
      var s2 = a2.xTickAmount;
      a2.xAxisScale = this.linearScale(t3, e2, s2, 0, i2.config.xaxis.stepSize);
    } else a2.xAxisScale = this.linearScale(0, 10, 10);
    return a2.xAxisScale;
  } }, { key: &quot;scaleMultipleYAxes&quot;, value: function() {
    var t3 = this, e2 = this.w.config, i2 = this.w.globals;
    this.coreUtils.setSeriesYAxisMappings();
    var a2 = i2.seriesYAxisMap, s2 = i2.minYArr, r2 = i2.maxYArr;
    i2.allSeriesCollapsed = true, i2.barGroups = [], a2.forEach(function(a3, n2) {
      var o2 = [];
      a3.forEach(function(t4) {
        var i3, a4 = null === (i3 = e2.series[t4]) || void 0 === i3 ? void 0 : i3.group;
        o2.indexOf(a4) &lt; 0 &amp;&amp; o2.push(a4);
      }), a3.length &gt; 0 ? function() {
        var l2, h2, c2 = Number.MAX_VALUE, d2 = -Number.MAX_VALUE, u2 = c2, g2 = d2;
        if (e2.chart.stacked) !function() {
          var t4 = new Array(i2.dataPoints).fill(0), s3 = [], r3 = [], p3 = [];
          o2.forEach(function() {
            s3.push(t4.map(function() {
              return Number.MIN_VALUE;
            })), r3.push(t4.map(function() {
              return Number.MIN_VALUE;
            })), p3.push(t4.map(function() {
              return Number.MIN_VALUE;
            }));
          });
          for (var f3 = function(t5) {
            !l2 &amp;&amp; e2.series[a3[t5]].type &amp;&amp; (l2 = e2.series[a3[t5]].type);
            var c3 = a3[t5];
            h2 = e2.series[c3].group ? e2.series[c3].group : &quot;axis-&quot;.concat(n2), !(i2.collapsedSeriesIndices.indexOf(c3) &lt; 0 &amp;&amp; i2.ancillaryCollapsedSeriesIndices.indexOf(c3) &lt; 0) || (i2.allSeriesCollapsed = false, o2.forEach(function(t6, a4) {
              if (e2.series[c3].group === t6) for (var n3 = 0; n3 &lt; i2.series[c3].length; n3++) {
                var o3 = i2.series[c3][n3];
                o3 &gt;= 0 ? r3[a4][n3] += o3 : p3[a4][n3] += o3, s3[a4][n3] += o3, u2 = Math.min(u2, o3), g2 = Math.max(g2, o3);
              }
            })), &quot;bar&quot; !== l2 &amp;&amp; &quot;column&quot; !== l2 || i2.barGroups.push(h2);
          }, x2 = 0; x2 &lt; a3.length; x2++) f3(x2);
          l2 || (l2 = e2.chart.type), &quot;bar&quot; === l2 || &quot;column&quot; === l2 ? o2.forEach(function(t5, e3) {
            c2 = Math.min(c2, Math.min.apply(null, p3[e3])), d2 = Math.max(d2, Math.max.apply(null, r3[e3]));
          }) : (o2.forEach(function(t5, e3) {
            u2 = Math.min(u2, Math.min.apply(null, s3[e3])), g2 = Math.max(g2, Math.max.apply(null, s3[e3]));
          }), c2 = u2, d2 = g2), c2 === Number.MIN_VALUE &amp;&amp; d2 === Number.MIN_VALUE &amp;&amp; (d2 = -Number.MAX_VALUE);
        }();
        else for (var p2 = 0; p2 &lt; a3.length; p2++) {
          var f2 = a3[p2];
          c2 = Math.min(c2, s2[f2]), d2 = Math.max(d2, r2[f2]), !(i2.collapsedSeriesIndices.indexOf(f2) &lt; 0 &amp;&amp; i2.ancillaryCollapsedSeriesIndices.indexOf(f2) &lt; 0) || (i2.allSeriesCollapsed = false);
        }
        void 0 !== e2.yaxis[n2].min &amp;&amp; (c2 = &quot;function&quot; == typeof e2.yaxis[n2].min ? e2.yaxis[n2].min(c2) : e2.yaxis[n2].min), void 0 !== e2.yaxis[n2].max &amp;&amp; (d2 = &quot;function&quot; == typeof e2.yaxis[n2].max ? e2.yaxis[n2].max(d2) : e2.yaxis[n2].max), i2.barGroups = i2.barGroups.filter(function(t4, e3, i3) {
          return i3.indexOf(t4) === e3;
        }), t3.setYScaleForIndex(n2, c2, d2), a3.forEach(function(t4) {
          s2[t4] = i2.yAxisScale[n2].niceMin, r2[t4] = i2.yAxisScale[n2].niceMax;
        });
      }() : t3.setYScaleForIndex(n2, 0, -Number.MAX_VALUE);
    });
  } }]), t2;
}();
var ea = function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w, this.scales = new ta(e2);
  }
  return s(t2, [{ key: &quot;init&quot;, value: function() {
    this.setYRange(), this.setXRange(), this.setZRange();
  } }, { key: &quot;getMinYMaxY&quot;, value: function(t3) {
    var e2 = arguments.length &gt; 1 &amp;&amp; void 0 !== arguments[1] ? arguments[1] : Number.MAX_VALUE, i2 = arguments.length &gt; 2 &amp;&amp; void 0 !== arguments[2] ? arguments[2] : -Number.MAX_VALUE, a2 = arguments.length &gt; 3 &amp;&amp; void 0 !== arguments[3] ? arguments[3] : null, s2 = this.w.config, r2 = this.w.globals, n2 = -Number.MAX_VALUE, o2 = Number.MIN_VALUE;
    null === a2 &amp;&amp; (a2 = t3 + 1);
    var l2 = r2.series, h2 = l2, c2 = l2;
    &quot;candlestick&quot; === s2.chart.type ? (h2 = r2.seriesCandleL, c2 = r2.seriesCandleH) : &quot;boxPlot&quot; === s2.chart.type ? (h2 = r2.seriesCandleO, c2 = r2.seriesCandleC) : r2.isRangeData &amp;&amp; (h2 = r2.seriesRangeStart, c2 = r2.seriesRangeEnd);
    var d2 = false;
    if (r2.seriesX.length &gt;= a2) {
      var u2, g2 = null === (u2 = r2.brushSource) || void 0 === u2 ? void 0 : u2.w.config.chart.brush;
      (s2.chart.zoom.enabled &amp;&amp; s2.chart.zoom.autoScaleYaxis || null != g2 &amp;&amp; g2.enabled &amp;&amp; null != g2 &amp;&amp; g2.autoScaleYaxis) &amp;&amp; (d2 = true);
    }
    for (var p2 = t3; p2 &lt; a2; p2++) {
      r2.dataPoints = Math.max(r2.dataPoints, l2[p2].length);
      var f2 = s2.series[p2].type;
      r2.categoryLabels.length &amp;&amp; (r2.dataPoints = r2.categoryLabels.filter(function(t4) {
        return void 0 !== t4;
      }).length), r2.labels.length &amp;&amp; &quot;datetime&quot; !== s2.xaxis.type &amp;&amp; 0 !== r2.series.reduce(function(t4, e3) {
        return t4 + e3.length;
      }, 0) &amp;&amp; (r2.dataPoints = Math.max(r2.dataPoints, r2.labels.length));
      var x2 = 0, b2 = l2[p2].length - 1;
      if (d2) {
        if (s2.xaxis.min) for (; x2 &lt; b2 &amp;&amp; r2.seriesX[p2][x2] &lt; s2.xaxis.min; x2++) ;
        if (s2.xaxis.max) for (; b2 &gt; x2 &amp;&amp; r2.seriesX[p2][b2] &gt; s2.xaxis.max; b2--) ;
      }
      for (var m2 = x2; m2 &lt;= b2 &amp;&amp; m2 &lt; r2.series[p2].length; m2++) {
        var y2 = l2[p2][m2];
        if (null !== y2 &amp;&amp; v.isNumber(y2)) {
          switch (void 0 !== c2[p2][m2] &amp;&amp; (n2 = Math.max(n2, c2[p2][m2]), e2 = Math.min(e2, c2[p2][m2])), void 0 !== h2[p2][m2] &amp;&amp; (e2 = Math.min(e2, h2[p2][m2]), i2 = Math.max(i2, h2[p2][m2])), f2) {
            case &quot;candlestick&quot;:
              void 0 !== r2.seriesCandleC[p2][m2] &amp;&amp; (n2 = Math.max(n2, r2.seriesCandleH[p2][m2]), e2 = Math.min(e2, r2.seriesCandleL[p2][m2]));
              break;
            case &quot;boxPlot&quot;:
              void 0 !== r2.seriesCandleC[p2][m2] &amp;&amp; (n2 = Math.max(n2, r2.seriesCandleC[p2][m2]), e2 = Math.min(e2, r2.seriesCandleO[p2][m2]));
          }
          f2 &amp;&amp; &quot;candlestick&quot; !== f2 &amp;&amp; &quot;boxPlot&quot; !== f2 &amp;&amp; &quot;rangeArea&quot; !== f2 &amp;&amp; &quot;rangeBar&quot; !== f2 &amp;&amp; (n2 = Math.max(n2, r2.series[p2][m2]), e2 = Math.min(e2, r2.series[p2][m2])), r2.seriesGoals[p2] &amp;&amp; r2.seriesGoals[p2][m2] &amp;&amp; Array.isArray(r2.seriesGoals[p2][m2]) &amp;&amp; r2.seriesGoals[p2][m2].forEach(function(t4) {
            n2 = Math.max(n2, t4.value), e2 = Math.min(e2, t4.value);
          }), i2 = n2, y2 = v.noExponents(y2), v.isFloat(y2) &amp;&amp; (r2.yValueDecimal = Math.max(r2.yValueDecimal, y2.toString().split(&quot;.&quot;)[1].length)), o2 &gt; h2[p2][m2] &amp;&amp; h2[p2][m2] &lt; 0 &amp;&amp; (o2 = h2[p2][m2]);
        } else r2.hasNullValues = true;
      }
      &quot;bar&quot; !== f2 &amp;&amp; &quot;column&quot; !== f2 || (o2 &lt; 0 &amp;&amp; n2 &lt; 0 &amp;&amp; (n2 = 0, i2 = Math.max(i2, 0)), o2 === Number.MIN_VALUE &amp;&amp; (o2 = 0, e2 = Math.min(e2, 0)));
    }
    return &quot;rangeBar&quot; === s2.chart.type &amp;&amp; r2.seriesRangeStart.length &amp;&amp; r2.isBarHorizontal &amp;&amp; (o2 = e2), &quot;bar&quot; === s2.chart.type &amp;&amp; (o2 &lt; 0 &amp;&amp; n2 &lt; 0 &amp;&amp; (n2 = 0), o2 === Number.MIN_VALUE &amp;&amp; (o2 = 0)), { minY: o2, maxY: n2, lowestY: e2, highestY: i2 };
  } }, { key: &quot;setYRange&quot;, value: function() {
    var t3 = this.w.globals, e2 = this.w.config;
    t3.maxY = -Number.MAX_VALUE, t3.minY = Number.MIN_VALUE;
    var i2, a2 = Number.MAX_VALUE;
    if (t3.isMultipleYAxis) {
      a2 = Number.MAX_VALUE;
      for (var s2 = 0; s2 &lt; t3.series.length; s2++) i2 = this.getMinYMaxY(s2), t3.minYArr[s2] = i2.lowestY, t3.maxYArr[s2] = i2.highestY, a2 = Math.min(a2, i2.lowestY);
    }
    if (i2 = this.getMinYMaxY(0, a2, null, t3.series.length), &quot;bar&quot; === e2.chart.type ? (t3.minY = i2.minY, t3.maxY = i2.maxY) : (t3.minY = i2.lowestY, t3.maxY = i2.highestY), a2 = i2.lowestY, e2.chart.stacked &amp;&amp; this._setStackedMinMax(), &quot;line&quot; === e2.chart.type || &quot;area&quot; === e2.chart.type || &quot;scatter&quot; === e2.chart.type || &quot;candlestick&quot; === e2.chart.type || &quot;boxPlot&quot; === e2.chart.type || &quot;rangeBar&quot; === e2.chart.type &amp;&amp; !t3.isBarHorizontal ? t3.minY === Number.MIN_VALUE &amp;&amp; a2 !== -Number.MAX_VALUE &amp;&amp; a2 !== t3.maxY &amp;&amp; (t3.minY = a2) : t3.minY = t3.minY !== Number.MIN_VALUE ? Math.min(i2.minY, t3.minY) : i2.minY, e2.yaxis.forEach(function(e3, i3) {
      void 0 !== e3.max &amp;&amp; (&quot;number&quot; == typeof e3.max ? t3.maxYArr[i3] = e3.max : &quot;function&quot; == typeof e3.max &amp;&amp; (t3.maxYArr[i3] = e3.max(t3.isMultipleYAxis ? t3.maxYArr[i3] : t3.maxY)), t3.maxY = t3.maxYArr[i3]), void 0 !== e3.min &amp;&amp; (&quot;number&quot; == typeof e3.min ? t3.minYArr[i3] = e3.min : &quot;function&quot; == typeof e3.min &amp;&amp; (t3.minYArr[i3] = e3.min(t3.isMultipleYAxis ? t3.minYArr[i3] === Number.MIN_VALUE ? 0 : t3.minYArr[i3] : t3.minY)), t3.minY = t3.minYArr[i3]);
    }), t3.isBarHorizontal) {
      [&quot;min&quot;, &quot;max&quot;].forEach(function(i3) {
        void 0 !== e2.xaxis[i3] &amp;&amp; &quot;number&quot; == typeof e2.xaxis[i3] &amp;&amp; (&quot;min&quot; === i3 ? t3.minY = e2.xaxis[i3] : t3.maxY = e2.xaxis[i3]);
      });
    }
    return t3.isMultipleYAxis ? (this.scales.scaleMultipleYAxes(), t3.minY = a2) : (this.scales.setYScaleForIndex(0, t3.minY, t3.maxY), t3.minY = t3.yAxisScale[0].niceMin, t3.maxY = t3.yAxisScale[0].niceMax, t3.minYArr[0] = t3.minY, t3.maxYArr[0] = t3.maxY), t3.barGroups = [], t3.lineGroups = [], t3.areaGroups = [], e2.series.forEach(function(i3) {
      switch (i3.type || e2.chart.type) {
        case &quot;bar&quot;:
        case &quot;column&quot;:
          t3.barGroups.push(i3.group);
          break;
        case &quot;line&quot;:
          t3.lineGroups.push(i3.group);
          break;
        case &quot;area&quot;:
          t3.areaGroups.push(i3.group);
      }
    }), t3.barGroups = t3.barGroups.filter(function(t4, e3, i3) {
      return i3.indexOf(t4) === e3;
    }), t3.lineGroups = t3.lineGroups.filter(function(t4, e3, i3) {
      return i3.indexOf(t4) === e3;
    }), t3.areaGroups = t3.areaGroups.filter(function(t4, e3, i3) {
      return i3.indexOf(t4) === e3;
    }), { minY: t3.minY, maxY: t3.maxY, minYArr: t3.minYArr, maxYArr: t3.maxYArr, yAxisScale: t3.yAxisScale };
  } }, { key: &quot;setXRange&quot;, value: function() {
    var t3 = this.w.globals, e2 = this.w.config, i2 = &quot;numeric&quot; === e2.xaxis.type || &quot;datetime&quot; === e2.xaxis.type || &quot;category&quot; === e2.xaxis.type &amp;&amp; !t3.noLabelsProvided || t3.noLabelsProvided || t3.isXNumeric;
    if (t3.isXNumeric &amp;&amp; function() {
      for (var e3 = 0; e3 &lt; t3.series.length; e3++) if (t3.labels[e3]) for (var i3 = 0; i3 &lt; t3.labels[e3].length; i3++) null !== t3.labels[e3][i3] &amp;&amp; v.isNumber(t3.labels[e3][i3]) &amp;&amp; (t3.maxX = Math.max(t3.maxX, t3.labels[e3][i3]), t3.initialMaxX = Math.max(t3.maxX, t3.labels[e3][i3]), t3.minX = Math.min(t3.minX, t3.labels[e3][i3]), t3.initialMinX = Math.min(t3.minX, t3.labels[e3][i3]));
    }(), t3.noLabelsProvided &amp;&amp; 0 === e2.xaxis.categories.length &amp;&amp; (t3.maxX = t3.labels[t3.labels.length - 1], t3.initialMaxX = t3.labels[t3.labels.length - 1], t3.minX = 1, t3.initialMinX = 1), t3.isXNumeric || t3.noLabelsProvided || t3.dataFormatXNumeric) {
      var a2 = 10;
      if (void 0 === e2.xaxis.tickAmount) a2 = Math.round(t3.svgWidth / 150), &quot;numeric&quot; === e2.xaxis.type &amp;&amp; t3.dataPoints &lt; 30 &amp;&amp; (a2 = t3.dataPoints - 1), a2 &gt; t3.dataPoints &amp;&amp; 0 !== t3.dataPoints &amp;&amp; (a2 = t3.dataPoints - 1);
      else if (&quot;dataPoints&quot; === e2.xaxis.tickAmount) {
        if (t3.series.length &gt; 1 &amp;&amp; (a2 = t3.series[t3.maxValsInArrayIndex].length - 1), t3.isXNumeric) {
          var s2 = Math.round(t3.maxX - t3.minX);
          s2 &lt; 30 &amp;&amp; (a2 = s2 - 1);
        }
      } else a2 = e2.xaxis.tickAmount;
      if (t3.xTickAmount = a2, void 0 !== e2.xaxis.max &amp;&amp; &quot;number&quot; == typeof e2.xaxis.max &amp;&amp; (t3.maxX = e2.xaxis.max), void 0 !== e2.xaxis.min &amp;&amp; &quot;number&quot; == typeof e2.xaxis.min &amp;&amp; (t3.minX = e2.xaxis.min), void 0 !== e2.xaxis.range &amp;&amp; (t3.minX = t3.maxX - e2.xaxis.range), t3.minX !== Number.MAX_VALUE &amp;&amp; t3.maxX !== -Number.MAX_VALUE) if (e2.xaxis.convertedCatToNumeric &amp;&amp; !t3.dataFormatXNumeric) {
        for (var r2 = [], n2 = t3.minX - 1; n2 &lt; t3.maxX; n2++) r2.push(n2 + 1);
        t3.xAxisScale = { result: r2, niceMin: r2[0], niceMax: r2[r2.length - 1] };
      } else t3.xAxisScale = this.scales.setXScale(t3.minX, t3.maxX);
      else t3.xAxisScale = this.scales.linearScale(0, a2, a2, 0, e2.xaxis.stepSize), t3.noLabelsProvided &amp;&amp; t3.labels.length &gt; 0 &amp;&amp; (t3.xAxisScale = this.scales.linearScale(1, t3.labels.length, a2 - 1, 0, e2.xaxis.stepSize), t3.seriesX = t3.labels.slice());
      i2 &amp;&amp; (t3.labels = t3.xAxisScale.result.slice());
    }
    return t3.isBarHorizontal &amp;&amp; t3.labels.length &amp;&amp; (t3.xTickAmount = t3.labels.length), this._handleSingleDataPoint(), this._getMinXDiff(), { minX: t3.minX, maxX: t3.maxX };
  } }, { key: &quot;setZRange&quot;, value: function() {
    var t3 = this.w.globals;
    if (t3.isDataXYZ) {
      for (var e2 = 0; e2 &lt; t3.series.length; e2++) if (void 0 !== t3.seriesZ[e2]) for (var i2 = 0; i2 &lt; t3.seriesZ[e2].length; i2++) null !== t3.seriesZ[e2][i2] &amp;&amp; v.isNumber(t3.seriesZ[e2][i2]) &amp;&amp; (t3.maxZ = Math.max(t3.maxZ, t3.seriesZ[e2][i2]), t3.minZ = Math.min(t3.minZ, t3.seriesZ[e2][i2]));
    }
  } }, { key: &quot;_handleSingleDataPoint&quot;, value: function() {
    var t3 = this.w.globals, e2 = this.w.config;
    if (t3.minX === t3.maxX) {
      var i2 = new zi(this.ctx);
      if (&quot;datetime&quot; === e2.xaxis.type) {
        var a2 = i2.getDate(t3.minX);
        e2.xaxis.labels.datetimeUTC ? a2.setUTCDate(a2.getUTCDate() - 2) : a2.setDate(a2.getDate() - 2), t3.minX = new Date(a2).getTime();
        var s2 = i2.getDate(t3.maxX);
        e2.xaxis.labels.datetimeUTC ? s2.setUTCDate(s2.getUTCDate() + 2) : s2.setDate(s2.getDate() + 2), t3.maxX = new Date(s2).getTime();
      } else (&quot;numeric&quot; === e2.xaxis.type || &quot;category&quot; === e2.xaxis.type &amp;&amp; !t3.noLabelsProvided) &amp;&amp; (t3.minX = t3.minX - 2, t3.initialMinX = t3.minX, t3.maxX = t3.maxX + 2, t3.initialMaxX = t3.maxX);
    }
  } }, { key: &quot;_getMinXDiff&quot;, value: function() {
    var t3 = this.w.globals;
    t3.isXNumeric &amp;&amp; t3.seriesX.forEach(function(e2, i2) {
      if (e2.length) {
        1 === e2.length &amp;&amp; e2.push(t3.seriesX[t3.maxValsInArrayIndex][t3.seriesX[t3.maxValsInArrayIndex].length - 1]);
        var a2 = e2.slice();
        a2.sort(function(t4, e3) {
          return t4 - e3;
        }), a2.forEach(function(e3, i3) {
          if (i3 &gt; 0) {
            var s2 = e3 - a2[i3 - 1];
            s2 &gt; 0 &amp;&amp; (t3.minXDiff = Math.min(s2, t3.minXDiff));
          }
        }), 1 !== t3.dataPoints &amp;&amp; t3.minXDiff !== Number.MAX_VALUE || (t3.minXDiff = 0.5);
      }
    });
  } }, { key: &quot;_setStackedMinMax&quot;, value: function() {
    var t3 = this, e2 = this.w.globals;
    if (e2.series.length) {
      var i2 = e2.seriesGroups;
      i2.length || (i2 = [this.w.globals.seriesNames.map(function(t4) {
        return t4;
      })]);
      var a2 = {}, s2 = {};
      i2.forEach(function(i3) {
        a2[i3] = [], s2[i3] = [], t3.w.config.series.map(function(t4, a3) {
          return i3.indexOf(e2.seriesNames[a3]) &gt; -1 ? a3 : null;
        }).filter(function(t4) {
          return null !== t4;
        }).forEach(function(r2) {
          for (var n2 = 0; n2 &lt; e2.series[e2.maxValsInArrayIndex].length; n2++) {
            var o2, l2, h2, c2;
            void 0 === a2[i3][n2] &amp;&amp; (a2[i3][n2] = 0, s2[i3][n2] = 0), (t3.w.config.chart.stacked &amp;&amp; !e2.comboCharts || t3.w.config.chart.stacked &amp;&amp; e2.comboCharts &amp;&amp; (!t3.w.config.chart.stackOnlyBar || &quot;bar&quot; === (null === (o2 = t3.w.config.series) || void 0 === o2 || null === (l2 = o2[r2]) || void 0 === l2 ? void 0 : l2.type) || &quot;column&quot; === (null === (h2 = t3.w.config.series) || void 0 === h2 || null === (c2 = h2[r2]) || void 0 === c2 ? void 0 : c2.type))) &amp;&amp; null !== e2.series[r2][n2] &amp;&amp; v.isNumber(e2.series[r2][n2]) &amp;&amp; (e2.series[r2][n2] &gt; 0 ? a2[i3][n2] += parseFloat(e2.series[r2][n2]) + 1e-4 : s2[i3][n2] += parseFloat(e2.series[r2][n2]));
          }
        });
      }), Object.entries(a2).forEach(function(t4) {
        var i3 = p(t4, 1)[0];
        a2[i3].forEach(function(t5, r2) {
          e2.maxY = Math.max(e2.maxY, a2[i3][r2]), e2.minY = Math.min(e2.minY, s2[i3][r2]);
        });
      });
    }
  } }]), t2;
}();
var ia = function() {
  function t2(e2, a2) {
    i(this, t2), this.ctx = e2, this.elgrid = a2, this.w = e2.w;
    var s2 = this.w;
    this.xaxisFontSize = s2.config.xaxis.labels.style.fontSize, this.axisFontFamily = s2.config.xaxis.labels.style.fontFamily, this.xaxisForeColors = s2.config.xaxis.labels.style.colors, this.isCategoryBarHorizontal = &quot;bar&quot; === s2.config.chart.type &amp;&amp; s2.config.plotOptions.bar.horizontal, this.xAxisoffX = &quot;bottom&quot; === s2.config.xaxis.position ? s2.globals.gridHeight : 0, this.drawnLabels = [], this.axesUtils = new Ri(e2);
  }
  return s(t2, [{ key: &quot;drawYaxis&quot;, value: function(t3) {
    var e2 = this.w, i2 = new Mi(this.ctx), a2 = e2.config.yaxis[t3].labels.style, s2 = a2.fontSize, r2 = a2.fontFamily, n2 = a2.fontWeight, o2 = i2.group({ class: &quot;apexcharts-yaxis&quot;, rel: t3, transform: &quot;translate(&quot;.concat(e2.globals.translateYAxisX[t3], &quot;, 0)&quot;) });
    if (this.axesUtils.isYAxisHidden(t3)) return o2;
    var l2 = i2.group({ class: &quot;apexcharts-yaxis-texts-g&quot; });
    o2.add(l2);
    var h2 = e2.globals.yAxisScale[t3].result.length - 1, c2 = e2.globals.gridHeight / h2, d2 = e2.globals.yLabelFormatters[t3], u2 = this.axesUtils.checkForReversedLabels(t3, e2.globals.yAxisScale[t3].result.slice());
    if (e2.config.yaxis[t3].labels.show) {
      var g2 = e2.globals.translateY + e2.config.yaxis[t3].labels.offsetY;
      e2.globals.isBarHorizontal ? g2 = 0 : &quot;heatmap&quot; === e2.config.chart.type &amp;&amp; (g2 -= c2 / 2), g2 += parseInt(s2, 10) / 3;
      for (var p2 = h2; p2 &gt;= 0; p2--) {
        var f2 = d2(u2[p2], p2, e2), x2 = e2.config.yaxis[t3].labels.padding;
        e2.config.yaxis[t3].opposite &amp;&amp; 0 !== e2.config.yaxis.length &amp;&amp; (x2 *= -1);
        var b2 = this.getTextAnchor(e2.config.yaxis[t3].labels.align, e2.config.yaxis[t3].opposite), m2 = this.axesUtils.getYAxisForeColor(a2.colors, t3), y2 = Array.isArray(m2) ? m2[p2] : m2, w2 = v.listToArray(e2.globals.dom.baseEl.querySelectorAll(&quot;.apexcharts-yaxis[rel=&#x27;&quot;.concat(t3, &quot;&#x27;] .apexcharts-yaxis-label tspan&quot;))).map(function(t4) {
          return t4.textContent;
        }), k2 = i2.drawText({ x: x2, y: g2, text: w2.includes(f2) &amp;&amp; !e2.config.yaxis[t3].labels.showDuplicates ? &quot;&quot; : f2, textAnchor: b2, fontSize: s2, fontFamily: r2, fontWeight: n2, maxWidth: e2.config.yaxis[t3].labels.maxWidth, foreColor: y2, isPlainText: false, cssClass: &quot;apexcharts-yaxis-label &quot;.concat(a2.cssClass) });
        l2.add(k2), this.addTooltip(k2, f2), 0 !== e2.config.yaxis[t3].labels.rotate &amp;&amp; this.rotateLabel(i2, k2, firstLabel, e2.config.yaxis[t3].labels.rotate), g2 += c2;
      }
    }
    return this.addYAxisTitle(i2, o2, t3), this.addAxisBorder(i2, o2, t3, h2, c2), o2;
  } }, { key: &quot;getTextAnchor&quot;, value: function(t3, e2) {
    return &quot;left&quot; === t3 ? &quot;start&quot; : &quot;center&quot; === t3 ? &quot;middle&quot; : &quot;right&quot; === t3 ? &quot;end&quot; : e2 ? &quot;start&quot; : &quot;end&quot;;
  } }, { key: &quot;addTooltip&quot;, value: function(t3, e2) {
    var i2 = document.createElementNS(this.w.globals.SVGNS, &quot;title&quot;);
    i2.textContent = Array.isArray(e2) ? e2.join(&quot; &quot;) : e2, t3.node.appendChild(i2);
  } }, { key: &quot;rotateLabel&quot;, value: function(t3, e2, i2, a2) {
    var s2 = t3.rotateAroundCenter(i2.node), r2 = t3.rotateAroundCenter(e2.node);
    e2.node.setAttribute(&quot;transform&quot;, &quot;rotate(&quot;.concat(a2, &quot; &quot;).concat(s2.x, &quot; &quot;).concat(r2.y, &quot;)&quot;));
  } }, { key: &quot;addYAxisTitle&quot;, value: function(t3, e2, i2) {
    var a2 = this.w;
    if (void 0 !== a2.config.yaxis[i2].title.text) {
      var s2 = t3.group({ class: &quot;apexcharts-yaxis-title&quot; }), r2 = a2.config.yaxis[i2].opposite ? a2.globals.translateYAxisX[i2] : 0, n2 = t3.drawText({ x: r2, y: a2.globals.gridHeight / 2 + a2.globals.translateY + a2.config.yaxis[i2].title.offsetY, text: a2.config.yaxis[i2].title.text, textAnchor: &quot;end&quot;, foreColor: a2.config.yaxis[i2].title.style.color, fontSize: a2.config.yaxis[i2].title.style.fontSize, fontWeight: a2.config.yaxis[i2].title.style.fontWeight, fontFamily: a2.config.yaxis[i2].title.style.fontFamily, cssClass: &quot;apexcharts-yaxis-title-text &quot;.concat(a2.config.yaxis[i2].title.style.cssClass) });
      s2.add(n2), e2.add(s2);
    }
  } }, { key: &quot;addAxisBorder&quot;, value: function(t3, e2, i2, a2, s2) {
    var r2 = this.w, n2 = r2.config.yaxis[i2].axisBorder, o2 = 31 + n2.offsetX;
    if (r2.config.yaxis[i2].opposite &amp;&amp; (o2 = -31 - n2.offsetX), n2.show) {
      var l2 = t3.drawLine(o2, r2.globals.translateY + n2.offsetY - 2, o2, r2.globals.gridHeight + r2.globals.translateY + n2.offsetY + 2, n2.color, 0, n2.width);
      e2.add(l2);
    }
    r2.config.yaxis[i2].axisTicks.show &amp;&amp; this.axesUtils.drawYAxisTicks(o2, a2, n2, r2.config.yaxis[i2].axisTicks, i2, s2, e2);
  } }, { key: &quot;drawYaxisInversed&quot;, value: function(t3) {
    var e2 = this.w, i2 = new Mi(this.ctx), a2 = i2.group({ class: &quot;apexcharts-xaxis apexcharts-yaxis-inversed&quot; }), s2 = i2.group({ class: &quot;apexcharts-xaxis-texts-g&quot;, transform: &quot;translate(&quot;.concat(e2.globals.translateXAxisX, &quot;, &quot;).concat(e2.globals.translateXAxisY, &quot;)&quot;) });
    a2.add(s2);
    var r2 = e2.globals.yAxisScale[t3].result.length - 1, n2 = e2.globals.gridWidth / r2 + 0.1, o2 = n2 + e2.config.xaxis.labels.offsetX, l2 = e2.globals.xLabelFormatter, h2 = this.axesUtils.checkForReversedLabels(t3, e2.globals.yAxisScale[t3].result.slice()), c2 = e2.globals.timescaleLabels;
    if (c2.length &gt; 0 &amp;&amp; (this.xaxisLabels = c2.slice(), r2 = (h2 = c2.slice()).length), e2.config.xaxis.labels.show) for (var d2 = c2.length ? 0 : r2; c2.length ? d2 &lt; c2.length : d2 &gt;= 0; c2.length ? d2++ : d2--) {
      var u2 = l2(h2[d2], d2, e2), g2 = e2.globals.gridWidth + e2.globals.padHorizontal - (o2 - n2 + e2.config.xaxis.labels.offsetX);
      if (c2.length) {
        var p2 = this.axesUtils.getLabel(h2, c2, g2, d2, this.drawnLabels, this.xaxisFontSize);
        g2 = p2.x, u2 = p2.text, this.drawnLabels.push(p2.text), 0 === d2 &amp;&amp; e2.globals.skipFirstTimelinelabel &amp;&amp; (u2 = &quot;&quot;), d2 === h2.length - 1 &amp;&amp; e2.globals.skipLastTimelinelabel &amp;&amp; (u2 = &quot;&quot;);
      }
      var f2 = i2.drawText({ x: g2, y: this.xAxisoffX + e2.config.xaxis.labels.offsetY + 30 - (&quot;top&quot; === e2.config.xaxis.position ? e2.globals.xAxisHeight + e2.config.xaxis.axisTicks.height - 2 : 0), text: u2, textAnchor: &quot;middle&quot;, foreColor: Array.isArray(this.xaxisForeColors) ? this.xaxisForeColors[t3] : this.xaxisForeColors, fontSize: this.xaxisFontSize, fontFamily: this.xaxisFontFamily, fontWeight: e2.config.xaxis.labels.style.fontWeight, isPlainText: false, cssClass: &quot;apexcharts-xaxis-label &quot;.concat(e2.config.xaxis.labels.style.cssClass) });
      s2.add(f2), f2.tspan(u2), this.addTooltip(f2, u2), o2 += n2;
    }
    return this.inversedYAxisTitleText(a2), this.inversedYAxisBorder(a2), a2;
  } }, { key: &quot;inversedYAxisBorder&quot;, value: function(t3) {
    var e2 = this.w, i2 = new Mi(this.ctx), a2 = e2.config.xaxis.axisBorder;
    if (a2.show) {
      var s2 = 0;
      &quot;bar&quot; === e2.config.chart.type &amp;&amp; e2.globals.isXNumeric &amp;&amp; (s2 -= 15);
      var r2 = i2.drawLine(e2.globals.padHorizontal + s2 + a2.offsetX, this.xAxisoffX, e2.globals.gridWidth, this.xAxisoffX, a2.color, 0, a2.height);
      this.elgrid &amp;&amp; this.elgrid.elGridBorders &amp;&amp; e2.config.grid.show ? this.elgrid.elGridBorders.add(r2) : t3.add(r2);
    }
  } }, { key: &quot;inversedYAxisTitleText&quot;, value: function(t3) {
    var e2 = this.w, i2 = new Mi(this.ctx);
    if (void 0 !== e2.config.xaxis.title.text) {
      var a2 = i2.group({ class: &quot;apexcharts-xaxis-title apexcharts-yaxis-title-inversed&quot; }), s2 = i2.drawText({ x: e2.globals.gridWidth / 2 + e2.config.xaxis.title.offsetX, y: this.xAxisoffX + parseFloat(this.xaxisFontSize) + parseFloat(e2.config.xaxis.title.style.fontSize) + e2.config.xaxis.title.offsetY + 20, text: e2.config.xaxis.title.text, textAnchor: &quot;middle&quot;, fontSize: e2.config.xaxis.title.style.fontSize, fontFamily: e2.config.xaxis.title.style.fontFamily, fontWeight: e2.config.xaxis.title.style.fontWeight, foreColor: e2.config.xaxis.title.style.color, cssClass: &quot;apexcharts-xaxis-title-text &quot;.concat(e2.config.xaxis.title.style.cssClass) });
      a2.add(s2), t3.add(a2);
    }
  } }, { key: &quot;yAxisTitleRotate&quot;, value: function(t3, e2) {
    var i2 = this.w, a2 = new Mi(this.ctx), s2 = i2.globals.dom.baseEl.querySelector(&quot;.apexcharts-yaxis[rel=&#x27;&quot;.concat(t3, &quot;&#x27;] .apexcharts-yaxis-texts-g&quot;)), r2 = s2 ? s2.getBoundingClientRect() : { width: 0, height: 0 }, n2 = i2.globals.dom.baseEl.querySelector(&quot;.apexcharts-yaxis[rel=&#x27;&quot;.concat(t3, &quot;&#x27;] .apexcharts-yaxis-title text&quot;)), o2 = n2 ? n2.getBoundingClientRect() : { width: 0, height: 0 };
    if (n2) {
      var l2 = this.xPaddingForYAxisTitle(t3, r2, o2, e2);
      n2.setAttribute(&quot;x&quot;, l2.xPos - (e2 ? 10 : 0));
      var h2 = a2.rotateAroundCenter(n2);
      n2.setAttribute(&quot;transform&quot;, &quot;rotate(&quot;.concat(e2 ? -1 * i2.config.yaxis[t3].title.rotate : i2.config.yaxis[t3].title.rotate, &quot; &quot;).concat(h2.x, &quot; &quot;).concat(h2.y, &quot;)&quot;));
    }
  } }, { key: &quot;xPaddingForYAxisTitle&quot;, value: function(t3, e2, i2, a2) {
    var s2 = this.w, r2 = 0, n2 = 10;
    return void 0 === s2.config.yaxis[t3].title.text || t3 &lt; 0 ? { xPos: r2, padd: 0 } : (a2 ? r2 = e2.width + s2.config.yaxis[t3].title.offsetX + i2.width / 2 + n2 / 2 : (r2 = -1 * e2.width + s2.config.yaxis[t3].title.offsetX + n2 / 2 + i2.width / 2, s2.globals.isBarHorizontal &amp;&amp; (n2 = 25, r2 = -1 * e2.width - s2.config.yaxis[t3].title.offsetX - n2)), { xPos: r2, padd: n2 });
  } }, { key: &quot;setYAxisXPosition&quot;, value: function(t3, e2) {
    var i2 = this.w, a2 = 0, s2 = 0, r2 = 18, n2 = 1;
    i2.config.yaxis.length &gt; 1 &amp;&amp; (this.multipleYs = true), i2.config.yaxis.forEach(function(o2, l2) {
      var h2 = i2.globals.ignoreYAxisIndexes.includes(l2) || !o2.show || o2.floating || 0 === t3[l2].width, c2 = t3[l2].width + e2[l2].width;
      o2.opposite ? i2.globals.isBarHorizontal ? (s2 = i2.globals.gridWidth + i2.globals.translateX - 1, i2.globals.translateYAxisX[l2] = s2 - o2.labels.offsetX) : (s2 = i2.globals.gridWidth + i2.globals.translateX + n2, h2 || (n2 += c2 + 20), i2.globals.translateYAxisX[l2] = s2 - o2.labels.offsetX + 20) : (a2 = i2.globals.translateX - r2, h2 || (r2 += c2 + 20), i2.globals.translateYAxisX[l2] = a2 + o2.labels.offsetX);
    });
  } }, { key: &quot;setYAxisTextAlignments&quot;, value: function() {
    var t3 = this.w;
    v.listToArray(t3.globals.dom.baseEl.getElementsByClassName(&quot;apexcharts-yaxis&quot;)).forEach(function(e2, i2) {
      var a2 = t3.config.yaxis[i2];
      if (a2 &amp;&amp; !a2.floating &amp;&amp; void 0 !== a2.labels.align) {
        var s2 = t3.globals.dom.baseEl.querySelector(&quot;.apexcharts-yaxis[rel=&#x27;&quot;.concat(i2, &quot;&#x27;] .apexcharts-yaxis-texts-g&quot;)), r2 = v.listToArray(t3.globals.dom.baseEl.querySelectorAll(&quot;.apexcharts-yaxis[rel=&#x27;&quot;.concat(i2, &quot;&#x27;] .apexcharts-yaxis-label&quot;))), n2 = s2.getBoundingClientRect();
        r2.forEach(function(t4) {
          t4.setAttribute(&quot;text-anchor&quot;, a2.labels.align);
        }), &quot;left&quot; !== a2.labels.align || a2.opposite ? &quot;center&quot; === a2.labels.align ? s2.setAttribute(&quot;transform&quot;, &quot;translate(&quot;.concat(n2.width / 2 * (a2.opposite ? 1 : -1), &quot;, 0)&quot;)) : &quot;right&quot; === a2.labels.align &amp;&amp; a2.opposite &amp;&amp; s2.setAttribute(&quot;transform&quot;, &quot;translate(&quot;.concat(n2.width, &quot;, 0)&quot;)) : s2.setAttribute(&quot;transform&quot;, &quot;translate(-&quot;.concat(n2.width, &quot;, 0)&quot;));
      }
    });
  } }]), t2;
}();
var aa = function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w, this.documentEvent = v.bind(this.documentEvent, this);
  }
  return s(t2, [{ key: &quot;addEventListener&quot;, value: function(t3, e2) {
    var i2 = this.w;
    i2.globals.events.hasOwnProperty(t3) ? i2.globals.events[t3].push(e2) : i2.globals.events[t3] = [e2];
  } }, { key: &quot;removeEventListener&quot;, value: function(t3, e2) {
    var i2 = this.w;
    if (i2.globals.events.hasOwnProperty(t3)) {
      var a2 = i2.globals.events[t3].indexOf(e2);
      -1 !== a2 &amp;&amp; i2.globals.events[t3].splice(a2, 1);
    }
  } }, { key: &quot;fireEvent&quot;, value: function(t3, e2) {
    var i2 = this.w;
    if (i2.globals.events.hasOwnProperty(t3)) {
      e2 &amp;&amp; e2.length || (e2 = []);
      for (var a2 = i2.globals.events[t3], s2 = a2.length, r2 = 0; r2 &lt; s2; r2++) a2[r2].apply(null, e2);
    }
  } }, { key: &quot;setupEventHandlers&quot;, value: function() {
    var t3 = this, e2 = this.w, i2 = this.ctx, a2 = e2.globals.dom.baseEl.querySelector(e2.globals.chartClass);
    this.ctx.eventList.forEach(function(t4) {
      a2.addEventListener(t4, function(t5) {
        var a3 = Object.assign({}, e2, { seriesIndex: e2.globals.axisCharts ? e2.globals.capturedSeriesIndex : 0, dataPointIndex: e2.globals.capturedDataPointIndex });
        &quot;mousemove&quot; === t5.type || &quot;touchmove&quot; === t5.type ? &quot;function&quot; == typeof e2.config.chart.events.mouseMove &amp;&amp; e2.config.chart.events.mouseMove(t5, i2, a3) : &quot;mouseleave&quot; === t5.type || &quot;touchleave&quot; === t5.type ? &quot;function&quot; == typeof e2.config.chart.events.mouseLeave &amp;&amp; e2.config.chart.events.mouseLeave(t5, i2, a3) : (&quot;mouseup&quot; === t5.type &amp;&amp; 1 === t5.which || &quot;touchend&quot; === t5.type) &amp;&amp; (&quot;function&quot; == typeof e2.config.chart.events.click &amp;&amp; e2.config.chart.events.click(t5, i2, a3), i2.ctx.events.fireEvent(&quot;click&quot;, [t5, i2, a3]));
      }, { capture: false, passive: true });
    }), this.ctx.eventList.forEach(function(i3) {
      e2.globals.dom.baseEl.addEventListener(i3, t3.documentEvent, { passive: true });
    }), this.ctx.core.setupBrushHandler();
  } }, { key: &quot;documentEvent&quot;, value: function(t3) {
    var e2 = this.w, i2 = t3.target.className;
    if (&quot;click&quot; === t3.type) {
      var a2 = e2.globals.dom.baseEl.querySelector(&quot;.apexcharts-menu&quot;);
      a2 &amp;&amp; a2.classList.contains(&quot;apexcharts-menu-open&quot;) &amp;&amp; &quot;apexcharts-menu-icon&quot; !== i2 &amp;&amp; a2.classList.remove(&quot;apexcharts-menu-open&quot;);
    }
    e2.globals.clientX = &quot;touchmove&quot; === t3.type ? t3.touches[0].clientX : t3.clientX, e2.globals.clientY = &quot;touchmove&quot; === t3.type ? t3.touches[0].clientY : t3.clientY;
  } }]), t2;
}();
var sa = function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w;
  }
  return s(t2, [{ key: &quot;setCurrentLocaleValues&quot;, value: function(t3) {
    var e2 = this.w.config.chart.locales;
    window.Apex.chart &amp;&amp; window.Apex.chart.locales &amp;&amp; window.Apex.chart.locales.length &gt; 0 &amp;&amp; (e2 = this.w.config.chart.locales.concat(window.Apex.chart.locales));
    var i2 = e2.filter(function(e3) {
      return e3.name === t3;
    })[0];
    if (!i2) throw new Error(&quot;Wrong locale name provided. Please make sure you set the correct locale name in options&quot;);
    var a2 = v.extend(Hi, i2);
    this.w.globals.locale = a2.options;
  } }]), t2;
}();
var ra = function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w;
  }
  return s(t2, [{ key: &quot;drawAxis&quot;, value: function(t3, e2) {
    var i2, a2, s2 = this, r2 = this.w.globals, n2 = this.w.config, o2 = new Qi(this.ctx, e2), l2 = new ia(this.ctx, e2);
    r2.axisCharts &amp;&amp; &quot;radar&quot; !== t3 &amp;&amp; (r2.isBarHorizontal ? (a2 = l2.drawYaxisInversed(0), i2 = o2.drawXaxisInversed(0), r2.dom.elGraphical.add(i2), r2.dom.elGraphical.add(a2)) : (i2 = o2.drawXaxis(), r2.dom.elGraphical.add(i2), n2.yaxis.map(function(t4, e3) {
      if (-1 === r2.ignoreYAxisIndexes.indexOf(e3) &amp;&amp; (a2 = l2.drawYaxis(e3), r2.dom.Paper.add(a2), &quot;back&quot; === s2.w.config.grid.position)) {
        var i3 = r2.dom.Paper.children()[1];
        i3.remove(), r2.dom.Paper.add(i3);
      }
    })));
  } }]), t2;
}();
var na = function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w;
  }
  return s(t2, [{ key: &quot;drawXCrosshairs&quot;, value: function() {
    var t3 = this.w, e2 = new Mi(this.ctx), i2 = new Li(this.ctx), a2 = t3.config.xaxis.crosshairs.fill.gradient, s2 = t3.config.xaxis.crosshairs.dropShadow, r2 = t3.config.xaxis.crosshairs.fill.type, n2 = a2.colorFrom, o2 = a2.colorTo, l2 = a2.opacityFrom, h2 = a2.opacityTo, c2 = a2.stops, d2 = s2.enabled, u2 = s2.left, g2 = s2.top, p2 = s2.blur, f2 = s2.color, x2 = s2.opacity, b2 = t3.config.xaxis.crosshairs.fill.color;
    if (t3.config.xaxis.crosshairs.show) {
      &quot;gradient&quot; === r2 &amp;&amp; (b2 = e2.drawGradient(&quot;vertical&quot;, n2, o2, l2, h2, null, c2, null));
      var m2 = e2.drawRect();
      1 === t3.config.xaxis.crosshairs.width &amp;&amp; (m2 = e2.drawLine());
      var y2 = t3.globals.gridHeight;
      (!v.isNumber(y2) || y2 &lt; 0) &amp;&amp; (y2 = 0);
      var w2 = t3.config.xaxis.crosshairs.width;
      (!v.isNumber(w2) || w2 &lt; 0) &amp;&amp; (w2 = 0), m2.attr({ class: &quot;apexcharts-xcrosshairs&quot;, x: 0, y: 0, y2, width: w2, height: y2, fill: b2, filter: &quot;none&quot;, &quot;fill-opacity&quot;: t3.config.xaxis.crosshairs.opacity, stroke: t3.config.xaxis.crosshairs.stroke.color, &quot;stroke-width&quot;: t3.config.xaxis.crosshairs.stroke.width, &quot;stroke-dasharray&quot;: t3.config.xaxis.crosshairs.stroke.dashArray }), d2 &amp;&amp; (m2 = i2.dropShadow(m2, { left: u2, top: g2, blur: p2, color: f2, opacity: x2 })), t3.globals.dom.elGraphical.add(m2);
    }
  } }, { key: &quot;drawYCrosshairs&quot;, value: function() {
    var t3 = this.w, e2 = new Mi(this.ctx), i2 = t3.config.yaxis[0].crosshairs, a2 = t3.globals.barPadForNumericAxis;
    if (t3.config.yaxis[0].crosshairs.show) {
      var s2 = e2.drawLine(-a2, 0, t3.globals.gridWidth + a2, 0, i2.stroke.color, i2.stroke.dashArray, i2.stroke.width);
      s2.attr({ class: &quot;apexcharts-ycrosshairs&quot; }), t3.globals.dom.elGraphical.add(s2);
    }
    var r2 = e2.drawLine(-a2, 0, t3.globals.gridWidth + a2, 0, i2.stroke.color, 0, 0);
    r2.attr({ class: &quot;apexcharts-ycrosshairs-hidden&quot; }), t3.globals.dom.elGraphical.add(r2);
  } }]), t2;
}();
var oa = function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w;
  }
  return s(t2, [{ key: &quot;checkResponsiveConfig&quot;, value: function(t3) {
    var e2 = this, i2 = this.w, a2 = i2.config;
    if (0 !== a2.responsive.length) {
      var s2 = a2.responsive.slice();
      s2.sort(function(t4, e3) {
        return t4.breakpoint &gt; e3.breakpoint ? 1 : e3.breakpoint &gt; t4.breakpoint ? -1 : 0;
      }).reverse();
      var r2 = new Wi({}), n2 = function() {
        var t4 = arguments.length &gt; 0 &amp;&amp; void 0 !== arguments[0] ? arguments[0] : {}, a3 = s2[0].breakpoint, n3 = window.innerWidth &gt; 0 ? window.innerWidth : screen.width;
        if (n3 &gt; a3) {
          var o3 = v.clone(i2.globals.initialConfig);
          o3.series = v.clone(i2.config.series);
          var l2 = Pi.extendArrayProps(r2, o3, i2);
          t4 = v.extend(l2, t4), t4 = v.extend(i2.config, t4), e2.overrideResponsiveOptions(t4);
        } else for (var h2 = 0; h2 &lt; s2.length; h2++) n3 &lt; s2[h2].breakpoint &amp;&amp; (t4 = Pi.extendArrayProps(r2, s2[h2].options, i2), t4 = v.extend(i2.config, t4), e2.overrideResponsiveOptions(t4));
      };
      if (t3) {
        var o2 = Pi.extendArrayProps(r2, t3, i2);
        o2 = v.extend(i2.config, o2), n2(o2 = v.extend(o2, t3));
      } else n2({});
    }
  } }, { key: &quot;overrideResponsiveOptions&quot;, value: function(t3) {
    var e2 = new Wi(t3).init({ responsiveOverride: true });
    this.w.config = e2;
  } }]), t2;
}();
var la = function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w, this.colors = [], this.isColorFn = false, this.isHeatmapDistributed = this.checkHeatmapDistributed(), this.isBarDistributed = this.checkBarDistributed();
  }
  return s(t2, [{ key: &quot;checkHeatmapDistributed&quot;, value: function() {
    var t3 = this.w.config, e2 = t3.chart, i2 = t3.plotOptions;
    return &quot;treemap&quot; === e2.type &amp;&amp; i2.treemap &amp;&amp; i2.treemap.distributed || &quot;heatmap&quot; === e2.type &amp;&amp; i2.heatmap &amp;&amp; i2.heatmap.distributed;
  } }, { key: &quot;checkBarDistributed&quot;, value: function() {
    var t3 = this.w.config, e2 = t3.chart, i2 = t3.plotOptions;
    return i2.bar &amp;&amp; i2.bar.distributed &amp;&amp; (&quot;bar&quot; === e2.type || &quot;rangeBar&quot; === e2.type);
  } }, { key: &quot;init&quot;, value: function() {
    this.setDefaultColors();
  } }, { key: &quot;setDefaultColors&quot;, value: function() {
    var t3 = this.w, e2 = new v();
    t3.globals.dom.elWrap.classList.add(&quot;apexcharts-theme-&quot;.concat(t3.config.theme.mode));
    var i2 = f(t3.config.colors || t3.config.fill.colors || []);
    t3.globals.colors = this.getColors(i2), this.applySeriesColors(t3.globals.seriesColors, t3.globals.colors), t3.config.theme.monochrome.enabled &amp;&amp; (t3.globals.colors = this.getMonochromeColors(t3.config.theme.monochrome, t3.globals.series, e2));
    var a2 = t3.globals.colors.slice();
    this.pushExtraColors(t3.globals.colors), this.applyColorTypes([&quot;fill&quot;, &quot;stroke&quot;], a2), this.applyDataLabelsColors(a2), this.applyRadarPolygonsColors(), this.applyMarkersColors(a2);
  } }, { key: &quot;getColors&quot;, value: function(t3) {
    var e2 = this, i2 = this.w;
    return t3 &amp;&amp; 0 !== t3.length ? Array.isArray(t3) &amp;&amp; t3.length &gt; 0 &amp;&amp; &quot;function&quot; == typeof t3[0] ? (this.isColorFn = true, i2.config.series.map(function(a2, s2) {
      var r2 = t3[s2] || t3[0];
      return &quot;function&quot; == typeof r2 ? r2({ value: i2.globals.axisCharts ? i2.globals.series[s2][0] || 0 : i2.globals.series[s2], seriesIndex: s2, dataPointIndex: s2, w: e2.w }) : r2;
    })) : t3 : this.predefined();
  } }, { key: &quot;applySeriesColors&quot;, value: function(t3, e2) {
    t3.forEach(function(t4, i2) {
      t4 &amp;&amp; (e2[i2] = t4);
    });
  } }, { key: &quot;getMonochromeColors&quot;, value: function(t3, e2, i2) {
    var a2 = t3.color, s2 = t3.shadeIntensity, r2 = t3.shadeTo, n2 = this.isBarDistributed || this.isHeatmapDistributed ? e2[0].length * e2.length : e2.length, o2 = 1 / (n2 / s2), l2 = 0;
    return Array.from({ length: n2 }, function() {
      var t4 = &quot;dark&quot; === r2 ? i2.shadeColor(-1 * l2, a2) : i2.shadeColor(l2, a2);
      return l2 += o2, t4;
    });
  } }, { key: &quot;applyColorTypes&quot;, value: function(t3, e2) {
    var i2 = this, a2 = this.w;
    t3.forEach(function(t4) {
      a2.globals[t4].colors = void 0 === a2.config[t4].colors ? i2.isColorFn ? a2.config.colors : e2 : a2.config[t4].colors.slice(), i2.pushExtraColors(a2.globals[t4].colors);
    });
  } }, { key: &quot;applyDataLabelsColors&quot;, value: function(t3) {
    var e2 = this.w;
    e2.globals.dataLabels.style.colors = void 0 === e2.config.dataLabels.style.colors ? t3 : e2.config.dataLabels.style.colors.slice(), this.pushExtraColors(e2.globals.dataLabels.style.colors, 50);
  } }, { key: &quot;applyRadarPolygonsColors&quot;, value: function() {
    var t3 = this.w;
    t3.globals.radarPolygons.fill.colors = void 0 === t3.config.plotOptions.radar.polygons.fill.colors ? [&quot;dark&quot; === t3.config.theme.mode ? &quot;#424242&quot; : &quot;none&quot;] : t3.config.plotOptions.radar.polygons.fill.colors.slice(), this.pushExtraColors(t3.globals.radarPolygons.fill.colors, 20);
  } }, { key: &quot;applyMarkersColors&quot;, value: function(t3) {
    var e2 = this.w;
    e2.globals.markers.colors = void 0 === e2.config.markers.colors ? t3 : e2.config.markers.colors.slice(), this.pushExtraColors(e2.globals.markers.colors);
  } }, { key: &quot;pushExtraColors&quot;, value: function(t3, e2) {
    var i2 = arguments.length &gt; 2 &amp;&amp; void 0 !== arguments[2] ? arguments[2] : null, a2 = this.w, s2 = e2 || a2.globals.series.length;
    if (null === i2 &amp;&amp; (i2 = this.isBarDistributed || this.isHeatmapDistributed || &quot;heatmap&quot; === a2.config.chart.type &amp;&amp; a2.config.plotOptions.heatmap &amp;&amp; a2.config.plotOptions.heatmap.colorScale.inverse), i2 &amp;&amp; a2.globals.series.length &amp;&amp; (s2 = a2.globals.series[a2.globals.maxValsInArrayIndex].length * a2.globals.series.length), t3.length &lt; s2) for (var r2 = s2 - t3.length, n2 = 0; n2 &lt; r2; n2++) t3.push(t3[n2]);
  } }, { key: &quot;updateThemeOptions&quot;, value: function(t3) {
    t3.chart = t3.chart || {}, t3.tooltip = t3.tooltip || {};
    var e2 = t3.theme.mode, i2 = &quot;dark&quot; === e2 ? &quot;palette4&quot; : &quot;light&quot; === e2 ? &quot;palette1&quot; : t3.theme.palette || &quot;palette1&quot;, a2 = &quot;dark&quot; === e2 ? &quot;#f6f7f8&quot; : &quot;light&quot; === e2 ? &quot;#373d3f&quot; : t3.chart.foreColor || &quot;#373d3f&quot;;
    return t3.tooltip.theme = e2 || &quot;light&quot;, t3.chart.foreColor = a2, t3.theme.palette = i2, t3;
  } }, { key: &quot;predefined&quot;, value: function() {
    var t3 = { palette1: [&quot;#008FFB&quot;, &quot;#00E396&quot;, &quot;#FEB019&quot;, &quot;#FF4560&quot;, &quot;#775DD0&quot;], palette2: [&quot;#3f51b5&quot;, &quot;#03a9f4&quot;, &quot;#4caf50&quot;, &quot;#f9ce1d&quot;, &quot;#FF9800&quot;], palette3: [&quot;#33b2df&quot;, &quot;#546E7A&quot;, &quot;#d4526e&quot;, &quot;#13d8aa&quot;, &quot;#A5978B&quot;], palette4: [&quot;#4ecdc4&quot;, &quot;#c7f464&quot;, &quot;#81D4FA&quot;, &quot;#fd6a6a&quot;, &quot;#546E7A&quot;], palette5: [&quot;#2b908f&quot;, &quot;#f9a3a4&quot;, &quot;#90ee7e&quot;, &quot;#fa4443&quot;, &quot;#69d2e7&quot;], palette6: [&quot;#449DD1&quot;, &quot;#F86624&quot;, &quot;#EA3546&quot;, &quot;#662E9B&quot;, &quot;#C5D86D&quot;], palette7: [&quot;#D7263D&quot;, &quot;#1B998B&quot;, &quot;#2E294E&quot;, &quot;#F46036&quot;, &quot;#E2C044&quot;], palette8: [&quot;#662E9B&quot;, &quot;#F86624&quot;, &quot;#F9C80E&quot;, &quot;#EA3546&quot;, &quot;#43BCCD&quot;], palette9: [&quot;#5C4742&quot;, &quot;#A5978B&quot;, &quot;#8D5B4C&quot;, &quot;#5A2A27&quot;, &quot;#C4BBAF&quot;], palette10: [&quot;#A300D6&quot;, &quot;#7D02EB&quot;, &quot;#5653FE&quot;, &quot;#2983FF&quot;, &quot;#00B1F2&quot;], default: [&quot;#008FFB&quot;, &quot;#00E396&quot;, &quot;#FEB019&quot;, &quot;#FF4560&quot;, &quot;#775DD0&quot;] };
    return t3[this.w.config.theme.palette] || t3.default;
  } }]), t2;
}();
var ha = function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w;
  }
  return s(t2, [{ key: &quot;draw&quot;, value: function() {
    this.drawTitleSubtitle(&quot;title&quot;), this.drawTitleSubtitle(&quot;subtitle&quot;);
  } }, { key: &quot;drawTitleSubtitle&quot;, value: function(t3) {
    var e2 = this.w, i2 = &quot;title&quot; === t3 ? e2.config.title : e2.config.subtitle, a2 = e2.globals.svgWidth / 2, s2 = i2.offsetY, r2 = &quot;middle&quot;;
    if (&quot;left&quot; === i2.align ? (a2 = 10, r2 = &quot;start&quot;) : &quot;right&quot; === i2.align &amp;&amp; (a2 = e2.globals.svgWidth - 10, r2 = &quot;end&quot;), a2 += i2.offsetX, s2 = s2 + parseInt(i2.style.fontSize, 10) + i2.margin / 2, void 0 !== i2.text) {
      var n2 = new Mi(this.ctx).drawText({ x: a2, y: s2, text: i2.text, textAnchor: r2, fontSize: i2.style.fontSize, fontFamily: i2.style.fontFamily, fontWeight: i2.style.fontWeight, foreColor: i2.style.color, opacity: 1 });
      n2.node.setAttribute(&quot;class&quot;, &quot;apexcharts-&quot;.concat(t3, &quot;-text&quot;)), e2.globals.dom.Paper.add(n2);
    }
  } }]), t2;
}();
var ca = function() {
  function t2(e2) {
    i(this, t2), this.w = e2.w, this.dCtx = e2;
  }
  return s(t2, [{ key: &quot;getTitleSubtitleCoords&quot;, value: function(t3) {
    var e2 = this.w, i2 = 0, a2 = 0, s2 = &quot;title&quot; === t3 ? e2.config.title.floating : e2.config.subtitle.floating, r2 = e2.globals.dom.baseEl.querySelector(&quot;.apexcharts-&quot;.concat(t3, &quot;-text&quot;));
    if (null !== r2 &amp;&amp; !s2) {
      var n2 = r2.getBoundingClientRect();
      i2 = n2.width, a2 = e2.globals.axisCharts ? n2.height + 5 : n2.height;
    }
    return { width: i2, height: a2 };
  } }, { key: &quot;getLegendsRect&quot;, value: function() {
    var t3 = this.w, e2 = t3.globals.dom.elLegendWrap;
    t3.config.legend.height || &quot;top&quot; !== t3.config.legend.position &amp;&amp; &quot;bottom&quot; !== t3.config.legend.position || (e2.style.maxHeight = t3.globals.svgHeight / 2 + &quot;px&quot;);
    var i2 = Object.assign({}, v.getBoundingClientRect(e2));
    return null !== e2 &amp;&amp; !t3.config.legend.floating &amp;&amp; t3.config.legend.show ? this.dCtx.lgRect = { x: i2.x, y: i2.y, height: i2.height, width: 0 === i2.height ? 0 : i2.width } : this.dCtx.lgRect = { x: 0, y: 0, height: 0, width: 0 }, &quot;left&quot; !== t3.config.legend.position &amp;&amp; &quot;right&quot; !== t3.config.legend.position || 1.5 * this.dCtx.lgRect.width &gt; t3.globals.svgWidth &amp;&amp; (this.dCtx.lgRect.width = t3.globals.svgWidth / 1.5), this.dCtx.lgRect;
  } }, { key: &quot;getDatalabelsRect&quot;, value: function() {
    var t3 = this, e2 = this.w, i2 = [];
    e2.config.series.forEach(function(s3, r3) {
      s3.data.forEach(function(s4, n3) {
        var o2;
        o2 = e2.globals.series[r3][n3], a2 = e2.config.dataLabels.formatter(o2, { ctx: t3.dCtx.ctx, seriesIndex: r3, dataPointIndex: n3, w: e2 }), i2.push(a2);
      });
    });
    var a2 = v.getLargestStringFromArr(i2), s2 = new Mi(this.dCtx.ctx), r2 = e2.config.dataLabels.style, n2 = s2.getTextRects(a2, parseInt(r2.fontSize), r2.fontFamily);
    return { width: 1.05 * n2.width, height: n2.height };
  } }, { key: &quot;getLargestStringFromMultiArr&quot;, value: function(t3, e2) {
    var i2 = t3;
    if (this.w.globals.isMultiLineX) {
      var a2 = e2.map(function(t4, e3) {
        return Array.isArray(t4) ? t4.length : 1;
      }), s2 = Math.max.apply(Math, f(a2));
      i2 = e2[a2.indexOf(s2)];
    }
    return i2;
  } }]), t2;
}();
var da = function() {
  function t2(e2) {
    i(this, t2), this.w = e2.w, this.dCtx = e2;
  }
  return s(t2, [{ key: &quot;getxAxisLabelsCoords&quot;, value: function() {
    var t3, e2 = this.w, i2 = e2.globals.labels.slice();
    if (e2.config.xaxis.convertedCatToNumeric &amp;&amp; 0 === i2.length &amp;&amp; (i2 = e2.globals.categoryLabels), e2.globals.timescaleLabels.length &gt; 0) {
      var a2 = this.getxAxisTimeScaleLabelsCoords();
      t3 = { width: a2.width, height: a2.height }, e2.globals.rotateXLabels = false;
    } else {
      this.dCtx.lgWidthForSideLegends = &quot;left&quot; !== e2.config.legend.position &amp;&amp; &quot;right&quot; !== e2.config.legend.position || e2.config.legend.floating ? 0 : this.dCtx.lgRect.width;
      var s2 = e2.globals.xLabelFormatter, r2 = v.getLargestStringFromArr(i2), n2 = this.dCtx.dimHelpers.getLargestStringFromMultiArr(r2, i2);
      e2.globals.isBarHorizontal &amp;&amp; (n2 = r2 = e2.globals.yAxisScale[0].result.reduce(function(t4, e3) {
        return t4.length &gt; e3.length ? t4 : e3;
      }, 0));
      var o2 = new Xi(this.dCtx.ctx), l2 = r2;
      r2 = o2.xLabelFormat(s2, r2, l2, { i: void 0, dateFormatter: new zi(this.dCtx.ctx).formatDate, w: e2 }), n2 = o2.xLabelFormat(s2, n2, l2, { i: void 0, dateFormatter: new zi(this.dCtx.ctx).formatDate, w: e2 }), (e2.config.xaxis.convertedCatToNumeric &amp;&amp; void 0 === r2 || &quot;&quot; === String(r2).trim()) &amp;&amp; (n2 = r2 = &quot;1&quot;);
      var h2 = new Mi(this.dCtx.ctx), c2 = h2.getTextRects(r2, e2.config.xaxis.labels.style.fontSize), d2 = c2;
      if (r2 !== n2 &amp;&amp; (d2 = h2.getTextRects(n2, e2.config.xaxis.labels.style.fontSize)), (t3 = { width: c2.width &gt;= d2.width ? c2.width : d2.width, height: c2.height &gt;= d2.height ? c2.height : d2.height }).width * i2.length &gt; e2.globals.svgWidth - this.dCtx.lgWidthForSideLegends - this.dCtx.yAxisWidth - this.dCtx.gridPad.left - this.dCtx.gridPad.right &amp;&amp; 0 !== e2.config.xaxis.labels.rotate || e2.config.xaxis.labels.rotateAlways) {
        if (!e2.globals.isBarHorizontal) {
          e2.globals.rotateXLabels = true;
          var u2 = function(t4) {
            return h2.getTextRects(t4, e2.config.xaxis.labels.style.fontSize, e2.config.xaxis.labels.style.fontFamily, &quot;rotate(&quot;.concat(e2.config.xaxis.labels.rotate, &quot; 0 0)&quot;), false);
          };
          c2 = u2(r2), r2 !== n2 &amp;&amp; (d2 = u2(n2)), t3.height = (c2.height &gt; d2.height ? c2.height : d2.height) / 1.5, t3.width = c2.width &gt; d2.width ? c2.width : d2.width;
        }
      } else e2.globals.rotateXLabels = false;
    }
    return e2.config.xaxis.labels.show || (t3 = { width: 0, height: 0 }), { width: t3.width, height: t3.height };
  } }, { key: &quot;getxAxisGroupLabelsCoords&quot;, value: function() {
    var t3, e2 = this.w;
    if (!e2.globals.hasXaxisGroups) return { width: 0, height: 0 };
    var i2, a2 = (null === (t3 = e2.config.xaxis.group.style) || void 0 === t3 ? void 0 : t3.fontSize) || e2.config.xaxis.labels.style.fontSize, s2 = e2.globals.groups.map(function(t4) {
      return t4.title;
    }), r2 = v.getLargestStringFromArr(s2), n2 = this.dCtx.dimHelpers.getLargestStringFromMultiArr(r2, s2), o2 = new Mi(this.dCtx.ctx), l2 = o2.getTextRects(r2, a2), h2 = l2;
    return r2 !== n2 &amp;&amp; (h2 = o2.getTextRects(n2, a2)), i2 = { width: l2.width &gt;= h2.width ? l2.width : h2.width, height: l2.height &gt;= h2.height ? l2.height : h2.height }, e2.config.xaxis.labels.show || (i2 = { width: 0, height: 0 }), { width: i2.width, height: i2.height };
  } }, { key: &quot;getxAxisTitleCoords&quot;, value: function() {
    var t3 = this.w, e2 = 0, i2 = 0;
    if (void 0 !== t3.config.xaxis.title.text) {
      var a2 = new Mi(this.dCtx.ctx).getTextRects(t3.config.xaxis.title.text, t3.config.xaxis.title.style.fontSize);
      e2 = a2.width, i2 = a2.height;
    }
    return { width: e2, height: i2 };
  } }, { key: &quot;getxAxisTimeScaleLabelsCoords&quot;, value: function() {
    var t3, e2 = this.w;
    this.dCtx.timescaleLabels = e2.globals.timescaleLabels.slice();
    var i2 = this.dCtx.timescaleLabels.map(function(t4) {
      return t4.value;
    }), a2 = i2.reduce(function(t4, e3) {
      return void 0 === t4 ? (console.error(&quot;You have possibly supplied invalid Date format. Please supply a valid JavaScript Date&quot;), 0) : t4.length &gt; e3.length ? t4 : e3;
    }, 0);
    return 1.05 * (t3 = new Mi(this.dCtx.ctx).getTextRects(a2, e2.config.xaxis.labels.style.fontSize)).width * i2.length &gt; e2.globals.gridWidth &amp;&amp; 0 !== e2.config.xaxis.labels.rotate &amp;&amp; (e2.globals.overlappingXLabels = true), t3;
  } }, { key: &quot;additionalPaddingXLabels&quot;, value: function(t3) {
    var e2 = this, i2 = this.w, a2 = i2.globals, s2 = i2.config, r2 = s2.xaxis.type, n2 = t3.width;
    a2.skipLastTimelinelabel = false, a2.skipFirstTimelinelabel = false;
    var o2 = i2.config.yaxis[0].opposite &amp;&amp; i2.globals.isBarHorizontal, l2 = function(t4, o3) {
      s2.yaxis.length &gt; 1 &amp;&amp; function(t5) {
        return -1 !== a2.collapsedSeriesIndices.indexOf(t5);
      }(o3) || function(t5) {
        if (e2.dCtx.timescaleLabels &amp;&amp; e2.dCtx.timescaleLabels.length) {
          var o4 = e2.dCtx.timescaleLabels[0], l3 = e2.dCtx.timescaleLabels[e2.dCtx.timescaleLabels.length - 1].position + n2 / 1.75 - e2.dCtx.yAxisWidthRight, h2 = o4.position - n2 / 1.75 + e2.dCtx.yAxisWidthLeft, c2 = &quot;right&quot; === i2.config.legend.position &amp;&amp; e2.dCtx.lgRect.width &gt; 0 ? e2.dCtx.lgRect.width : 0;
          l3 &gt; a2.svgWidth - a2.translateX - c2 &amp;&amp; (a2.skipLastTimelinelabel = true), h2 &lt; -(t5.show &amp;&amp; !t5.floating || &quot;bar&quot; !== s2.chart.type &amp;&amp; &quot;candlestick&quot; !== s2.chart.type &amp;&amp; &quot;rangeBar&quot; !== s2.chart.type &amp;&amp; &quot;boxPlot&quot; !== s2.chart.type ? 10 : n2 / 1.75) &amp;&amp; (a2.skipFirstTimelinelabel = true);
        } else &quot;datetime&quot; === r2 ? e2.dCtx.gridPad.right &lt; n2 &amp;&amp; !a2.rotateXLabels &amp;&amp; (a2.skipLastTimelinelabel = true) : &quot;datetime&quot; !== r2 &amp;&amp; e2.dCtx.gridPad.right &lt; n2 / 2 - e2.dCtx.yAxisWidthRight &amp;&amp; !a2.rotateXLabels &amp;&amp; !i2.config.xaxis.labels.trim &amp;&amp; (e2.dCtx.xPadRight = n2 / 2 + 1);
      }(t4);
    };
    s2.yaxis.forEach(function(t4, i3) {
      o2 ? (e2.dCtx.gridPad.left &lt; n2 &amp;&amp; (e2.dCtx.xPadLeft = n2 / 2 + 1), e2.dCtx.xPadRight = n2 / 2 + 1) : l2(t4, i3);
    });
  } }]), t2;
}();
var ua = function() {
  function t2(e2) {
    i(this, t2), this.w = e2.w, this.dCtx = e2;
  }
  return s(t2, [{ key: &quot;getyAxisLabelsCoords&quot;, value: function() {
    var t3 = this, e2 = this.w, i2 = [], a2 = 10, s2 = new Ri(this.dCtx.ctx);
    return e2.config.yaxis.map(function(r2, n2) {
      var o2 = { seriesIndex: n2, dataPointIndex: -1, w: e2 }, l2 = e2.globals.yAxisScale[n2], h2 = 0;
      if (!s2.isYAxisHidden(n2) &amp;&amp; r2.labels.show &amp;&amp; void 0 !== r2.labels.minWidth &amp;&amp; (h2 = r2.labels.minWidth), !s2.isYAxisHidden(n2) &amp;&amp; r2.labels.show &amp;&amp; l2.result.length) {
        var c2 = e2.globals.yLabelFormatters[n2], d2 = l2.niceMin === Number.MIN_VALUE ? 0 : l2.niceMin, u2 = l2.result.reduce(function(t4, e3) {
          var i3, a3;
          return (null === (i3 = String(c2(t4, o2))) || void 0 === i3 ? void 0 : i3.length) &gt; (null === (a3 = String(c2(e3, o2))) || void 0 === a3 ? void 0 : a3.length) ? t4 : e3;
        }, d2), g2 = u2 = c2(u2, o2);
        if (void 0 !== u2 &amp;&amp; 0 !== u2.length || (u2 = l2.niceMax), e2.globals.isBarHorizontal) {
          a2 = 0;
          var p2 = e2.globals.labels.slice();
          u2 = v.getLargestStringFromArr(p2), u2 = c2(u2, { seriesIndex: n2, dataPointIndex: -1, w: e2 }), g2 = t3.dCtx.dimHelpers.getLargestStringFromMultiArr(u2, p2);
        }
        var f2 = new Mi(t3.dCtx.ctx), x2 = &quot;rotate(&quot;.concat(r2.labels.rotate, &quot; 0 0)&quot;), b2 = f2.getTextRects(u2, r2.labels.style.fontSize, r2.labels.style.fontFamily, x2, false), m2 = b2;
        u2 !== g2 &amp;&amp; (m2 = f2.getTextRects(g2, r2.labels.style.fontSize, r2.labels.style.fontFamily, x2, false)), i2.push({ width: (h2 &gt; m2.width || h2 &gt; b2.width ? h2 : m2.width &gt; b2.width ? m2.width : b2.width) + a2, height: m2.height &gt; b2.height ? m2.height : b2.height });
      } else i2.push({ width: 0, height: 0 });
    }), i2;
  } }, { key: &quot;getyAxisTitleCoords&quot;, value: function() {
    var t3 = this, e2 = this.w, i2 = [];
    return e2.config.yaxis.map(function(e3, a2) {
      if (e3.show &amp;&amp; void 0 !== e3.title.text) {
        var s2 = new Mi(t3.dCtx.ctx), r2 = &quot;rotate(&quot;.concat(e3.title.rotate, &quot; 0 0)&quot;), n2 = s2.getTextRects(e3.title.text, e3.title.style.fontSize, e3.title.style.fontFamily, r2, false);
        i2.push({ width: n2.width, height: n2.height });
      } else i2.push({ width: 0, height: 0 });
    }), i2;
  } }, { key: &quot;getTotalYAxisWidth&quot;, value: function() {
    var t3 = this.w, e2 = 0, i2 = 0, a2 = 0, s2 = t3.globals.yAxisScale.length &gt; 1 ? 10 : 0, r2 = new Ri(this.dCtx.ctx), n2 = function(n3, o2) {
      var l2 = t3.config.yaxis[o2].floating, h2 = 0;
      n3.width &gt; 0 &amp;&amp; !l2 ? (h2 = n3.width + s2, function(e3) {
        return t3.globals.ignoreYAxisIndexes.indexOf(e3) &gt; -1;
      }(o2) &amp;&amp; (h2 = h2 - n3.width - s2)) : h2 = l2 || r2.isYAxisHidden(o2) ? 0 : 5, t3.config.yaxis[o2].opposite ? a2 += h2 : i2 += h2, e2 += h2;
    };
    return t3.globals.yLabelsCoords.map(function(t4, e3) {
      n2(t4, e3);
    }), t3.globals.yTitleCoords.map(function(t4, e3) {
      n2(t4, e3);
    }), t3.globals.isBarHorizontal &amp;&amp; !t3.config.yaxis[0].floating &amp;&amp; (e2 = t3.globals.yLabelsCoords[0].width + t3.globals.yTitleCoords[0].width + 15), this.dCtx.yAxisWidthLeft = i2, this.dCtx.yAxisWidthRight = a2, e2;
  } }]), t2;
}();
var ga = function() {
  function t2(e2) {
    i(this, t2), this.w = e2.w, this.dCtx = e2;
  }
  return s(t2, [{ key: &quot;gridPadForColumnsInNumericAxis&quot;, value: function(t3) {
    var e2 = this.w, i2 = e2.config, a2 = e2.globals;
    if (a2.noData || a2.collapsedSeries.length + a2.ancillaryCollapsedSeries.length === i2.series.length) return 0;
    var s2 = function(t4) {
      return [&quot;bar&quot;, &quot;rangeBar&quot;, &quot;candlestick&quot;, &quot;boxPlot&quot;].includes(t4);
    }, r2 = i2.chart.type, n2 = 0, o2 = s2(r2) ? i2.series.length : 1;
    a2.comboBarCount &gt; 0 &amp;&amp; (o2 = a2.comboBarCount), a2.collapsedSeries.forEach(function(t4) {
      s2(t4.type) &amp;&amp; (o2 -= 1);
    }), i2.chart.stacked &amp;&amp; (o2 = 1);
    var l2 = s2(r2) || a2.comboBarCount &gt; 0, h2 = Math.abs(a2.initialMaxX - a2.initialMinX);
    if (l2 &amp;&amp; a2.isXNumeric &amp;&amp; !a2.isBarHorizontal &amp;&amp; o2 &gt; 0 &amp;&amp; 0 !== h2) {
      h2 &lt;= 3 &amp;&amp; (h2 = a2.dataPoints);
      var c2 = h2 / t3, d2 = a2.minXDiff &amp;&amp; a2.minXDiff / c2 &gt; 0 ? a2.minXDiff / c2 : 0;
      d2 &gt; t3 / 2 &amp;&amp; (d2 /= 2), (n2 = d2 * parseInt(i2.plotOptions.bar.columnWidth, 10) / 100) &lt; 1 &amp;&amp; (n2 = 1), a2.barPadForNumericAxis = n2;
    }
    return n2;
  } }, { key: &quot;gridPadFortitleSubtitle&quot;, value: function() {
    var t3 = this, e2 = this.w, i2 = e2.globals, a2 = this.dCtx.isSparkline || !i2.axisCharts ? 0 : 10;
    [&quot;title&quot;, &quot;subtitle&quot;].forEach(function(s3) {
      void 0 !== e2.config[s3].text ? a2 += e2.config[s3].margin : a2 += t3.dCtx.isSparkline || !i2.axisCharts ? 0 : 5;
    }), !e2.config.legend.show || &quot;bottom&quot; !== e2.config.legend.position || e2.config.legend.floating || i2.axisCharts || (a2 += 10);
    var s2 = this.dCtx.dimHelpers.getTitleSubtitleCoords(&quot;title&quot;), r2 = this.dCtx.dimHelpers.getTitleSubtitleCoords(&quot;subtitle&quot;);
    i2.gridHeight -= s2.height + r2.height + a2, i2.translateY += s2.height + r2.height + a2;
  } }, { key: &quot;setGridXPosForDualYAxis&quot;, value: function(t3, e2) {
    var i2 = this.w, a2 = new Ri(this.dCtx.ctx);
    i2.config.yaxis.forEach(function(s2, r2) {
      -1 !== i2.globals.ignoreYAxisIndexes.indexOf(r2) || s2.floating || a2.isYAxisHidden(r2) || (s2.opposite &amp;&amp; (i2.globals.translateX -= e2[r2].width + t3[r2].width + parseInt(s2.labels.style.fontSize, 10) / 1.2 + 12), i2.globals.translateX &lt; 2 &amp;&amp; (i2.globals.translateX = 2));
    });
  } }]), t2;
}();
var pa = function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w, this.lgRect = {}, this.yAxisWidth = 0, this.yAxisWidthLeft = 0, this.yAxisWidthRight = 0, this.xAxisHeight = 0, this.isSparkline = this.w.config.chart.sparkline.enabled, this.dimHelpers = new ca(this), this.dimYAxis = new ua(this), this.dimXAxis = new da(this), this.dimGrid = new ga(this), this.lgWidthForSideLegends = 0, this.gridPad = this.w.config.grid.padding, this.xPadRight = 0, this.xPadLeft = 0;
  }
  return s(t2, [{ key: &quot;plotCoords&quot;, value: function() {
    var t3 = this, e2 = this.w, i2 = e2.globals;
    this.lgRect = this.dimHelpers.getLegendsRect(), this.datalabelsCoords = { width: 0, height: 0 };
    var a2 = Array.isArray(e2.config.stroke.width) ? Math.max.apply(Math, f(e2.config.stroke.width)) : e2.config.stroke.width;
    this.isSparkline &amp;&amp; ((e2.config.markers.discrete.length &gt; 0 || e2.config.markers.size &gt; 0) &amp;&amp; Object.entries(this.gridPad).forEach(function(e3) {
      var i3 = p(e3, 2), a3 = i3[0], s3 = i3[1];
      t3.gridPad[a3] = Math.max(s3, t3.w.globals.markers.largestSize / 1.5);
    }), this.gridPad.top = Math.max(a2 / 2, this.gridPad.top), this.gridPad.bottom = Math.max(a2 / 2, this.gridPad.bottom)), i2.axisCharts ? this.setDimensionsForAxisCharts() : this.setDimensionsForNonAxisCharts(), this.dimGrid.gridPadFortitleSubtitle(), i2.gridHeight = i2.gridHeight - this.gridPad.top - this.gridPad.bottom, i2.gridWidth = i2.gridWidth - this.gridPad.left - this.gridPad.right - this.xPadRight - this.xPadLeft;
    var s2 = this.dimGrid.gridPadForColumnsInNumericAxis(i2.gridWidth);
    i2.gridWidth = i2.gridWidth - 2 * s2, i2.translateX = i2.translateX + this.gridPad.left + this.xPadLeft + (s2 &gt; 0 ? s2 : 0), i2.translateY = i2.translateY + this.gridPad.top;
  } }, { key: &quot;setDimensionsForAxisCharts&quot;, value: function() {
    var t3 = this, e2 = this.w, i2 = e2.globals, a2 = this.dimYAxis.getyAxisLabelsCoords(), s2 = this.dimYAxis.getyAxisTitleCoords();
    i2.isSlopeChart &amp;&amp; (this.datalabelsCoords = this.dimHelpers.getDatalabelsRect()), e2.globals.yLabelsCoords = [], e2.globals.yTitleCoords = [], e2.config.yaxis.map(function(t4, i3) {
      e2.globals.yLabelsCoords.push({ width: a2[i3].width, index: i3 }), e2.globals.yTitleCoords.push({ width: s2[i3].width, index: i3 });
    }), this.yAxisWidth = this.dimYAxis.getTotalYAxisWidth();
    var r2 = this.dimXAxis.getxAxisLabelsCoords(), n2 = this.dimXAxis.getxAxisGroupLabelsCoords(), o2 = this.dimXAxis.getxAxisTitleCoords();
    this.conditionalChecksForAxisCoords(r2, o2, n2), i2.translateXAxisY = e2.globals.rotateXLabels ? this.xAxisHeight / 8 : -4, i2.translateXAxisX = e2.globals.rotateXLabels &amp;&amp; e2.globals.isXNumeric &amp;&amp; e2.config.xaxis.labels.rotate &lt;= -45 ? -this.xAxisWidth / 4 : 0, e2.globals.isBarHorizontal &amp;&amp; (i2.rotateXLabels = false, i2.translateXAxisY = parseInt(e2.config.xaxis.labels.style.fontSize, 10) / 1.5 * -1), i2.translateXAxisY = i2.translateXAxisY + e2.config.xaxis.labels.offsetY, i2.translateXAxisX = i2.translateXAxisX + e2.config.xaxis.labels.offsetX;
    var l2 = this.yAxisWidth, h2 = this.xAxisHeight;
    i2.xAxisLabelsHeight = this.xAxisHeight - o2.height, i2.xAxisGroupLabelsHeight = i2.xAxisLabelsHeight - r2.height, i2.xAxisLabelsWidth = this.xAxisWidth, i2.xAxisHeight = this.xAxisHeight;
    var c2 = 10;
    (&quot;radar&quot; === e2.config.chart.type || this.isSparkline) &amp;&amp; (l2 = 0, h2 = 0), this.isSparkline &amp;&amp; (this.lgRect = { height: 0, width: 0 }), (this.isSparkline || &quot;treemap&quot; === e2.config.chart.type) &amp;&amp; (l2 = 0, h2 = 0, c2 = 0), this.isSparkline || &quot;treemap&quot; === e2.config.chart.type || this.dimXAxis.additionalPaddingXLabels(r2);
    var d2 = function() {
      i2.translateX = l2 + t3.datalabelsCoords.width, i2.gridHeight = i2.svgHeight - t3.lgRect.height - h2 - (t3.isSparkline || &quot;treemap&quot; === e2.config.chart.type ? 0 : e2.globals.rotateXLabels ? 10 : 15), i2.gridWidth = i2.svgWidth - l2 - 2 * t3.datalabelsCoords.width;
    };
    switch (&quot;top&quot; === e2.config.xaxis.position &amp;&amp; (c2 = i2.xAxisHeight - e2.config.xaxis.axisTicks.height - 5), e2.config.legend.position) {
      case &quot;bottom&quot;:
        i2.translateY = c2, d2();
        break;
      case &quot;top&quot;:
        i2.translateY = this.lgRect.height + c2, d2();
        break;
      case &quot;left&quot;:
        i2.translateY = c2, i2.translateX = this.lgRect.width + l2 + this.datalabelsCoords.width, i2.gridHeight = i2.svgHeight - h2 - 12, i2.gridWidth = i2.svgWidth - this.lgRect.width - l2 - 2 * this.datalabelsCoords.width;
        break;
      case &quot;right&quot;:
        i2.translateY = c2, i2.translateX = l2 + this.datalabelsCoords.width, i2.gridHeight = i2.svgHeight - h2 - 12, i2.gridWidth = i2.svgWidth - this.lgRect.width - l2 - 2 * this.datalabelsCoords.width - 5;
        break;
      default:
        throw new Error(&quot;Legend position not supported&quot;);
    }
    this.dimGrid.setGridXPosForDualYAxis(s2, a2), new ia(this.ctx).setYAxisXPosition(a2, s2);
  } }, { key: &quot;setDimensionsForNonAxisCharts&quot;, value: function() {
    var t3 = this.w, e2 = t3.globals, i2 = t3.config, a2 = 0;
    t3.config.legend.show &amp;&amp; !t3.config.legend.floating &amp;&amp; (a2 = 20);
    var s2 = &quot;pie&quot; === i2.chart.type || &quot;polarArea&quot; === i2.chart.type || &quot;donut&quot; === i2.chart.type ? &quot;pie&quot; : &quot;radialBar&quot;, r2 = i2.plotOptions[s2].offsetY, n2 = i2.plotOptions[s2].offsetX;
    if (!i2.legend.show || i2.legend.floating) {
      e2.gridHeight = e2.svgHeight;
      var o2 = e2.dom.elWrap.getBoundingClientRect().width;
      return e2.gridWidth = Math.min(o2, e2.gridHeight), e2.translateY = r2, void (e2.translateX = n2 + (e2.svgWidth - e2.gridWidth) / 2);
    }
    switch (i2.legend.position) {
      case &quot;bottom&quot;:
        e2.gridHeight = e2.svgHeight - this.lgRect.height, e2.gridWidth = e2.svgWidth, e2.translateY = r2 - 10, e2.translateX = n2 + (e2.svgWidth - e2.gridWidth) / 2;
        break;
      case &quot;top&quot;:
        e2.gridHeight = e2.svgHeight - this.lgRect.height, e2.gridWidth = e2.svgWidth, e2.translateY = this.lgRect.height + r2 + 10, e2.translateX = n2 + (e2.svgWidth - e2.gridWidth) / 2;
        break;
      case &quot;left&quot;:
        e2.gridWidth = e2.svgWidth - this.lgRect.width - a2, e2.gridHeight = &quot;auto&quot; !== i2.chart.height ? e2.svgHeight : e2.gridWidth, e2.translateY = r2, e2.translateX = n2 + this.lgRect.width + a2;
        break;
      case &quot;right&quot;:
        e2.gridWidth = e2.svgWidth - this.lgRect.width - a2 - 5, e2.gridHeight = &quot;auto&quot; !== i2.chart.height ? e2.svgHeight : e2.gridWidth, e2.translateY = r2, e2.translateX = n2 + 10;
        break;
      default:
        throw new Error(&quot;Legend position not supported&quot;);
    }
  } }, { key: &quot;conditionalChecksForAxisCoords&quot;, value: function(t3, e2, i2) {
    var a2 = this.w, s2 = a2.globals.hasXaxisGroups ? 2 : 1, r2 = i2.height + t3.height + e2.height, n2 = a2.globals.isMultiLineX ? 1.2 : a2.globals.LINE_HEIGHT_RATIO, o2 = a2.globals.rotateXLabels ? 22 : 10, l2 = a2.globals.rotateXLabels &amp;&amp; &quot;bottom&quot; === a2.config.legend.position ? 10 : 0;
    this.xAxisHeight = r2 * n2 + s2 * o2 + l2, this.xAxisWidth = t3.width, this.xAxisHeight - e2.height &gt; a2.config.xaxis.labels.maxHeight &amp;&amp; (this.xAxisHeight = a2.config.xaxis.labels.maxHeight), a2.config.xaxis.labels.minHeight &amp;&amp; this.xAxisHeight &lt; a2.config.xaxis.labels.minHeight &amp;&amp; (this.xAxisHeight = a2.config.xaxis.labels.minHeight), a2.config.xaxis.floating &amp;&amp; (this.xAxisHeight = 0);
    var h2 = 0, c2 = 0;
    a2.config.yaxis.forEach(function(t4) {
      h2 += t4.labels.minWidth, c2 += t4.labels.maxWidth;
    }), this.yAxisWidth &lt; h2 &amp;&amp; (this.yAxisWidth = h2), this.yAxisWidth &gt; c2 &amp;&amp; (this.yAxisWidth = c2);
  } }]), t2;
}();
var fa = function() {
  function t2(e2) {
    i(this, t2), this.w = e2.w, this.lgCtx = e2;
  }
  return s(t2, [{ key: &quot;getLegendStyles&quot;, value: function() {
    var t3, e2, i2, a2 = document.createElement(&quot;style&quot;);
    a2.setAttribute(&quot;type&quot;, &quot;text/css&quot;);
    var s2 = (null === (t3 = this.lgCtx.ctx) || void 0 === t3 || null === (e2 = t3.opts) || void 0 === e2 || null === (i2 = e2.chart) || void 0 === i2 ? void 0 : i2.nonce) || this.w.config.chart.nonce;
    s2 &amp;&amp; a2.setAttribute(&quot;nonce&quot;, s2);
    var r2 = document.createTextNode(&quot;\n      .apexcharts-flip-y {\n        transform: scaleY(-1) translateY(-100%);\n        transform-origin: top;\n        transform-box: fill-box;\n      }\n      .apexcharts-flip-x {\n        transform: scaleX(-1);\n        transform-origin: center;\n        transform-box: fill-box;\n      }\n      .apexcharts-legend {\n        display: flex;\n        overflow: auto;\n        padding: 0 10px;\n      }\n      .apexcharts-legend.apexcharts-legend-group-horizontal {\n        flex-direction: column;\n      }\n      .apexcharts-legend-group {\n        display: flex;\n      }\n      .apexcharts-legend-group-vertical {\n        flex-direction: column-reverse;\n      }\n      .apexcharts-legend.apx-legend-position-bottom, .apexcharts-legend.apx-legend-position-top {\n        flex-wrap: wrap\n      }\n      .apexcharts-legend.apx-legend-position-right, .apexcharts-legend.apx-legend-position-left {\n        flex-direction: column;\n        bottom: 0;\n      }\n      .apexcharts-legend.apx-legend-position-bottom.apexcharts-align-left, .apexcharts-legend.apx-legend-position-top.apexcharts-align-left, .apexcharts-legend.apx-legend-position-right, .apexcharts-legend.apx-legend-position-left {\n        justify-content: flex-start;\n        align-items: flex-start;\n      }\n      .apexcharts-legend.apx-legend-position-bottom.apexcharts-align-center, .apexcharts-legend.apx-legend-position-top.apexcharts-align-center {\n        justify-content: center;\n        align-items: center;\n      }\n      .apexcharts-legend.apx-legend-position-bottom.apexcharts-align-right, .apexcharts-legend.apx-legend-position-top.apexcharts-align-right {\n        justify-content: flex-end;\n        align-items: flex-end;\n      }\n      .apexcharts-legend-series {\n        cursor: pointer;\n        line-height: normal;\n        display: flex;\n        align-items: center;\n      }\n      .apexcharts-legend-text {\n        position: relative;\n        font-size: 14px;\n      }\n      .apexcharts-legend-text *, .apexcharts-legend-marker * {\n        pointer-events: none;\n      }\n      .apexcharts-legend-marker {\n        position: relative;\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        cursor: pointer;\n        margin-right: 1px;\n      }\n\n      .apexcharts-legend-series.apexcharts-no-click {\n        cursor: auto;\n      }\n      .apexcharts-legend .apexcharts-hidden-zero-series, .apexcharts-legend .apexcharts-hidden-null-series {\n        display: none !important;\n      }\n      .apexcharts-inactive-legend {\n        opacity: 0.45;\n      }\n\n    &quot;);
    return a2.appendChild(r2), a2;
  } }, { key: &quot;getLegendDimensions&quot;, value: function() {
    var t3 = this.w.globals.dom.baseEl.querySelector(&quot;.apexcharts-legend&quot;).getBoundingClientRect(), e2 = t3.width;
    return { clwh: t3.height, clww: e2 };
  } }, { key: &quot;appendToForeignObject&quot;, value: function() {
    this.w.globals.dom.elLegendForeign.appendChild(this.getLegendStyles());
  } }, { key: &quot;toggleDataSeries&quot;, value: function(t3, e2) {
    var i2 = this, a2 = this.w;
    if (a2.globals.axisCharts || &quot;radialBar&quot; === a2.config.chart.type) {
      a2.globals.resized = true;
      var s2 = null, r2 = null;
      if (a2.globals.risingSeries = [], a2.globals.axisCharts ? (s2 = a2.globals.dom.baseEl.querySelector(&quot;.apexcharts-series[data\\:realIndex=&#x27;&quot;.concat(t3, &quot;&#x27;]&quot;)), r2 = parseInt(s2.getAttribute(&quot;data:realIndex&quot;), 10)) : (s2 = a2.globals.dom.baseEl.querySelector(&quot;.apexcharts-series[rel=&#x27;&quot;.concat(t3 + 1, &quot;&#x27;]&quot;)), r2 = parseInt(s2.getAttribute(&quot;rel&quot;), 10) - 1), e2) [{ cs: a2.globals.collapsedSeries, csi: a2.globals.collapsedSeriesIndices }, { cs: a2.globals.ancillaryCollapsedSeries, csi: a2.globals.ancillaryCollapsedSeriesIndices }].forEach(function(t4) {
        i2.riseCollapsedSeries(t4.cs, t4.csi, r2);
      });
      else this.hideSeries({ seriesEl: s2, realIndex: r2 });
    } else {
      var n2 = a2.globals.dom.Paper.findOne(&quot; .apexcharts-series[rel=&#x27;&quot;.concat(t3 + 1, &quot;&#x27;] path&quot;)), o2 = a2.config.chart.type;
      if (&quot;pie&quot; === o2 || &quot;polarArea&quot; === o2 || &quot;donut&quot; === o2) {
        var l2 = a2.config.plotOptions.pie.donut.labels;
        new Mi(this.lgCtx.ctx).pathMouseDown(n2, null), this.lgCtx.ctx.pie.printDataLabelsInner(n2.node, l2);
      }
      n2.fire(&quot;click&quot;);
    }
  } }, { key: &quot;getSeriesAfterCollapsing&quot;, value: function(t3) {
    var e2 = t3.realIndex, i2 = this.w, a2 = i2.globals, s2 = v.clone(i2.config.series);
    if (a2.axisCharts) {
      var r2 = i2.config.yaxis[a2.seriesYAxisReverseMap[e2]], n2 = { index: e2, data: s2[e2].data.slice(), type: s2[e2].type || i2.config.chart.type };
      if (r2 &amp;&amp; r2.show &amp;&amp; r2.showAlways) a2.ancillaryCollapsedSeriesIndices.indexOf(e2) &lt; 0 &amp;&amp; (a2.ancillaryCollapsedSeries.push(n2), a2.ancillaryCollapsedSeriesIndices.push(e2));
      else if (a2.collapsedSeriesIndices.indexOf(e2) &lt; 0) {
        a2.collapsedSeries.push(n2), a2.collapsedSeriesIndices.push(e2);
        var o2 = a2.risingSeries.indexOf(e2);
        a2.risingSeries.splice(o2, 1);
      }
    } else a2.collapsedSeries.push({ index: e2, data: s2[e2] }), a2.collapsedSeriesIndices.push(e2);
    return a2.allSeriesCollapsed = a2.collapsedSeries.length + a2.ancillaryCollapsedSeries.length === i2.config.series.length, this._getSeriesBasedOnCollapsedState(s2);
  } }, { key: &quot;hideSeries&quot;, value: function(t3) {
    for (var e2 = t3.seriesEl, i2 = t3.realIndex, a2 = this.w, s2 = this.getSeriesAfterCollapsing({ realIndex: i2 }), r2 = e2.childNodes, n2 = 0; n2 &lt; r2.length; n2++) r2[n2].classList.contains(&quot;apexcharts-series-markers-wrap&quot;) &amp;&amp; (r2[n2].classList.contains(&quot;apexcharts-hide&quot;) ? r2[n2].classList.remove(&quot;apexcharts-hide&quot;) : r2[n2].classList.add(&quot;apexcharts-hide&quot;));
    this.lgCtx.ctx.updateHelpers._updateSeries(s2, a2.config.chart.animations.dynamicAnimation.enabled);
  } }, { key: &quot;riseCollapsedSeries&quot;, value: function(t3, e2, i2) {
    var a2 = this.w, s2 = v.clone(a2.config.series);
    if (t3.length &gt; 0) {
      for (var r2 = 0; r2 &lt; t3.length; r2++) t3[r2].index === i2 &amp;&amp; (a2.globals.axisCharts ? s2[i2].data = t3[r2].data.slice() : s2[i2] = t3[r2].data, &quot;number&quot; != typeof s2[i2] &amp;&amp; (s2[i2].hidden = false), t3.splice(r2, 1), e2.splice(r2, 1), a2.globals.risingSeries.push(i2));
      s2 = this._getSeriesBasedOnCollapsedState(s2), this.lgCtx.ctx.updateHelpers._updateSeries(s2, a2.config.chart.animations.dynamicAnimation.enabled);
    }
  } }, { key: &quot;_getSeriesBasedOnCollapsedState&quot;, value: function(t3) {
    var e2 = this.w, i2 = 0;
    return e2.globals.axisCharts ? t3.forEach(function(a2, s2) {
      e2.globals.collapsedSeriesIndices.indexOf(s2) &lt; 0 &amp;&amp; e2.globals.ancillaryCollapsedSeriesIndices.indexOf(s2) &lt; 0 || (t3[s2].data = [], i2++);
    }) : t3.forEach(function(a2, s2) {
      !e2.globals.collapsedSeriesIndices.indexOf(s2) &lt; 0 &amp;&amp; (t3[s2] = 0, i2++);
    }), e2.globals.allSeriesCollapsed = i2 === t3.length, t3;
  } }]), t2;
}();
var xa = function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w, this.onLegendClick = this.onLegendClick.bind(this), this.onLegendHovered = this.onLegendHovered.bind(this), this.isBarsDistributed = &quot;bar&quot; === this.w.config.chart.type &amp;&amp; this.w.config.plotOptions.bar.distributed &amp;&amp; 1 === this.w.config.series.length, this.legendHelpers = new fa(this);
  }
  return s(t2, [{ key: &quot;init&quot;, value: function() {
    var t3 = this.w, e2 = t3.globals, i2 = t3.config, a2 = i2.legend.showForSingleSeries &amp;&amp; 1 === e2.series.length || this.isBarsDistributed || e2.series.length &gt; 1;
    if (this.legendHelpers.appendToForeignObject(), (a2 || !e2.axisCharts) &amp;&amp; i2.legend.show) {
      for (; e2.dom.elLegendWrap.firstChild; ) e2.dom.elLegendWrap.removeChild(e2.dom.elLegendWrap.firstChild);
      this.drawLegends(), &quot;bottom&quot; === i2.legend.position || &quot;top&quot; === i2.legend.position ? this.legendAlignHorizontal() : &quot;right&quot; !== i2.legend.position &amp;&amp; &quot;left&quot; !== i2.legend.position || this.legendAlignVertical();
    }
  } }, { key: &quot;createLegendMarker&quot;, value: function(t3) {
    var e2 = t3.i, i2 = t3.fillcolor, a2 = this.w, s2 = document.createElement(&quot;span&quot;);
    s2.classList.add(&quot;apexcharts-legend-marker&quot;);
    var r2 = a2.config.legend.markers.shape || a2.config.markers.shape, n2 = r2;
    Array.isArray(r2) &amp;&amp; (n2 = r2[e2]);
    var o2 = Array.isArray(a2.config.legend.markers.size) ? parseFloat(a2.config.legend.markers.size[e2]) : parseFloat(a2.config.legend.markers.size), l2 = Array.isArray(a2.config.legend.markers.offsetX) ? parseFloat(a2.config.legend.markers.offsetX[e2]) : parseFloat(a2.config.legend.markers.offsetX), h2 = Array.isArray(a2.config.legend.markers.offsetY) ? parseFloat(a2.config.legend.markers.offsetY[e2]) : parseFloat(a2.config.legend.markers.offsetY), c2 = Array.isArray(a2.config.legend.markers.strokeWidth) ? parseFloat(a2.config.legend.markers.strokeWidth[e2]) : parseFloat(a2.config.legend.markers.strokeWidth), d2 = s2.style;
    if (d2.height = 2 * (o2 + c2) + &quot;px&quot;, d2.width = 2 * (o2 + c2) + &quot;px&quot;, d2.left = l2 + &quot;px&quot;, d2.top = h2 + &quot;px&quot;, a2.config.legend.markers.customHTML) d2.background = &quot;transparent&quot;, d2.color = i2[e2], Array.isArray(a2.config.legend.markers.customHTML) ? a2.config.legend.markers.customHTML[e2] &amp;&amp; (s2.innerHTML = a2.config.legend.markers.customHTML[e2]()) : s2.innerHTML = a2.config.legend.markers.customHTML();
    else {
      var g2 = new Vi(this.ctx).getMarkerConfig({ cssClass: &quot;apexcharts-legend-marker apexcharts-marker apexcharts-marker-&quot;.concat(n2), seriesIndex: e2, strokeWidth: c2, size: o2 }), p2 = window.SVG().addTo(s2).size(&quot;100%&quot;, &quot;100%&quot;), f2 = new Mi(this.ctx).drawMarker(0, 0, u(u({}, g2), {}, { pointFillColor: Array.isArray(i2) ? i2[e2] : g2.pointFillColor, shape: n2 }));
      a2.globals.dom.Paper.find(&quot;.apexcharts-legend-marker.apexcharts-marker&quot;).forEach(function(t4) {
        t4.node.classList.contains(&quot;apexcharts-marker-triangle&quot;) ? t4.node.style.transform = &quot;translate(50%, 45%)&quot; : t4.node.style.transform = &quot;translate(50%, 50%)&quot;;
      }), p2.add(f2);
    }
    return s2;
  } }, { key: &quot;drawLegends&quot;, value: function() {
    var t3 = this, e2 = this, i2 = this.w, a2 = i2.config.legend.fontFamily, s2 = i2.globals.seriesNames, r2 = i2.config.legend.markers.fillColors ? i2.config.legend.markers.fillColors.slice() : i2.globals.colors.slice();
    if (&quot;heatmap&quot; === i2.config.chart.type) {
      var n2 = i2.config.plotOptions.heatmap.colorScale.ranges;
      s2 = n2.map(function(t4) {
        return t4.name ? t4.name : t4.from + &quot; - &quot; + t4.to;
      }), r2 = n2.map(function(t4) {
        return t4.color;
      });
    } else this.isBarsDistributed &amp;&amp; (s2 = i2.globals.labels.slice());
    i2.config.legend.customLegendItems.length &amp;&amp; (s2 = i2.config.legend.customLegendItems);
    var o2 = i2.globals.legendFormatter, l2 = i2.config.legend.inverseOrder, h2 = [];
    i2.globals.seriesGroups.length &gt; 1 &amp;&amp; i2.config.legend.clusterGroupedSeries &amp;&amp; i2.globals.seriesGroups.forEach(function(t4, e3) {
      h2[e3] = document.createElement(&quot;div&quot;), h2[e3].classList.add(&quot;apexcharts-legend-group&quot;, &quot;apexcharts-legend-group-&quot;.concat(e3)), &quot;horizontal&quot; === i2.config.legend.clusterGroupedSeriesOrientation ? i2.globals.dom.elLegendWrap.classList.add(&quot;apexcharts-legend-group-horizontal&quot;) : h2[e3].classList.add(&quot;apexcharts-legend-group-vertical&quot;);
    });
    for (var c2 = function(e3) {
      var n3, l3 = o2(s2[e3], { seriesIndex: e3, w: i2 }), c3 = false, d3 = false;
      if (i2.globals.collapsedSeries.length &gt; 0) for (var u2 = 0; u2 &lt; i2.globals.collapsedSeries.length; u2++) i2.globals.collapsedSeries[u2].index === e3 &amp;&amp; (c3 = true);
      if (i2.globals.ancillaryCollapsedSeriesIndices.length &gt; 0) for (var g2 = 0; g2 &lt; i2.globals.ancillaryCollapsedSeriesIndices.length; g2++) i2.globals.ancillaryCollapsedSeriesIndices[g2] === e3 &amp;&amp; (d3 = true);
      var p2 = t3.createLegendMarker({ i: e3, fillcolor: r2 });
      Mi.setAttrs(p2, { rel: e3 + 1, &quot;data:collapsed&quot;: c3 || d3 }), (c3 || d3) &amp;&amp; p2.classList.add(&quot;apexcharts-inactive-legend&quot;);
      var f2 = document.createElement(&quot;div&quot;), x2 = document.createElement(&quot;span&quot;);
      x2.classList.add(&quot;apexcharts-legend-text&quot;), x2.innerHTML = Array.isArray(l3) ? l3.join(&quot; &quot;) : l3;
      var b2 = i2.config.legend.labels.useSeriesColors ? i2.globals.colors[e3] : Array.isArray(i2.config.legend.labels.colors) ? null === (n3 = i2.config.legend.labels.colors) || void 0 === n3 ? void 0 : n3[e3] : i2.config.legend.labels.colors;
      b2 || (b2 = i2.config.chart.foreColor), x2.style.color = b2, x2.style.fontSize = parseFloat(i2.config.legend.fontSize) + &quot;px&quot;, x2.style.fontWeight = i2.config.legend.fontWeight, x2.style.fontFamily = a2 || i2.config.chart.fontFamily, Mi.setAttrs(x2, { rel: e3 + 1, i: e3, &quot;data:default-text&quot;: encodeURIComponent(l3), &quot;data:collapsed&quot;: c3 || d3 }), f2.appendChild(p2), f2.appendChild(x2);
      var m2 = new Pi(t3.ctx);
      i2.config.legend.showForZeroSeries || 0 === m2.getSeriesTotalByIndex(e3) &amp;&amp; m2.seriesHaveSameValues(e3) &amp;&amp; !m2.isSeriesNull(e3) &amp;&amp; -1 === i2.globals.collapsedSeriesIndices.indexOf(e3) &amp;&amp; -1 === i2.globals.ancillaryCollapsedSeriesIndices.indexOf(e3) &amp;&amp; f2.classList.add(&quot;apexcharts-hidden-zero-series&quot;);
      i2.config.legend.showForNullSeries || m2.isSeriesNull(e3) &amp;&amp; -1 === i2.globals.collapsedSeriesIndices.indexOf(e3) &amp;&amp; -1 === i2.globals.ancillaryCollapsedSeriesIndices.indexOf(e3) &amp;&amp; f2.classList.add(&quot;apexcharts-hidden-null-series&quot;), h2.length ? i2.globals.seriesGroups.forEach(function(t4, a3) {
        var s3;
        t4.includes(null === (s3 = i2.config.series[e3]) || void 0 === s3 ? void 0 : s3.name) &amp;&amp; (i2.globals.dom.elLegendWrap.appendChild(h2[a3]), h2[a3].appendChild(f2));
      }) : i2.globals.dom.elLegendWrap.appendChild(f2), i2.globals.dom.elLegendWrap.classList.add(&quot;apexcharts-align-&quot;.concat(i2.config.legend.horizontalAlign)), i2.globals.dom.elLegendWrap.classList.add(&quot;apx-legend-position-&quot; + i2.config.legend.position), f2.classList.add(&quot;apexcharts-legend-series&quot;), f2.style.margin = &quot;&quot;.concat(i2.config.legend.itemMargin.vertical, &quot;px &quot;).concat(i2.config.legend.itemMargin.horizontal, &quot;px&quot;), i2.globals.dom.elLegendWrap.style.width = i2.config.legend.width ? i2.config.legend.width + &quot;px&quot; : &quot;&quot;, i2.globals.dom.elLegendWrap.style.height = i2.config.legend.height ? i2.config.legend.height + &quot;px&quot; : &quot;&quot;, Mi.setAttrs(f2, { rel: e3 + 1, seriesName: v.escapeString(s2[e3]), &quot;data:collapsed&quot;: c3 || d3 }), (c3 || d3) &amp;&amp; f2.classList.add(&quot;apexcharts-inactive-legend&quot;), i2.config.legend.onItemClick.toggleDataSeries || f2.classList.add(&quot;apexcharts-no-click&quot;);
    }, d2 = l2 ? s2.length - 1 : 0; l2 ? d2 &gt;= 0 : d2 &lt;= s2.length - 1; l2 ? d2-- : d2++) c2(d2);
    i2.globals.dom.elWrap.addEventListener(&quot;click&quot;, e2.onLegendClick, true), i2.config.legend.onItemHover.highlightDataSeries &amp;&amp; 0 === i2.config.legend.customLegendItems.length &amp;&amp; (i2.globals.dom.elWrap.addEventListener(&quot;mousemove&quot;, e2.onLegendHovered, true), i2.globals.dom.elWrap.addEventListener(&quot;mouseout&quot;, e2.onLegendHovered, true));
  } }, { key: &quot;setLegendWrapXY&quot;, value: function(t3, e2) {
    var i2 = this.w, a2 = i2.globals.dom.elLegendWrap, s2 = a2.clientHeight, r2 = 0, n2 = 0;
    if (&quot;bottom&quot; === i2.config.legend.position) n2 = i2.globals.svgHeight - Math.min(s2, i2.globals.svgHeight / 2) - 5;
    else if (&quot;top&quot; === i2.config.legend.position) {
      var o2 = new pa(this.ctx), l2 = o2.dimHelpers.getTitleSubtitleCoords(&quot;title&quot;).height, h2 = o2.dimHelpers.getTitleSubtitleCoords(&quot;subtitle&quot;).height;
      n2 = (l2 &gt; 0 ? l2 - 10 : 0) + (h2 &gt; 0 ? h2 - 10 : 0);
    }
    a2.style.position = &quot;absolute&quot;, r2 = r2 + t3 + i2.config.legend.offsetX, n2 = n2 + e2 + i2.config.legend.offsetY, a2.style.left = r2 + &quot;px&quot;, a2.style.top = n2 + &quot;px&quot;, &quot;right&quot; === i2.config.legend.position &amp;&amp; (a2.style.left = &quot;auto&quot;, a2.style.right = 25 + i2.config.legend.offsetX + &quot;px&quot;);
    [&quot;width&quot;, &quot;height&quot;].forEach(function(t4) {
      a2.style[t4] &amp;&amp; (a2.style[t4] = parseInt(i2.config.legend[t4], 10) + &quot;px&quot;);
    });
  } }, { key: &quot;legendAlignHorizontal&quot;, value: function() {
    var t3 = this.w;
    t3.globals.dom.elLegendWrap.style.right = 0;
    var e2 = new pa(this.ctx), i2 = e2.dimHelpers.getTitleSubtitleCoords(&quot;title&quot;), a2 = e2.dimHelpers.getTitleSubtitleCoords(&quot;subtitle&quot;), s2 = 0;
    &quot;top&quot; === t3.config.legend.position &amp;&amp; (s2 = i2.height + a2.height + t3.config.title.margin + t3.config.subtitle.margin - 10), this.setLegendWrapXY(20, s2);
  } }, { key: &quot;legendAlignVertical&quot;, value: function() {
    var t3 = this.w, e2 = this.legendHelpers.getLegendDimensions(), i2 = 0;
    &quot;left&quot; === t3.config.legend.position &amp;&amp; (i2 = 20), &quot;right&quot; === t3.config.legend.position &amp;&amp; (i2 = t3.globals.svgWidth - e2.clww - 10), this.setLegendWrapXY(i2, 20);
  } }, { key: &quot;onLegendHovered&quot;, value: function(t3) {
    var e2 = this.w, i2 = t3.target.classList.contains(&quot;apexcharts-legend-series&quot;) || t3.target.classList.contains(&quot;apexcharts-legend-text&quot;) || t3.target.classList.contains(&quot;apexcharts-legend-marker&quot;);
    if (&quot;heatmap&quot; === e2.config.chart.type || this.isBarsDistributed) {
      if (i2) {
        var a2 = parseInt(t3.target.getAttribute(&quot;rel&quot;), 10) - 1;
        this.ctx.events.fireEvent(&quot;legendHover&quot;, [this.ctx, a2, this.w]), new Zi(this.ctx).highlightRangeInSeries(t3, t3.target);
      }
    } else !t3.target.classList.contains(&quot;apexcharts-inactive-legend&quot;) &amp;&amp; i2 &amp;&amp; new Zi(this.ctx).toggleSeriesOnHover(t3, t3.target);
  } }, { key: &quot;onLegendClick&quot;, value: function(t3) {
    var e2 = this.w;
    if (!e2.config.legend.customLegendItems.length &amp;&amp; (t3.target.classList.contains(&quot;apexcharts-legend-series&quot;) || t3.target.classList.contains(&quot;apexcharts-legend-text&quot;) || t3.target.classList.contains(&quot;apexcharts-legend-marker&quot;))) {
      var i2 = parseInt(t3.target.getAttribute(&quot;rel&quot;), 10) - 1, a2 = &quot;true&quot; === t3.target.getAttribute(&quot;data:collapsed&quot;), s2 = this.w.config.chart.events.legendClick;
      &quot;function&quot; == typeof s2 &amp;&amp; s2(this.ctx, i2, this.w), this.ctx.events.fireEvent(&quot;legendClick&quot;, [this.ctx, i2, this.w]);
      var r2 = this.w.config.legend.markers.onClick;
      &quot;function&quot; == typeof r2 &amp;&amp; t3.target.classList.contains(&quot;apexcharts-legend-marker&quot;) &amp;&amp; (r2(this.ctx, i2, this.w), this.ctx.events.fireEvent(&quot;legendMarkerClick&quot;, [this.ctx, i2, this.w])), &quot;treemap&quot; !== e2.config.chart.type &amp;&amp; &quot;heatmap&quot; !== e2.config.chart.type &amp;&amp; !this.isBarsDistributed &amp;&amp; e2.config.legend.onItemClick.toggleDataSeries &amp;&amp; this.legendHelpers.toggleDataSeries(i2, a2);
    }
  } }]), t2;
}();
var ba = function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w;
    var a2 = this.w;
    this.ev = this.w.config.chart.events, this.selectedClass = &quot;apexcharts-selected&quot;, this.localeValues = this.w.globals.locale.toolbar, this.minX = a2.globals.minX, this.maxX = a2.globals.maxX;
  }
  return s(t2, [{ key: &quot;createToolbar&quot;, value: function() {
    var t3 = this, e2 = this.w, i2 = function() {
      return document.createElement(&quot;div&quot;);
    }, a2 = i2();
    if (a2.setAttribute(&quot;class&quot;, &quot;apexcharts-toolbar&quot;), a2.style.top = e2.config.chart.toolbar.offsetY + &quot;px&quot;, a2.style.right = 3 - e2.config.chart.toolbar.offsetX + &quot;px&quot;, e2.globals.dom.elWrap.appendChild(a2), this.elZoom = i2(), this.elZoomIn = i2(), this.elZoomOut = i2(), this.elPan = i2(), this.elSelection = i2(), this.elZoomReset = i2(), this.elMenuIcon = i2(), this.elMenu = i2(), this.elCustomIcons = [], this.t = e2.config.chart.toolbar.tools, Array.isArray(this.t.customIcons)) for (var s2 = 0; s2 &lt; this.t.customIcons.length; s2++) this.elCustomIcons.push(i2());
    var r2 = [], n2 = function(i3, a3, s3) {
      var n3 = i3.toLowerCase();
      t3.t[n3] &amp;&amp; e2.config.chart.zoom.enabled &amp;&amp; r2.push({ el: a3, icon: &quot;string&quot; == typeof t3.t[n3] ? t3.t[n3] : s3, title: t3.localeValues[i3], class: &quot;apexcharts-&quot;.concat(n3, &quot;-icon&quot;) });
    };
    n2(&quot;zoomIn&quot;, this.elZoomIn, &#x27;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;24&quot; height=&quot;24&quot; viewBox=&quot;0 0 24 24&quot;&gt;\n    &lt;path d=&quot;M0 0h24v24H0z&quot; fill=&quot;none&quot;/&gt;\n    &lt;path d=&quot;M13 7h-2v4H7v2h4v4h2v-4h4v-2h-4V7zm-1-5C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z&quot;/&gt;\n&lt;/svg&gt;\n&#x27;), n2(&quot;zoomOut&quot;, this.elZoomOut, &#x27;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;24&quot; height=&quot;24&quot; viewBox=&quot;0 0 24 24&quot;&gt;\n    &lt;path d=&quot;M0 0h24v24H0z&quot; fill=&quot;none&quot;/&gt;\n    &lt;path d=&quot;M7 11v2h10v-2H7zm5-9C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z&quot;/&gt;\n&lt;/svg&gt;\n&#x27;);
    var o2 = function(i3) {
      t3.t[i3] &amp;&amp; e2.config.chart[i3].enabled &amp;&amp; r2.push({ el: &quot;zoom&quot; === i3 ? t3.elZoom : t3.elSelection, icon: &quot;string&quot; == typeof t3.t[i3] ? t3.t[i3] : &quot;zoom&quot; === i3 ? &#x27;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; fill=&quot;#000000&quot; height=&quot;24&quot; viewBox=&quot;0 0 24 24&quot; width=&quot;24&quot;&gt;\n    &lt;path d=&quot;M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z&quot;/&gt;\n    &lt;path d=&quot;M0 0h24v24H0V0z&quot; fill=&quot;none&quot;/&gt;\n    &lt;path d=&quot;M12 10h-2v2H9v-2H7V9h2V7h1v2h2v1z&quot;/&gt;\n&lt;/svg&gt;&#x27; : &#x27;&lt;svg fill=&quot;#6E8192&quot; height=&quot;24&quot; viewBox=&quot;0 0 24 24&quot; width=&quot;24&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;\n    &lt;path d=&quot;M0 0h24v24H0z&quot; fill=&quot;none&quot;/&gt;\n    &lt;path d=&quot;M3 5h2V3c-1.1 0-2 .9-2 2zm0 8h2v-2H3v2zm4 8h2v-2H7v2zM3 9h2V7H3v2zm10-6h-2v2h2V3zm6 0v2h2c0-1.1-.9-2-2-2zM5 21v-2H3c0 1.1.9 2 2 2zm-2-4h2v-2H3v2zM9 3H7v2h2V3zm2 18h2v-2h-2v2zm8-8h2v-2h-2v2zm0 8c1.1 0 2-.9 2-2h-2v2zm0-12h2V7h-2v2zm0 8h2v-2h-2v2zm-4 4h2v-2h-2v2zm0-16h2V3h-2v2z&quot;/&gt;\n&lt;/svg&gt;&#x27;, title: t3.localeValues[&quot;zoom&quot; === i3 ? &quot;selectionZoom&quot; : &quot;selection&quot;], class: e2.globals.isTouchDevice ? &quot;apexcharts-element-hidden&quot; : &quot;apexcharts-&quot;.concat(i3, &quot;-icon&quot;) });
    };
    o2(&quot;zoom&quot;), o2(&quot;selection&quot;), this.t.pan &amp;&amp; e2.config.chart.zoom.enabled &amp;&amp; r2.push({ el: this.elPan, icon: &quot;string&quot; == typeof this.t.pan ? this.t.pan : &#x27;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot; fill=&quot;#000000&quot; height=&quot;24&quot; viewBox=&quot;0 0 24 24&quot; width=&quot;24&quot;&gt;\n    &lt;defs&gt;\n        &lt;path d=&quot;M0 0h24v24H0z&quot; id=&quot;a&quot;/&gt;\n    &lt;/defs&gt;\n    &lt;clipPath id=&quot;b&quot;&gt;\n        &lt;use overflow=&quot;visible&quot; xlink:href=&quot;#a&quot;/&gt;\n    &lt;/clipPath&gt;\n    &lt;path clip-path=&quot;url(#b)&quot; d=&quot;M23 5.5V20c0 2.2-1.8 4-4 4h-7.3c-1.08 0-2.1-.43-2.85-1.19L1 14.83s1.26-1.23 1.3-1.25c.22-.19.49-.29.79-.29.22 0 .42.06.6.16.04.01 4.31 2.46 4.31 2.46V4c0-.83.67-1.5 1.5-1.5S11 3.17 11 4v7h1V1.5c0-.83.67-1.5 1.5-1.5S15 .67 15 1.5V11h1V2.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5V11h1V5.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5z&quot;/&gt;\n&lt;/svg&gt;&#x27;, title: this.localeValues.pan, class: e2.globals.isTouchDevice ? &quot;apexcharts-element-hidden&quot; : &quot;apexcharts-pan-icon&quot; }), n2(&quot;reset&quot;, this.elZoomReset, &#x27;&lt;svg fill=&quot;#000000&quot; height=&quot;24&quot; viewBox=&quot;0 0 24 24&quot; width=&quot;24&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;\n    &lt;path d=&quot;M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z&quot;/&gt;\n    &lt;path d=&quot;M0 0h24v24H0z&quot; fill=&quot;none&quot;/&gt;\n&lt;/svg&gt;&#x27;), this.t.download &amp;&amp; r2.push({ el: this.elMenuIcon, icon: &quot;string&quot; == typeof this.t.download ? this.t.download : &#x27;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;24&quot; height=&quot;24&quot; viewBox=&quot;0 0 24 24&quot;&gt;&lt;path fill=&quot;none&quot; d=&quot;M0 0h24v24H0V0z&quot;/&gt;&lt;path d=&quot;M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z&quot;/&gt;&lt;/svg&gt;&#x27;, title: this.localeValues.menu, class: &quot;apexcharts-menu-icon&quot; });
    for (var l2 = 0; l2 &lt; this.elCustomIcons.length; l2++) r2.push({ el: this.elCustomIcons[l2], icon: this.t.customIcons[l2].icon, title: this.t.customIcons[l2].title, index: this.t.customIcons[l2].index, class: &quot;apexcharts-toolbar-custom-icon &quot; + this.t.customIcons[l2].class });
    r2.forEach(function(t4, e3) {
      t4.index &amp;&amp; v.moveIndexInArray(r2, e3, t4.index);
    });
    for (var h2 = 0; h2 &lt; r2.length; h2++) Mi.setAttrs(r2[h2].el, { class: r2[h2].class, title: r2[h2].title }), r2[h2].el.innerHTML = r2[h2].icon, a2.appendChild(r2[h2].el);
    this._createHamburgerMenu(a2), e2.globals.zoomEnabled ? this.elZoom.classList.add(this.selectedClass) : e2.globals.panEnabled ? this.elPan.classList.add(this.selectedClass) : e2.globals.selectionEnabled &amp;&amp; this.elSelection.classList.add(this.selectedClass), this.addToolbarEventListeners();
  } }, { key: &quot;_createHamburgerMenu&quot;, value: function(t3) {
    this.elMenuItems = [], t3.appendChild(this.elMenu), Mi.setAttrs(this.elMenu, { class: &quot;apexcharts-menu&quot; });
    for (var e2 = [{ name: &quot;exportSVG&quot;, title: this.localeValues.exportToSVG }, { name: &quot;exportPNG&quot;, title: this.localeValues.exportToPNG }, { name: &quot;exportCSV&quot;, title: this.localeValues.exportToCSV }], i2 = 0; i2 &lt; e2.length; i2++) this.elMenuItems.push(document.createElement(&quot;div&quot;)), this.elMenuItems[i2].innerHTML = e2[i2].title, Mi.setAttrs(this.elMenuItems[i2], { class: &quot;apexcharts-menu-item &quot;.concat(e2[i2].name), title: e2[i2].title }), this.elMenu.appendChild(this.elMenuItems[i2]);
  } }, { key: &quot;addToolbarEventListeners&quot;, value: function() {
    var t3 = this;
    this.elZoomReset.addEventListener(&quot;click&quot;, this.handleZoomReset.bind(this)), this.elSelection.addEventListener(&quot;click&quot;, this.toggleZoomSelection.bind(this, &quot;selection&quot;)), this.elZoom.addEventListener(&quot;click&quot;, this.toggleZoomSelection.bind(this, &quot;zoom&quot;)), this.elZoomIn.addEventListener(&quot;click&quot;, this.handleZoomIn.bind(this)), this.elZoomOut.addEventListener(&quot;click&quot;, this.handleZoomOut.bind(this)), this.elPan.addEventListener(&quot;click&quot;, this.togglePanning.bind(this)), this.elMenuIcon.addEventListener(&quot;click&quot;, this.toggleMenu.bind(this)), this.elMenuItems.forEach(function(e3) {
      e3.classList.contains(&quot;exportSVG&quot;) ? e3.addEventListener(&quot;click&quot;, t3.handleDownload.bind(t3, &quot;svg&quot;)) : e3.classList.contains(&quot;exportPNG&quot;) ? e3.addEventListener(&quot;click&quot;, t3.handleDownload.bind(t3, &quot;png&quot;)) : e3.classList.contains(&quot;exportCSV&quot;) &amp;&amp; e3.addEventListener(&quot;click&quot;, t3.handleDownload.bind(t3, &quot;csv&quot;));
    });
    for (var e2 = 0; e2 &lt; this.t.customIcons.length; e2++) this.elCustomIcons[e2].addEventListener(&quot;click&quot;, this.t.customIcons[e2].click.bind(this, this.ctx, this.ctx.w));
  } }, { key: &quot;toggleZoomSelection&quot;, value: function(t3) {
    this.ctx.getSyncedCharts().forEach(function(e2) {
      e2.ctx.toolbar.toggleOtherControls();
      var i2 = &quot;selection&quot; === t3 ? e2.ctx.toolbar.elSelection : e2.ctx.toolbar.elZoom, a2 = &quot;selection&quot; === t3 ? &quot;selectionEnabled&quot; : &quot;zoomEnabled&quot;;
      e2.w.globals[a2] = !e2.w.globals[a2], i2.classList.contains(e2.ctx.toolbar.selectedClass) ? i2.classList.remove(e2.ctx.toolbar.selectedClass) : i2.classList.add(e2.ctx.toolbar.selectedClass);
    });
  } }, { key: &quot;getToolbarIconsReference&quot;, value: function() {
    var t3 = this.w;
    this.elZoom || (this.elZoom = t3.globals.dom.baseEl.querySelector(&quot;.apexcharts-zoom-icon&quot;)), this.elPan || (this.elPan = t3.globals.dom.baseEl.querySelector(&quot;.apexcharts-pan-icon&quot;)), this.elSelection || (this.elSelection = t3.globals.dom.baseEl.querySelector(&quot;.apexcharts-selection-icon&quot;));
  } }, { key: &quot;enableZoomPanFromToolbar&quot;, value: function(t3) {
    this.toggleOtherControls(), &quot;pan&quot; === t3 ? this.w.globals.panEnabled = true : this.w.globals.zoomEnabled = true;
    var e2 = &quot;pan&quot; === t3 ? this.elPan : this.elZoom, i2 = &quot;pan&quot; === t3 ? this.elZoom : this.elPan;
    e2 &amp;&amp; e2.classList.add(this.selectedClass), i2 &amp;&amp; i2.classList.remove(this.selectedClass);
  } }, { key: &quot;togglePanning&quot;, value: function() {
    this.ctx.getSyncedCharts().forEach(function(t3) {
      t3.ctx.toolbar.toggleOtherControls(), t3.w.globals.panEnabled = !t3.w.globals.panEnabled, t3.ctx.toolbar.elPan.classList.contains(t3.ctx.toolbar.selectedClass) ? t3.ctx.toolbar.elPan.classList.remove(t3.ctx.toolbar.selectedClass) : t3.ctx.toolbar.elPan.classList.add(t3.ctx.toolbar.selectedClass);
    });
  } }, { key: &quot;toggleOtherControls&quot;, value: function() {
    var t3 = this, e2 = this.w;
    e2.globals.panEnabled = false, e2.globals.zoomEnabled = false, e2.globals.selectionEnabled = false, this.getToolbarIconsReference(), [this.elPan, this.elSelection, this.elZoom].forEach(function(e3) {
      e3 &amp;&amp; e3.classList.remove(t3.selectedClass);
    });
  } }, { key: &quot;handleZoomIn&quot;, value: function() {
    var t3 = this.w;
    t3.globals.isRangeBar &amp;&amp; (this.minX = t3.globals.minY, this.maxX = t3.globals.maxY);
    var e2 = (this.minX + this.maxX) / 2, i2 = (this.minX + e2) / 2, a2 = (this.maxX + e2) / 2, s2 = this._getNewMinXMaxX(i2, a2);
    t3.globals.disableZoomIn || this.zoomUpdateOptions(s2.minX, s2.maxX);
  } }, { key: &quot;handleZoomOut&quot;, value: function() {
    var t3 = this.w;
    if (t3.globals.isRangeBar &amp;&amp; (this.minX = t3.globals.minY, this.maxX = t3.globals.maxY), !(&quot;datetime&quot; === t3.config.xaxis.type &amp;&amp; new Date(this.minX).getUTCFullYear() &lt; 1e3)) {
      var e2 = (this.minX + this.maxX) / 2, i2 = this.minX - (e2 - this.minX), a2 = this.maxX - (e2 - this.maxX), s2 = this._getNewMinXMaxX(i2, a2);
      t3.globals.disableZoomOut || this.zoomUpdateOptions(s2.minX, s2.maxX);
    }
  } }, { key: &quot;_getNewMinXMaxX&quot;, value: function(t3, e2) {
    var i2 = this.w.config.xaxis.convertedCatToNumeric;
    return { minX: i2 ? Math.floor(t3) : t3, maxX: i2 ? Math.floor(e2) : e2 };
  } }, { key: &quot;zoomUpdateOptions&quot;, value: function(t3, e2) {
    var i2 = this.w;
    if (void 0 !== t3 || void 0 !== e2) {
      if (!(i2.config.xaxis.convertedCatToNumeric &amp;&amp; (t3 &lt; 1 &amp;&amp; (t3 = 1, e2 = i2.globals.dataPoints), e2 - t3 &lt; 2))) {
        var a2 = { min: t3, max: e2 }, s2 = this.getBeforeZoomRange(a2);
        s2 &amp;&amp; (a2 = s2.xaxis);
        var r2 = { xaxis: a2 }, n2 = v.clone(i2.globals.initialConfig.yaxis);
        i2.config.chart.group || (r2.yaxis = n2), this.w.globals.zoomed = true, this.ctx.updateHelpers._updateOptions(r2, false, this.w.config.chart.animations.dynamicAnimation.enabled), this.zoomCallback(a2, n2);
      }
    } else this.handleZoomReset();
  } }, { key: &quot;zoomCallback&quot;, value: function(t3, e2) {
    &quot;function&quot; == typeof this.ev.zoomed &amp;&amp; this.ev.zoomed(this.ctx, { xaxis: t3, yaxis: e2 });
  } }, { key: &quot;getBeforeZoomRange&quot;, value: function(t3, e2) {
    var i2 = null;
    return &quot;function&quot; == typeof this.ev.beforeZoom &amp;&amp; (i2 = this.ev.beforeZoom(this, { xaxis: t3, yaxis: e2 })), i2;
  } }, { key: &quot;toggleMenu&quot;, value: function() {
    var t3 = this;
    window.setTimeout(function() {
      t3.elMenu.classList.contains(&quot;apexcharts-menu-open&quot;) ? t3.elMenu.classList.remove(&quot;apexcharts-menu-open&quot;) : t3.elMenu.classList.add(&quot;apexcharts-menu-open&quot;);
    }, 0);
  } }, { key: &quot;handleDownload&quot;, value: function(t3) {
    var e2 = this.w, i2 = new Ji(this.ctx);
    switch (t3) {
      case &quot;svg&quot;:
        i2.exportToSVG(this.ctx);
        break;
      case &quot;png&quot;:
        i2.exportToPng(this.ctx);
        break;
      case &quot;csv&quot;:
        i2.exportToCSV({ series: e2.config.series, columnDelimiter: e2.config.chart.toolbar.export.csv.columnDelimiter });
    }
  } }, { key: &quot;handleZoomReset&quot;, value: function(t3) {
    this.ctx.getSyncedCharts().forEach(function(t4) {
      var e2 = t4.w;
      if (e2.globals.lastXAxis.min = e2.globals.initialConfig.xaxis.min, e2.globals.lastXAxis.max = e2.globals.initialConfig.xaxis.max, t4.updateHelpers.revertDefaultAxisMinMax(), &quot;function&quot; == typeof e2.config.chart.events.beforeResetZoom) {
        var i2 = e2.config.chart.events.beforeResetZoom(t4, e2);
        i2 &amp;&amp; t4.updateHelpers.revertDefaultAxisMinMax(i2);
      }
      &quot;function&quot; == typeof e2.config.chart.events.zoomed &amp;&amp; t4.ctx.toolbar.zoomCallback({ min: e2.config.xaxis.min, max: e2.config.xaxis.max }), e2.globals.zoomed = false;
      var a2 = t4.ctx.series.emptyCollapsedSeries(v.clone(e2.globals.initialSeries));
      t4.updateHelpers._updateSeries(a2, e2.config.chart.animations.dynamicAnimation.enabled);
    });
  } }, { key: &quot;destroy&quot;, value: function() {
    this.elZoom = null, this.elZoomIn = null, this.elZoomOut = null, this.elPan = null, this.elSelection = null, this.elZoomReset = null, this.elMenuIcon = null;
  } }]), t2;
}();
var ma = function(t2) {
  h(a2, ba);
  var e2 = n(a2);
  function a2(t3) {
    var s2;
    return i(this, a2), (s2 = e2.call(this, t3)).ctx = t3, s2.w = t3.w, s2.dragged = false, s2.graphics = new Mi(s2.ctx), s2.eventList = [&quot;mousedown&quot;, &quot;mouseleave&quot;, &quot;mousemove&quot;, &quot;touchstart&quot;, &quot;touchmove&quot;, &quot;mouseup&quot;, &quot;touchend&quot;, &quot;wheel&quot;], s2.clientX = 0, s2.clientY = 0, s2.startX = 0, s2.endX = 0, s2.dragX = 0, s2.startY = 0, s2.endY = 0, s2.dragY = 0, s2.moveDirection = &quot;none&quot;, s2.debounceTimer = null, s2.debounceDelay = 100, s2.wheelDelay = 400, s2;
  }
  return s(a2, [{ key: &quot;init&quot;, value: function(t3) {
    var e3 = this, i2 = t3.xyRatios, a3 = this.w, s2 = this;
    this.xyRatios = i2, this.zoomRect = this.graphics.drawRect(0, 0, 0, 0), this.selectionRect = this.graphics.drawRect(0, 0, 0, 0), this.gridRect = a3.globals.dom.baseEl.querySelector(&quot;.apexcharts-grid&quot;), this.constraints = new kt(0, 0, a3.globals.gridWidth, a3.globals.gridHeight), this.zoomRect.node.classList.add(&quot;apexcharts-zoom-rect&quot;), this.selectionRect.node.classList.add(&quot;apexcharts-selection-rect&quot;), a3.globals.dom.Paper.add(this.zoomRect), a3.globals.dom.Paper.add(this.selectionRect), &quot;x&quot; === a3.config.chart.selection.type ? this.slDraggableRect = this.selectionRect.draggable({ minX: 0, minY: 0, maxX: a3.globals.gridWidth, maxY: a3.globals.gridHeight }).on(&quot;dragmove.namespace&quot;, this.selectionDragging.bind(this, &quot;dragging&quot;)) : &quot;y&quot; === a3.config.chart.selection.type ? this.slDraggableRect = this.selectionRect.draggable({ minX: 0, maxX: a3.globals.gridWidth }).on(&quot;dragmove.namespace&quot;, this.selectionDragging.bind(this, &quot;dragging&quot;)) : this.slDraggableRect = this.selectionRect.draggable().on(&quot;dragmove.namespace&quot;, this.selectionDragging.bind(this, &quot;dragging&quot;)), this.preselectedSelection(), this.hoverArea = a3.globals.dom.baseEl.querySelector(&quot;&quot;.concat(a3.globals.chartClass, &quot; .apexcharts-svg&quot;)), this.hoverArea.classList.add(&quot;apexcharts-zoomable&quot;), this.eventList.forEach(function(t4) {
      e3.hoverArea.addEventListener(t4, s2.svgMouseEvents.bind(s2, i2), { capture: false, passive: true });
    }), a3.config.chart.zoom.enabled &amp;&amp; a3.config.chart.zoom.allowMouseWheelZoom &amp;&amp; this.hoverArea.addEventListener(&quot;wheel&quot;, s2.mouseWheelEvent.bind(s2), { capture: false, passive: false });
  } }, { key: &quot;destroy&quot;, value: function() {
    this.slDraggableRect &amp;&amp; (this.slDraggableRect.draggable(false), this.slDraggableRect.off(), this.selectionRect.off()), this.selectionRect = null, this.zoomRect = null, this.gridRect = null;
  } }, { key: &quot;svgMouseEvents&quot;, value: function(t3, e3) {
    var i2 = this.w, a3 = this.ctx.toolbar, s2 = i2.globals.zoomEnabled ? i2.config.chart.zoom.type : i2.config.chart.selection.type, r2 = i2.config.chart.toolbar.autoSelected;
    if (e3.shiftKey ? (this.shiftWasPressed = true, a3.enableZoomPanFromToolbar(&quot;pan&quot; === r2 ? &quot;zoom&quot; : &quot;pan&quot;)) : this.shiftWasPressed &amp;&amp; (a3.enableZoomPanFromToolbar(r2), this.shiftWasPressed = false), e3.target) {
      var n2, o2 = e3.target.classList;
      if (e3.target.parentNode &amp;&amp; null !== e3.target.parentNode &amp;&amp; (n2 = e3.target.parentNode.classList), !(o2.contains(&quot;apexcharts-legend-marker&quot;) || o2.contains(&quot;apexcharts-legend-text&quot;) || n2 &amp;&amp; n2.contains(&quot;apexcharts-toolbar&quot;))) {
        if (this.clientX = &quot;touchmove&quot; === e3.type || &quot;touchstart&quot; === e3.type ? e3.touches[0].clientX : &quot;touchend&quot; === e3.type ? e3.changedTouches[0].clientX : e3.clientX, this.clientY = &quot;touchmove&quot; === e3.type || &quot;touchstart&quot; === e3.type ? e3.touches[0].clientY : &quot;touchend&quot; === e3.type ? e3.changedTouches[0].clientY : e3.clientY, &quot;mousedown&quot; === e3.type &amp;&amp; 1 === e3.which || &quot;touchstart&quot; === e3.type) {
          var l2 = this.gridRect.getBoundingClientRect();
          this.startX = this.clientX - l2.left - i2.globals.barPadForNumericAxis, this.startY = this.clientY - l2.top, this.dragged = false, this.w.globals.mousedown = true;
        }
        (&quot;mousemove&quot; === e3.type &amp;&amp; 1 === e3.which || &quot;touchmove&quot; === e3.type) &amp;&amp; (this.dragged = true, i2.globals.panEnabled ? (i2.globals.selection = null, this.w.globals.mousedown &amp;&amp; this.panDragging({ context: this, zoomtype: s2, xyRatios: t3 })) : (this.w.globals.mousedown &amp;&amp; i2.globals.zoomEnabled || this.w.globals.mousedown &amp;&amp; i2.globals.selectionEnabled) &amp;&amp; (this.selection = this.selectionDrawing({ context: this, zoomtype: s2 }))), &quot;mouseup&quot; !== e3.type &amp;&amp; &quot;touchend&quot; !== e3.type &amp;&amp; &quot;mouseleave&quot; !== e3.type || this.handleMouseUp({ zoomtype: s2 }), this.makeSelectionRectDraggable();
      }
    }
  } }, { key: &quot;handleMouseUp&quot;, value: function(t3) {
    var e3, i2 = t3.zoomtype, a3 = t3.isResized, s2 = this.w, r2 = null === (e3 = this.gridRect) || void 0 === e3 ? void 0 : e3.getBoundingClientRect();
    r2 &amp;&amp; (this.w.globals.mousedown || a3) &amp;&amp; (this.endX = this.clientX - r2.left - s2.globals.barPadForNumericAxis, this.endY = this.clientY - r2.top, this.dragX = Math.abs(this.endX - this.startX), this.dragY = Math.abs(this.endY - this.startY), (s2.globals.zoomEnabled || s2.globals.selectionEnabled) &amp;&amp; this.selectionDrawn({ context: this, zoomtype: i2 }), s2.globals.panEnabled &amp;&amp; s2.config.xaxis.convertedCatToNumeric &amp;&amp; this.delayedPanScrolled()), s2.globals.zoomEnabled &amp;&amp; this.hideSelectionRect(this.selectionRect), this.dragged = false, this.w.globals.mousedown = false;
  } }, { key: &quot;mouseWheelEvent&quot;, value: function(t3) {
    var e3 = this, i2 = this.w;
    t3.preventDefault();
    var a3 = Date.now();
    a3 - i2.globals.lastWheelExecution &gt; this.wheelDelay &amp;&amp; (this.executeMouseWheelZoom(t3), i2.globals.lastWheelExecution = a3), this.debounceTimer &amp;&amp; clearTimeout(this.debounceTimer), this.debounceTimer = setTimeout(function() {
      a3 - i2.globals.lastWheelExecution &gt; e3.wheelDelay &amp;&amp; (e3.executeMouseWheelZoom(t3), i2.globals.lastWheelExecution = a3);
    }, this.debounceDelay);
  } }, { key: &quot;executeMouseWheelZoom&quot;, value: function(t3) {
    var e3, i2 = this.w;
    this.minX = i2.globals.isRangeBar ? i2.globals.minY : i2.globals.minX, this.maxX = i2.globals.isRangeBar ? i2.globals.maxY : i2.globals.maxX;
    var a3 = null === (e3 = this.gridRect) || void 0 === e3 ? void 0 : e3.getBoundingClientRect();
    if (a3) {
      var s2, r2, n2, o2 = (t3.clientX - a3.left) / a3.width, l2 = this.minX, h2 = this.maxX, c2 = h2 - l2;
      if (t3.deltaY &lt; 0) {
        var d2 = l2 + o2 * c2;
        r2 = d2 - (s2 = 0.5 * c2) / 2, n2 = d2 + s2 / 2;
      } else r2 = l2 - (s2 = 1.5 * c2) / 2, n2 = h2 + s2 / 2;
      if (!i2.globals.isRangeBar) {
        r2 = Math.max(r2, i2.globals.initialMinX), n2 = Math.min(n2, i2.globals.initialMaxX);
        var u2 = 0.01 * (i2.globals.initialMaxX - i2.globals.initialMinX);
        if (n2 - r2 &lt; u2) {
          var g2 = (r2 + n2) / 2;
          r2 = g2 - u2 / 2, n2 = g2 + u2 / 2;
        }
      }
      var p2 = this._getNewMinXMaxX(r2, n2);
      isNaN(p2.minX) || isNaN(p2.maxX) || this.zoomUpdateOptions(p2.minX, p2.maxX);
    }
  } }, { key: &quot;makeSelectionRectDraggable&quot;, value: function() {
    var t3 = this, e3 = this.w;
    if (this.selectionRect) {
      var i2 = this.selectionRect.node.getBoundingClientRect();
      i2.width &gt; 0 &amp;&amp; i2.height &gt; 0 &amp;&amp; (this.selectionRect.select(false).resize(false), this.selectionRect.select({ createRot: function() {
      }, updateRot: function() {
      }, createHandle: function(t4, e4, i3, a3, s2) {
        return &quot;l&quot; === s2 || &quot;r&quot; === s2 ? t4.circle(8).css({ &quot;stroke-width&quot;: 1, stroke: &quot;#333&quot;, fill: &quot;#fff&quot; }) : t4.circle(0);
      }, updateHandle: function(t4, e4) {
        return t4.center(e4[0], e4[1]);
      } }).resize().on(&quot;resize&quot;, function() {
        var i3 = e3.globals.zoomEnabled ? e3.config.chart.zoom.type : e3.config.chart.selection.type;
        t3.handleMouseUp({ zoomtype: i3, isResized: true });
      }));
    }
  } }, { key: &quot;preselectedSelection&quot;, value: function() {
    var t3 = this.w, e3 = this.xyRatios;
    if (!t3.globals.zoomEnabled) {
      if (void 0 !== t3.globals.selection &amp;&amp; null !== t3.globals.selection) this.drawSelectionRect(u(u({}, t3.globals.selection), {}, { translateX: t3.globals.translateX, translateY: t3.globals.translateY }));
      else if (void 0 !== t3.config.chart.selection.xaxis.min &amp;&amp; void 0 !== t3.config.chart.selection.xaxis.max) {
        var i2 = (t3.config.chart.selection.xaxis.min - t3.globals.minX) / e3.xRatio, a3 = t3.globals.gridWidth - (t3.globals.maxX - t3.config.chart.selection.xaxis.max) / e3.xRatio - i2;
        t3.globals.isRangeBar &amp;&amp; (i2 = (t3.config.chart.selection.xaxis.min - t3.globals.yAxisScale[0].niceMin) / e3.invertedYRatio, a3 = (t3.config.chart.selection.xaxis.max - t3.config.chart.selection.xaxis.min) / e3.invertedYRatio);
        var s2 = { x: i2, y: 0, width: a3, height: t3.globals.gridHeight, translateX: t3.globals.translateX, translateY: t3.globals.translateY, selectionEnabled: true };
        this.drawSelectionRect(s2), this.makeSelectionRectDraggable(), &quot;function&quot; == typeof t3.config.chart.events.selection &amp;&amp; t3.config.chart.events.selection(this.ctx, { xaxis: { min: t3.config.chart.selection.xaxis.min, max: t3.config.chart.selection.xaxis.max }, yaxis: {} });
      }
    }
  } }, { key: &quot;drawSelectionRect&quot;, value: function(t3) {
    var e3 = t3.x, i2 = t3.y, a3 = t3.width, s2 = t3.height, r2 = t3.translateX, n2 = void 0 === r2 ? 0 : r2, o2 = t3.translateY, l2 = void 0 === o2 ? 0 : o2, h2 = this.w, c2 = this.zoomRect, d2 = this.selectionRect;
    if (this.dragged || null !== h2.globals.selection) {
      var u2 = { transform: &quot;translate(&quot; + n2 + &quot;, &quot; + l2 + &quot;)&quot; };
      h2.globals.zoomEnabled &amp;&amp; this.dragged &amp;&amp; (a3 &lt; 0 &amp;&amp; (a3 = 1), c2.attr({ x: e3, y: i2, width: a3, height: s2, fill: h2.config.chart.zoom.zoomedArea.fill.color, &quot;fill-opacity&quot;: h2.config.chart.zoom.zoomedArea.fill.opacity, stroke: h2.config.chart.zoom.zoomedArea.stroke.color, &quot;stroke-width&quot;: h2.config.chart.zoom.zoomedArea.stroke.width, &quot;stroke-opacity&quot;: h2.config.chart.zoom.zoomedArea.stroke.opacity }), Mi.setAttrs(c2.node, u2)), h2.globals.selectionEnabled &amp;&amp; (d2.attr({ x: e3, y: i2, width: a3 &gt; 0 ? a3 : 0, height: s2 &gt; 0 ? s2 : 0, fill: h2.config.chart.selection.fill.color, &quot;fill-opacity&quot;: h2.config.chart.selection.fill.opacity, stroke: h2.config.chart.selection.stroke.color, &quot;stroke-width&quot;: h2.config.chart.selection.stroke.width, &quot;stroke-dasharray&quot;: h2.config.chart.selection.stroke.dashArray, &quot;stroke-opacity&quot;: h2.config.chart.selection.stroke.opacity }), Mi.setAttrs(d2.node, u2));
    }
  } }, { key: &quot;hideSelectionRect&quot;, value: function(t3) {
    t3 &amp;&amp; t3.attr({ x: 0, y: 0, width: 0, height: 0 });
  } }, { key: &quot;selectionDrawing&quot;, value: function(t3) {
    var e3 = t3.context, i2 = t3.zoomtype, a3 = this.w, s2 = e3, r2 = this.gridRect.getBoundingClientRect(), n2 = s2.startX - 1, o2 = s2.startY, l2 = false, h2 = false, c2 = s2.clientX - r2.left - a3.globals.barPadForNumericAxis, d2 = s2.clientY - r2.top, g2 = c2 - n2, p2 = d2 - o2, f2 = { translateX: a3.globals.translateX, translateY: a3.globals.translateY };
    return Math.abs(g2 + n2) &gt; a3.globals.gridWidth ? g2 = a3.globals.gridWidth - n2 : c2 &lt; 0 &amp;&amp; (g2 = n2), n2 &gt; c2 &amp;&amp; (l2 = true, g2 = Math.abs(g2)), o2 &gt; d2 &amp;&amp; (h2 = true, p2 = Math.abs(p2)), f2 = u(u({}, f2 = &quot;x&quot; === i2 ? { x: l2 ? n2 - g2 : n2, y: 0, width: g2, height: a3.globals.gridHeight } : &quot;y&quot; === i2 ? { x: 0, y: h2 ? o2 - p2 : o2, width: a3.globals.gridWidth, height: p2 } : { x: l2 ? n2 - g2 : n2, y: h2 ? o2 - p2 : o2, width: g2, height: p2 }), {}, { translateX: a3.globals.translateX, translateY: a3.globals.translateY }), s2.drawSelectionRect(f2), s2.selectionDragging(&quot;resizing&quot;), f2;
  } }, { key: &quot;selectionDragging&quot;, value: function(t3, e3) {
    var i2 = this, a3 = this.w;
    if (e3) {
      e3.preventDefault();
      var s2 = e3.detail, r2 = s2.handler, n2 = s2.box, o2 = n2.x, l2 = n2.y;
      o2 &lt; this.constraints.x &amp;&amp; (o2 = this.constraints.x), l2 &lt; this.constraints.y &amp;&amp; (l2 = this.constraints.y), n2.x2 &gt; this.constraints.x2 &amp;&amp; (o2 = this.constraints.x2 - n2.w), n2.y2 &gt; this.constraints.y2 &amp;&amp; (l2 = this.constraints.y2 - n2.h), r2.move(o2, l2);
      var h2 = this.xyRatios, c2 = this.selectionRect, d2 = 0;
      &quot;resizing&quot; === t3 &amp;&amp; (d2 = 30);
      var u2 = function(t4) {
        return parseFloat(c2.node.getAttribute(t4));
      }, g2 = { x: u2(&quot;x&quot;), y: u2(&quot;y&quot;), width: u2(&quot;width&quot;), height: u2(&quot;height&quot;) };
      a3.globals.selection = g2, &quot;function&quot; == typeof a3.config.chart.events.selection &amp;&amp; a3.globals.selectionEnabled &amp;&amp; (clearTimeout(this.w.globals.selectionResizeTimer), this.w.globals.selectionResizeTimer = window.setTimeout(function() {
        var t4, e4, s3, r3, n3 = i2.gridRect.getBoundingClientRect(), o3 = c2.node.getBoundingClientRect();
        a3.globals.isRangeBar ? (t4 = a3.globals.yAxisScale[0].niceMin + (o3.left - n3.left) * h2.invertedYRatio, e4 = a3.globals.yAxisScale[0].niceMin + (o3.right - n3.left) * h2.invertedYRatio, s3 = 0, r3 = 1) : (t4 = a3.globals.xAxisScale.niceMin + (o3.left - n3.left) * h2.xRatio, e4 = a3.globals.xAxisScale.niceMin + (o3.right - n3.left) * h2.xRatio, s3 = a3.globals.yAxisScale[0].niceMin + (n3.bottom - o3.bottom) * h2.yRatio[0], r3 = a3.globals.yAxisScale[0].niceMax - (o3.top - n3.top) * h2.yRatio[0]);
        var l3 = { xaxis: { min: t4, max: e4 }, yaxis: { min: s3, max: r3 } };
        a3.config.chart.events.selection(i2.ctx, l3), a3.config.chart.brush.enabled &amp;&amp; void 0 !== a3.config.chart.events.brushScrolled &amp;&amp; a3.config.chart.events.brushScrolled(i2.ctx, l3);
      }, d2));
    }
  } }, { key: &quot;selectionDrawn&quot;, value: function(t3) {
    var e3, i2, a3 = t3.context, s2 = t3.zoomtype, r2 = this.w, n2 = a3, o2 = this.xyRatios, l2 = this.ctx.toolbar, h2 = r2.globals.zoomEnabled ? n2.zoomRect.node.getBoundingClientRect() : n2.selectionRect.node.getBoundingClientRect(), c2 = n2.gridRect.getBoundingClientRect(), d2 = h2.left - c2.left - r2.globals.barPadForNumericAxis, u2 = h2.right - c2.left - r2.globals.barPadForNumericAxis, g2 = h2.top - c2.top, p2 = h2.bottom - c2.top;
    r2.globals.isRangeBar ? (e3 = r2.globals.yAxisScale[0].niceMin + d2 * o2.invertedYRatio, i2 = r2.globals.yAxisScale[0].niceMin + u2 * o2.invertedYRatio) : (e3 = r2.globals.xAxisScale.niceMin + d2 * o2.xRatio, i2 = r2.globals.xAxisScale.niceMin + u2 * o2.xRatio);
    var f2 = [], x2 = [];
    if (r2.config.yaxis.forEach(function(t4, e4) {
      var i3 = r2.globals.seriesYAxisMap[e4][0], a4 = r2.globals.yAxisScale[e4].niceMax - o2.yRatio[i3] * g2, s3 = r2.globals.yAxisScale[e4].niceMax - o2.yRatio[i3] * p2;
      f2.push(a4), x2.push(s3);
    }), n2.dragged &amp;&amp; (n2.dragX &gt; 10 || n2.dragY &gt; 10) &amp;&amp; e3 !== i2) {
      if (r2.globals.zoomEnabled) {
        var b2 = v.clone(r2.globals.initialConfig.yaxis), m2 = v.clone(r2.globals.initialConfig.xaxis);
        if (r2.globals.zoomed = true, r2.config.xaxis.convertedCatToNumeric &amp;&amp; (e3 = Math.floor(e3), i2 = Math.floor(i2), e3 &lt; 1 &amp;&amp; (e3 = 1, i2 = r2.globals.dataPoints), i2 - e3 &lt; 2 &amp;&amp; (i2 = e3 + 1)), &quot;xy&quot; !== s2 &amp;&amp; &quot;x&quot; !== s2 || (m2 = { min: e3, max: i2 }), &quot;xy&quot; !== s2 &amp;&amp; &quot;y&quot; !== s2 || b2.forEach(function(t4, e4) {
          b2[e4].min = x2[e4], b2[e4].max = f2[e4];
        }), l2) {
          var y2 = l2.getBeforeZoomRange(m2, b2);
          y2 &amp;&amp; (m2 = y2.xaxis ? y2.xaxis : m2, b2 = y2.yaxis ? y2.yaxis : b2);
        }
        var w2 = { xaxis: m2 };
        r2.config.chart.group || (w2.yaxis = b2), n2.ctx.updateHelpers._updateOptions(w2, false, n2.w.config.chart.animations.dynamicAnimation.enabled), &quot;function&quot; == typeof r2.config.chart.events.zoomed &amp;&amp; l2.zoomCallback(m2, b2);
      } else if (r2.globals.selectionEnabled) {
        var k2, A2 = null;
        k2 = { min: e3, max: i2 }, &quot;xy&quot; !== s2 &amp;&amp; &quot;y&quot; !== s2 || (A2 = v.clone(r2.config.yaxis)).forEach(function(t4, e4) {
          A2[e4].min = x2[e4], A2[e4].max = f2[e4];
        }), r2.globals.selection = n2.selection, &quot;function&quot; == typeof r2.config.chart.events.selection &amp;&amp; r2.config.chart.events.selection(n2.ctx, { xaxis: k2, yaxis: A2 });
      }
    }
  } }, { key: &quot;panDragging&quot;, value: function(t3) {
    var e3 = t3.context, i2 = this.w, a3 = e3;
    if (void 0 !== i2.globals.lastClientPosition.x) {
      var s2 = i2.globals.lastClientPosition.x - a3.clientX, r2 = i2.globals.lastClientPosition.y - a3.clientY;
      Math.abs(s2) &gt; Math.abs(r2) &amp;&amp; s2 &gt; 0 ? this.moveDirection = &quot;left&quot; : Math.abs(s2) &gt; Math.abs(r2) &amp;&amp; s2 &lt; 0 ? this.moveDirection = &quot;right&quot; : Math.abs(r2) &gt; Math.abs(s2) &amp;&amp; r2 &gt; 0 ? this.moveDirection = &quot;up&quot; : Math.abs(r2) &gt; Math.abs(s2) &amp;&amp; r2 &lt; 0 &amp;&amp; (this.moveDirection = &quot;down&quot;);
    }
    i2.globals.lastClientPosition = { x: a3.clientX, y: a3.clientY };
    var n2 = i2.globals.isRangeBar ? i2.globals.minY : i2.globals.minX, o2 = i2.globals.isRangeBar ? i2.globals.maxY : i2.globals.maxX;
    i2.config.xaxis.convertedCatToNumeric || a3.panScrolled(n2, o2);
  } }, { key: &quot;delayedPanScrolled&quot;, value: function() {
    var t3 = this.w, e3 = t3.globals.minX, i2 = t3.globals.maxX, a3 = (t3.globals.maxX - t3.globals.minX) / 2;
    &quot;left&quot; === this.moveDirection ? (e3 = t3.globals.minX + a3, i2 = t3.globals.maxX + a3) : &quot;right&quot; === this.moveDirection &amp;&amp; (e3 = t3.globals.minX - a3, i2 = t3.globals.maxX - a3), e3 = Math.floor(e3), i2 = Math.floor(i2), this.updateScrolledChart({ xaxis: { min: e3, max: i2 } }, e3, i2);
  } }, { key: &quot;panScrolled&quot;, value: function(t3, e3) {
    var i2 = this.w, a3 = this.xyRatios, s2 = v.clone(i2.globals.initialConfig.yaxis), r2 = a3.xRatio, n2 = i2.globals.minX, o2 = i2.globals.maxX;
    i2.globals.isRangeBar &amp;&amp; (r2 = a3.invertedYRatio, n2 = i2.globals.minY, o2 = i2.globals.maxY), &quot;left&quot; === this.moveDirection ? (t3 = n2 + i2.globals.gridWidth / 15 * r2, e3 = o2 + i2.globals.gridWidth / 15 * r2) : &quot;right&quot; === this.moveDirection &amp;&amp; (t3 = n2 - i2.globals.gridWidth / 15 * r2, e3 = o2 - i2.globals.gridWidth / 15 * r2), i2.globals.isRangeBar || (t3 &lt; i2.globals.initialMinX || e3 &gt; i2.globals.initialMaxX) &amp;&amp; (t3 = n2, e3 = o2);
    var l2 = { xaxis: { min: t3, max: e3 } };
    i2.config.chart.group || (l2.yaxis = s2), this.updateScrolledChart(l2, t3, e3);
  } }, { key: &quot;updateScrolledChart&quot;, value: function(t3, e3, i2) {
    var a3 = this.w;
    this.ctx.updateHelpers._updateOptions(t3, false, false), &quot;function&quot; == typeof a3.config.chart.events.scrolled &amp;&amp; a3.config.chart.events.scrolled(this.ctx, { xaxis: { min: e3, max: i2 } });
  } }]), a2;
}();
var va = function() {
  function t2(e2) {
    i(this, t2), this.w = e2.w, this.ttCtx = e2, this.ctx = e2.ctx;
  }
  return s(t2, [{ key: &quot;getNearestValues&quot;, value: function(t3) {
    var e2 = t3.hoverArea, i2 = t3.elGrid, a2 = t3.clientX, s2 = t3.clientY, r2 = this.w, n2 = i2.getBoundingClientRect(), o2 = n2.width, l2 = n2.height, h2 = o2 / (r2.globals.dataPoints - 1), c2 = l2 / r2.globals.dataPoints, d2 = this.hasBars();
    !r2.globals.comboCharts &amp;&amp; !d2 || r2.config.xaxis.convertedCatToNumeric || (h2 = o2 / r2.globals.dataPoints);
    var u2 = a2 - n2.left - r2.globals.barPadForNumericAxis, g2 = s2 - n2.top;
    u2 &lt; 0 || g2 &lt; 0 || u2 &gt; o2 || g2 &gt; l2 ? (e2.classList.remove(&quot;hovering-zoom&quot;), e2.classList.remove(&quot;hovering-pan&quot;)) : r2.globals.zoomEnabled ? (e2.classList.remove(&quot;hovering-pan&quot;), e2.classList.add(&quot;hovering-zoom&quot;)) : r2.globals.panEnabled &amp;&amp; (e2.classList.remove(&quot;hovering-zoom&quot;), e2.classList.add(&quot;hovering-pan&quot;));
    var p2 = Math.round(u2 / h2), f2 = Math.floor(g2 / c2);
    d2 &amp;&amp; !r2.config.xaxis.convertedCatToNumeric &amp;&amp; (p2 = Math.ceil(u2 / h2), p2 -= 1);
    var x2 = null, b2 = null, m2 = r2.globals.seriesXvalues.map(function(t4) {
      return t4.filter(function(t5) {
        return v.isNumber(t5);
      });
    }), y2 = r2.globals.seriesYvalues.map(function(t4) {
      return t4.filter(function(t5) {
        return v.isNumber(t5);
      });
    });
    if (r2.globals.isXNumeric) {
      var w2 = this.ttCtx.getElGrid().getBoundingClientRect(), k2 = u2 * (w2.width / o2), A2 = g2 * (w2.height / l2);
      x2 = (b2 = this.closestInMultiArray(k2, A2, m2, y2)).index, p2 = b2.j, null !== x2 &amp;&amp; r2.globals.hasNullValues &amp;&amp; (m2 = r2.globals.seriesXvalues[x2], p2 = (b2 = this.closestInArray(k2, m2)).j);
    }
    return r2.globals.capturedSeriesIndex = null === x2 ? -1 : x2, (!p2 || p2 &lt; 1) &amp;&amp; (p2 = 0), r2.globals.isBarHorizontal ? r2.globals.capturedDataPointIndex = f2 : r2.globals.capturedDataPointIndex = p2, { capturedSeries: x2, j: r2.globals.isBarHorizontal ? f2 : p2, hoverX: u2, hoverY: g2 };
  } }, { key: &quot;getFirstActiveXArray&quot;, value: function(t3) {
    for (var e2 = this.w, i2 = 0, a2 = t3.map(function(t4, e3) {
      return t4.length &gt; 0 ? e3 : -1;
    }), s2 = 0; s2 &lt; a2.length; s2++) if (-1 !== a2[s2] &amp;&amp; -1 === e2.globals.collapsedSeriesIndices.indexOf(s2) &amp;&amp; -1 === e2.globals.ancillaryCollapsedSeriesIndices.indexOf(s2)) {
      i2 = a2[s2];
      break;
    }
    return i2;
  } }, { key: &quot;closestInMultiArray&quot;, value: function(t3, e2, i2, a2) {
    for (var s2, r2 = this.w, n2 = 1 / 0, o2 = null, l2 = null, h2 = 0; h2 &lt; i2.length; h2++) if (s2 = h2, -1 === r2.globals.collapsedSeriesIndices.indexOf(s2) &amp;&amp; -1 === r2.globals.ancillaryCollapsedSeriesIndices.indexOf(s2)) for (var c2 = i2[h2], d2 = a2[h2], u2 = Math.min(c2.length, d2.length), g2 = 0; g2 &lt; u2; g2++) {
      var p2 = t3 - c2[g2], f2 = Math.sqrt(p2 * p2);
      if (!r2.globals.allSeriesHasEqualX) {
        var x2 = e2 - d2[g2];
        f2 = Math.sqrt(p2 * p2 + x2 * x2);
      }
      f2 &lt; n2 &amp;&amp; (n2 = f2, o2 = h2, l2 = g2);
    }
    return { index: o2, j: l2 };
  } }, { key: &quot;closestInArray&quot;, value: function(t3, e2) {
    for (var i2 = e2[0], a2 = null, s2 = Math.abs(t3 - i2), r2 = 0; r2 &lt; e2.length; r2++) {
      var n2 = Math.abs(t3 - e2[r2]);
      n2 &lt; s2 &amp;&amp; (s2 = n2, a2 = r2);
    }
    return { j: a2 };
  } }, { key: &quot;isXoverlap&quot;, value: function(t3) {
    var e2 = [], i2 = this.w.globals.seriesX.filter(function(t4) {
      return void 0 !== t4[0];
    });
    if (i2.length &gt; 0) for (var a2 = 0; a2 &lt; i2.length - 1; a2++) void 0 !== i2[a2][t3] &amp;&amp; void 0 !== i2[a2 + 1][t3] &amp;&amp; i2[a2][t3] !== i2[a2 + 1][t3] &amp;&amp; e2.push(&quot;unEqual&quot;);
    return 0 === e2.length;
  } }, { key: &quot;isInitialSeriesSameLen&quot;, value: function() {
    for (var t3 = true, e2 = this.w.globals.initialSeries, i2 = 0; i2 &lt; e2.length - 1; i2++) if (e2[i2].data.length !== e2[i2 + 1].data.length) {
      t3 = false;
      break;
    }
    return t3;
  } }, { key: &quot;getBarsHeight&quot;, value: function(t3) {
    return f(t3).reduce(function(t4, e2) {
      return t4 + e2.getBBox().height;
    }, 0);
  } }, { key: &quot;getElMarkers&quot;, value: function(t3) {
    return &quot;number&quot; == typeof t3 ? this.w.globals.dom.baseEl.querySelectorAll(&quot;.apexcharts-series[data\\:realIndex=&#x27;&quot;.concat(t3, &quot;&#x27;] .apexcharts-series-markers-wrap &gt; *&quot;)) : this.w.globals.dom.baseEl.querySelectorAll(&quot;.apexcharts-series-markers-wrap &gt; *&quot;);
  } }, { key: &quot;getAllMarkers&quot;, value: function() {
    var t3 = this, e2 = arguments.length &gt; 0 &amp;&amp; void 0 !== arguments[0] &amp;&amp; arguments[0], i2 = this.w.globals.dom.baseEl.querySelectorAll(&quot;.apexcharts-series-markers-wrap&quot;);
    i2 = f(i2), e2 &amp;&amp; (i2 = i2.filter(function(e3) {
      var i3 = Number(e3.getAttribute(&quot;data:realIndex&quot;));
      return -1 === t3.w.globals.collapsedSeriesIndices.indexOf(i3);
    })), i2.sort(function(t4, e3) {
      var i3 = Number(t4.getAttribute(&quot;data:realIndex&quot;)), a3 = Number(e3.getAttribute(&quot;data:realIndex&quot;));
      return a3 &lt; i3 ? 1 : a3 &gt; i3 ? -1 : 0;
    });
    var a2 = [];
    return i2.forEach(function(t4) {
      a2.push(t4.querySelector(&quot;.apexcharts-marker&quot;));
    }), a2;
  } }, { key: &quot;hasMarkers&quot;, value: function(t3) {
    return this.getElMarkers(t3).length &gt; 0;
  } }, { key: &quot;getPathFromPoint&quot;, value: function(t3, e2) {
    var i2 = Number(t3.getAttribute(&quot;cx&quot;)), a2 = Number(t3.getAttribute(&quot;cy&quot;)), s2 = t3.getAttribute(&quot;shape&quot;);
    return new Mi(this.ctx).getMarkerPath(i2, a2, s2, e2);
  } }, { key: &quot;getElBars&quot;, value: function() {
    return this.w.globals.dom.baseEl.querySelectorAll(&quot;.apexcharts-bar-series,  .apexcharts-candlestick-series, .apexcharts-boxPlot-series, .apexcharts-rangebar-series&quot;);
  } }, { key: &quot;hasBars&quot;, value: function() {
    return this.getElBars().length &gt; 0;
  } }, { key: &quot;getHoverMarkerSize&quot;, value: function(t3) {
    var e2 = this.w, i2 = e2.config.markers.hover.size;
    return void 0 === i2 &amp;&amp; (i2 = e2.globals.markers.size[t3] + e2.config.markers.hover.sizeOffset), i2;
  } }, { key: &quot;toggleAllTooltipSeriesGroups&quot;, value: function(t3) {
    var e2 = this.w, i2 = this.ttCtx;
    0 === i2.allTooltipSeriesGroups.length &amp;&amp; (i2.allTooltipSeriesGroups = e2.globals.dom.baseEl.querySelectorAll(&quot;.apexcharts-tooltip-series-group&quot;));
    for (var a2 = i2.allTooltipSeriesGroups, s2 = 0; s2 &lt; a2.length; s2++) &quot;enable&quot; === t3 ? (a2[s2].classList.add(&quot;apexcharts-active&quot;), a2[s2].style.display = e2.config.tooltip.items.display) : (a2[s2].classList.remove(&quot;apexcharts-active&quot;), a2[s2].style.display = &quot;none&quot;);
  } }]), t2;
}();
var ya = function() {
  function t2(e2) {
    i(this, t2), this.w = e2.w, this.ctx = e2.ctx, this.ttCtx = e2, this.tooltipUtil = new va(e2);
  }
  return s(t2, [{ key: &quot;drawSeriesTexts&quot;, value: function(t3) {
    var e2 = t3.shared, i2 = void 0 === e2 || e2, a2 = t3.ttItems, s2 = t3.i, r2 = void 0 === s2 ? 0 : s2, n2 = t3.j, o2 = void 0 === n2 ? null : n2, l2 = t3.y1, h2 = t3.y2, c2 = t3.e, d2 = this.w;
    void 0 !== d2.config.tooltip.custom ? this.handleCustomTooltip({ i: r2, j: o2, y1: l2, y2: h2, w: d2 }) : this.toggleActiveInactiveSeries(i2, r2);
    var u2 = this.getValuesToPrint({ i: r2, j: o2 });
    this.printLabels({ i: r2, j: o2, values: u2, ttItems: a2, shared: i2, e: c2 });
    var g2 = this.ttCtx.getElTooltip();
    this.ttCtx.tooltipRect.ttWidth = g2.getBoundingClientRect().width, this.ttCtx.tooltipRect.ttHeight = g2.getBoundingClientRect().height;
  } }, { key: &quot;printLabels&quot;, value: function(t3) {
    var e2, i2 = this, a2 = t3.i, s2 = t3.j, r2 = t3.values, n2 = t3.ttItems, o2 = t3.shared, l2 = t3.e, h2 = this.w, c2 = [], d2 = function(t4) {
      return h2.globals.seriesGoals[t4] &amp;&amp; h2.globals.seriesGoals[t4][s2] &amp;&amp; Array.isArray(h2.globals.seriesGoals[t4][s2]);
    }, g2 = r2.xVal, p2 = r2.zVal, f2 = r2.xAxisTTVal, x2 = &quot;&quot;, b2 = h2.globals.colors[a2];
    null !== s2 &amp;&amp; h2.config.plotOptions.bar.distributed &amp;&amp; (b2 = h2.globals.colors[s2]);
    for (var m2 = function(t4, r3) {
      var m3 = i2.getFormatters(a2);
      x2 = i2.getSeriesName({ fn: m3.yLbTitleFormatter, index: a2, seriesIndex: a2, j: s2 }), &quot;treemap&quot; === h2.config.chart.type &amp;&amp; (x2 = m3.yLbTitleFormatter(String(h2.config.series[a2].data[s2].x), { series: h2.globals.series, seriesIndex: a2, dataPointIndex: s2, w: h2 }));
      var v3 = h2.config.tooltip.inverseOrder ? r3 : t4;
      if (h2.globals.axisCharts) {
        var y3 = function(t5) {
          var e3, i3, a3, r4;
          return h2.globals.isRangeData ? m3.yLbFormatter(null === (e3 = h2.globals.seriesRangeStart) || void 0 === e3 || null === (i3 = e3[t5]) || void 0 === i3 ? void 0 : i3[s2], { series: h2.globals.seriesRangeStart, seriesIndex: t5, dataPointIndex: s2, w: h2 }) + &quot; - &quot; + m3.yLbFormatter(null === (a3 = h2.globals.seriesRangeEnd) || void 0 === a3 || null === (r4 = a3[t5]) || void 0 === r4 ? void 0 : r4[s2], { series: h2.globals.seriesRangeEnd, seriesIndex: t5, dataPointIndex: s2, w: h2 }) : m3.yLbFormatter(h2.globals.series[t5][s2], { series: h2.globals.series, seriesIndex: t5, dataPointIndex: s2, w: h2 });
        };
        if (o2) m3 = i2.getFormatters(v3), x2 = i2.getSeriesName({ fn: m3.yLbTitleFormatter, index: v3, seriesIndex: a2, j: s2 }), b2 = h2.globals.colors[v3], e2 = y3(v3), d2(v3) &amp;&amp; (c2 = h2.globals.seriesGoals[v3][s2].map(function(t5) {
          return { attrs: t5, val: m3.yLbFormatter(t5.value, { seriesIndex: v3, dataPointIndex: s2, w: h2 }) };
        }));
        else {
          var w2, k2 = null == l2 || null === (w2 = l2.target) || void 0 === w2 ? void 0 : w2.getAttribute(&quot;fill&quot;);
          k2 &amp;&amp; (-1 !== k2.indexOf(&quot;url&quot;) ? -1 !== k2.indexOf(&quot;Pattern&quot;) &amp;&amp; (b2 = h2.globals.dom.baseEl.querySelector(k2.substr(4).slice(0, -1)).childNodes[0].getAttribute(&quot;stroke&quot;)) : b2 = k2), e2 = y3(a2), d2(a2) &amp;&amp; Array.isArray(h2.globals.seriesGoals[a2][s2]) &amp;&amp; (c2 = h2.globals.seriesGoals[a2][s2].map(function(t5) {
            return { attrs: t5, val: m3.yLbFormatter(t5.value, { seriesIndex: a2, dataPointIndex: s2, w: h2 }) };
          }));
        }
      }
      null === s2 &amp;&amp; (e2 = m3.yLbFormatter(h2.globals.series[a2], u(u({}, h2), {}, { seriesIndex: a2, dataPointIndex: a2 }))), i2.DOMHandling({ i: a2, t: v3, j: s2, ttItems: n2, values: { val: e2, goalVals: c2, xVal: g2, xAxisTTVal: f2, zVal: p2 }, seriesName: x2, shared: o2, pColor: b2 });
    }, v2 = 0, y2 = h2.globals.series.length - 1; v2 &lt; h2.globals.series.length; v2++, y2--) m2(v2, y2);
  } }, { key: &quot;getFormatters&quot;, value: function(t3) {
    var e2, i2 = this.w, a2 = i2.globals.yLabelFormatters[t3];
    return void 0 !== i2.globals.ttVal ? Array.isArray(i2.globals.ttVal) ? (a2 = i2.globals.ttVal[t3] &amp;&amp; i2.globals.ttVal[t3].formatter, e2 = i2.globals.ttVal[t3] &amp;&amp; i2.globals.ttVal[t3].title &amp;&amp; i2.globals.ttVal[t3].title.formatter) : (a2 = i2.globals.ttVal.formatter, &quot;function&quot; == typeof i2.globals.ttVal.title.formatter &amp;&amp; (e2 = i2.globals.ttVal.title.formatter)) : e2 = i2.config.tooltip.y.title.formatter, &quot;function&quot; != typeof a2 &amp;&amp; (a2 = i2.globals.yLabelFormatters[0] ? i2.globals.yLabelFormatters[0] : function(t4) {
      return t4;
    }), &quot;function&quot; != typeof e2 &amp;&amp; (e2 = function(t4) {
      return t4 ? t4 + &quot;: &quot; : &quot;&quot;;
    }), { yLbFormatter: a2, yLbTitleFormatter: e2 };
  } }, { key: &quot;getSeriesName&quot;, value: function(t3) {
    var e2 = t3.fn, i2 = t3.index, a2 = t3.seriesIndex, s2 = t3.j, r2 = this.w;
    return e2(String(r2.globals.seriesNames[i2]), { series: r2.globals.series, seriesIndex: a2, dataPointIndex: s2, w: r2 });
  } }, { key: &quot;DOMHandling&quot;, value: function(t3) {
    t3.i;
    var e2 = t3.t, i2 = t3.j, a2 = t3.ttItems, s2 = t3.values, r2 = t3.seriesName, n2 = t3.shared, o2 = t3.pColor, l2 = this.w, h2 = this.ttCtx, c2 = s2.val, d2 = s2.goalVals, u2 = s2.xVal, g2 = s2.xAxisTTVal, p2 = s2.zVal, f2 = null;
    f2 = a2[e2].children, l2.config.tooltip.fillSeriesColor &amp;&amp; (a2[e2].style.backgroundColor = o2, f2[0].style.display = &quot;none&quot;), h2.showTooltipTitle &amp;&amp; (null === h2.tooltipTitle &amp;&amp; (h2.tooltipTitle = l2.globals.dom.baseEl.querySelector(&quot;.apexcharts-tooltip-title&quot;)), h2.tooltipTitle.innerHTML = u2), h2.isXAxisTooltipEnabled &amp;&amp; (h2.xaxisTooltipText.innerHTML = &quot;&quot; !== g2 ? g2 : u2);
    var x2 = a2[e2].querySelector(&quot;.apexcharts-tooltip-text-y-label&quot;);
    x2 &amp;&amp; (x2.innerHTML = r2 || &quot;&quot;);
    var b2 = a2[e2].querySelector(&quot;.apexcharts-tooltip-text-y-value&quot;);
    b2 &amp;&amp; (b2.innerHTML = void 0 !== c2 ? c2 : &quot;&quot;), f2[0] &amp;&amp; f2[0].classList.contains(&quot;apexcharts-tooltip-marker&quot;) &amp;&amp; (l2.config.tooltip.marker.fillColors &amp;&amp; Array.isArray(l2.config.tooltip.marker.fillColors) &amp;&amp; (o2 = l2.config.tooltip.marker.fillColors[e2]), l2.config.tooltip.fillSeriesColor ? f2[0].style.backgroundColor = o2 : f2[0].style.color = o2), l2.config.tooltip.marker.show || (f2[0].style.display = &quot;none&quot;);
    var m2 = a2[e2].querySelector(&quot;.apexcharts-tooltip-text-goals-label&quot;), v2 = a2[e2].querySelector(&quot;.apexcharts-tooltip-text-goals-value&quot;);
    if (d2.length &amp;&amp; l2.globals.seriesGoals[e2]) {
      var y2 = function() {
        var t4 = &quot;&lt;div&gt;&quot;, e3 = &quot;&lt;div&gt;&quot;;
        d2.forEach(function(i3, a3) {
          t4 += &#x27; &lt;div style=&quot;display: flex&quot;&gt;&lt;span class=&quot;apexcharts-tooltip-marker&quot; style=&quot;background-color: &#x27;.concat(i3.attrs.strokeColor, &#x27;; height: 3px; border-radius: 0; top: 5px;&quot;&gt;&lt;/span&gt; &#x27;).concat(i3.attrs.name, &quot;&lt;/div&gt;&quot;), e3 += &quot;&lt;div&gt;&quot;.concat(i3.val, &quot;&lt;/div&gt;&quot;);
        }), m2.innerHTML = t4 + &quot;&lt;/div&gt;&quot;, v2.innerHTML = e3 + &quot;&lt;/div&gt;&quot;;
      };
      n2 ? l2.globals.seriesGoals[e2][i2] &amp;&amp; Array.isArray(l2.globals.seriesGoals[e2][i2]) ? y2() : (m2.innerHTML = &quot;&quot;, v2.innerHTML = &quot;&quot;) : y2();
    } else m2.innerHTML = &quot;&quot;, v2.innerHTML = &quot;&quot;;
    null !== p2 &amp;&amp; (a2[e2].querySelector(&quot;.apexcharts-tooltip-text-z-label&quot;).innerHTML = l2.config.tooltip.z.title, a2[e2].querySelector(&quot;.apexcharts-tooltip-text-z-value&quot;).innerHTML = void 0 !== p2 ? p2 : &quot;&quot;);
    if (n2 &amp;&amp; f2[0]) {
      if (l2.config.tooltip.hideEmptySeries) {
        var w2 = a2[e2].querySelector(&quot;.apexcharts-tooltip-marker&quot;), k2 = a2[e2].querySelector(&quot;.apexcharts-tooltip-text&quot;);
        0 == parseFloat(c2) ? (w2.style.display = &quot;none&quot;, k2.style.display = &quot;none&quot;) : (w2.style.display = &quot;block&quot;, k2.style.display = &quot;block&quot;);
      }
      null == c2 || l2.globals.ancillaryCollapsedSeriesIndices.indexOf(e2) &gt; -1 || l2.globals.collapsedSeriesIndices.indexOf(e2) &gt; -1 || Array.isArray(h2.tConfig.enabledOnSeries) &amp;&amp; -1 === h2.tConfig.enabledOnSeries.indexOf(e2) ? f2[0].parentNode.style.display = &quot;none&quot; : f2[0].parentNode.style.display = l2.config.tooltip.items.display;
    } else Array.isArray(h2.tConfig.enabledOnSeries) &amp;&amp; -1 === h2.tConfig.enabledOnSeries.indexOf(e2) &amp;&amp; (f2[0].parentNode.style.display = &quot;none&quot;);
  } }, { key: &quot;toggleActiveInactiveSeries&quot;, value: function(t3, e2) {
    var i2 = this.w;
    if (t3) this.tooltipUtil.toggleAllTooltipSeriesGroups(&quot;enable&quot;);
    else {
      this.tooltipUtil.toggleAllTooltipSeriesGroups(&quot;disable&quot;);
      var a2 = i2.globals.dom.baseEl.querySelector(&quot;.apexcharts-tooltip-series-group-&quot;.concat(e2));
      a2 &amp;&amp; (a2.classList.add(&quot;apexcharts-active&quot;), a2.style.display = i2.config.tooltip.items.display);
    }
  } }, { key: &quot;getValuesToPrint&quot;, value: function(t3) {
    var e2 = t3.i, i2 = t3.j, a2 = this.w, s2 = this.ctx.series.filteredSeriesX(), r2 = &quot;&quot;, n2 = &quot;&quot;, o2 = null, l2 = null, h2 = { series: a2.globals.series, seriesIndex: e2, dataPointIndex: i2, w: a2 }, c2 = a2.globals.ttZFormatter;
    null === i2 ? l2 = a2.globals.series[e2] : a2.globals.isXNumeric &amp;&amp; &quot;treemap&quot; !== a2.config.chart.type ? (r2 = s2[e2][i2], 0 === s2[e2].length &amp;&amp; (r2 = s2[this.tooltipUtil.getFirstActiveXArray(s2)][i2])) : r2 = new $i(this.ctx).isFormatXY() ? void 0 !== a2.config.series[e2].data[i2] ? a2.config.series[e2].data[i2].x : &quot;&quot; : void 0 !== a2.globals.labels[i2] ? a2.globals.labels[i2] : &quot;&quot;;
    var d2 = r2;
    a2.globals.isXNumeric &amp;&amp; &quot;datetime&quot; === a2.config.xaxis.type ? r2 = new Xi(this.ctx).xLabelFormat(a2.globals.ttKeyFormatter, d2, d2, { i: void 0, dateFormatter: new zi(this.ctx).formatDate, w: this.w }) : r2 = a2.globals.isBarHorizontal ? a2.globals.yLabelFormatters[0](d2, h2) : a2.globals.xLabelFormatter(d2, h2);
    return void 0 !== a2.config.tooltip.x.formatter &amp;&amp; (r2 = a2.globals.ttKeyFormatter(d2, h2)), a2.globals.seriesZ.length &gt; 0 &amp;&amp; a2.globals.seriesZ[e2].length &gt; 0 &amp;&amp; (o2 = c2(a2.globals.seriesZ[e2][i2], a2)), n2 = &quot;function&quot; == typeof a2.config.xaxis.tooltip.formatter ? a2.globals.xaxisTooltipFormatter(d2, h2) : r2, { val: Array.isArray(l2) ? l2.join(&quot; &quot;) : l2, xVal: Array.isArray(r2) ? r2.join(&quot; &quot;) : r2, xAxisTTVal: Array.isArray(n2) ? n2.join(&quot; &quot;) : n2, zVal: o2 };
  } }, { key: &quot;handleCustomTooltip&quot;, value: function(t3) {
    var e2 = t3.i, i2 = t3.j, a2 = t3.y1, s2 = t3.y2, r2 = t3.w, n2 = this.ttCtx.getElTooltip(), o2 = r2.config.tooltip.custom;
    Array.isArray(o2) &amp;&amp; o2[e2] &amp;&amp; (o2 = o2[e2]);
    var l2 = o2({ ctx: this.ctx, series: r2.globals.series, seriesIndex: e2, dataPointIndex: i2, y1: a2, y2: s2, w: r2 });
    &quot;string&quot; == typeof l2 ? n2.innerHTML = l2 : (l2 instanceof Element || &quot;string&quot; == typeof l2.nodeName) &amp;&amp; (n2.innerHTML = &quot;&quot;, n2.appendChild(l2.cloneNode(true)));
  } }]), t2;
}();
var wa = function() {
  function t2(e2) {
    i(this, t2), this.ttCtx = e2, this.ctx = e2.ctx, this.w = e2.w;
  }
  return s(t2, [{ key: &quot;moveXCrosshairs&quot;, value: function(t3) {
    var e2 = arguments.length &gt; 1 &amp;&amp; void 0 !== arguments[1] ? arguments[1] : null, i2 = this.ttCtx, a2 = this.w, s2 = i2.getElXCrosshairs(), r2 = t3 - i2.xcrosshairsWidth / 2, n2 = a2.globals.labels.slice().length;
    if (null !== e2 &amp;&amp; (r2 = a2.globals.gridWidth / n2 * e2), null === s2 || a2.globals.isBarHorizontal || (s2.setAttribute(&quot;x&quot;, r2), s2.setAttribute(&quot;x1&quot;, r2), s2.setAttribute(&quot;x2&quot;, r2), s2.setAttribute(&quot;y2&quot;, a2.globals.gridHeight), s2.classList.add(&quot;apexcharts-active&quot;)), r2 &lt; 0 &amp;&amp; (r2 = 0), r2 &gt; a2.globals.gridWidth &amp;&amp; (r2 = a2.globals.gridWidth), i2.isXAxisTooltipEnabled) {
      var o2 = r2;
      &quot;tickWidth&quot; !== a2.config.xaxis.crosshairs.width &amp;&amp; &quot;barWidth&quot; !== a2.config.xaxis.crosshairs.width || (o2 = r2 + i2.xcrosshairsWidth / 2), this.moveXAxisTooltip(o2);
    }
  } }, { key: &quot;moveYCrosshairs&quot;, value: function(t3) {
    var e2 = this.ttCtx;
    null !== e2.ycrosshairs &amp;&amp; Mi.setAttrs(e2.ycrosshairs, { y1: t3, y2: t3 }), null !== e2.ycrosshairsHidden &amp;&amp; Mi.setAttrs(e2.ycrosshairsHidden, { y1: t3, y2: t3 });
  } }, { key: &quot;moveXAxisTooltip&quot;, value: function(t3) {
    var e2 = this.w, i2 = this.ttCtx;
    if (null !== i2.xaxisTooltip &amp;&amp; 0 !== i2.xcrosshairsWidth) {
      i2.xaxisTooltip.classList.add(&quot;apexcharts-active&quot;);
      var a2 = i2.xaxisOffY + e2.config.xaxis.tooltip.offsetY + e2.globals.translateY + 1 + e2.config.xaxis.offsetY;
      if (t3 -= i2.xaxisTooltip.getBoundingClientRect().width / 2, !isNaN(t3)) {
        t3 += e2.globals.translateX;
        var s2;
        s2 = new Mi(this.ctx).getTextRects(i2.xaxisTooltipText.innerHTML), i2.xaxisTooltipText.style.minWidth = s2.width + &quot;px&quot;, i2.xaxisTooltip.style.left = t3 + &quot;px&quot;, i2.xaxisTooltip.style.top = a2 + &quot;px&quot;;
      }
    }
  } }, { key: &quot;moveYAxisTooltip&quot;, value: function(t3) {
    var e2 = this.w, i2 = this.ttCtx;
    null === i2.yaxisTTEls &amp;&amp; (i2.yaxisTTEls = e2.globals.dom.baseEl.querySelectorAll(&quot;.apexcharts-yaxistooltip&quot;));
    var a2 = parseInt(i2.ycrosshairsHidden.getAttribute(&quot;y1&quot;), 10), s2 = e2.globals.translateY + a2, r2 = i2.yaxisTTEls[t3].getBoundingClientRect().height, n2 = e2.globals.translateYAxisX[t3] - 2;
    e2.config.yaxis[t3].opposite &amp;&amp; (n2 -= 26), s2 -= r2 / 2, -1 === e2.globals.ignoreYAxisIndexes.indexOf(t3) ? (i2.yaxisTTEls[t3].classList.add(&quot;apexcharts-active&quot;), i2.yaxisTTEls[t3].style.top = s2 + &quot;px&quot;, i2.yaxisTTEls[t3].style.left = n2 + e2.config.yaxis[t3].tooltip.offsetX + &quot;px&quot;) : i2.yaxisTTEls[t3].classList.remove(&quot;apexcharts-active&quot;);
  } }, { key: &quot;moveTooltip&quot;, value: function(t3, e2) {
    var i2 = arguments.length &gt; 2 &amp;&amp; void 0 !== arguments[2] ? arguments[2] : null, a2 = this.w, s2 = this.ttCtx, r2 = s2.getElTooltip(), n2 = s2.tooltipRect, o2 = null !== i2 ? parseFloat(i2) : 1, l2 = parseFloat(t3) + o2 + 5, h2 = parseFloat(e2) + o2 / 2;
    if (l2 &gt; a2.globals.gridWidth / 2 &amp;&amp; (l2 = l2 - n2.ttWidth - o2 - 10), l2 &gt; a2.globals.gridWidth - n2.ttWidth - 10 &amp;&amp; (l2 = a2.globals.gridWidth - n2.ttWidth), l2 &lt; -20 &amp;&amp; (l2 = -20), a2.config.tooltip.followCursor) {
      var c2 = s2.getElGrid().getBoundingClientRect();
      (l2 = s2.e.clientX - c2.left) &gt; a2.globals.gridWidth / 2 &amp;&amp; (l2 -= s2.tooltipRect.ttWidth), (h2 = s2.e.clientY + a2.globals.translateY - c2.top) &gt; a2.globals.gridHeight / 2 &amp;&amp; (h2 -= s2.tooltipRect.ttHeight);
    } else a2.globals.isBarHorizontal || n2.ttHeight / 2 + h2 &gt; a2.globals.gridHeight &amp;&amp; (h2 = a2.globals.gridHeight - n2.ttHeight + a2.globals.translateY);
    isNaN(l2) || (l2 += a2.globals.translateX, r2.style.left = l2 + &quot;px&quot;, r2.style.top = h2 + &quot;px&quot;);
  } }, { key: &quot;moveMarkers&quot;, value: function(t3, e2) {
    var i2 = this.w, a2 = this.ttCtx;
    if (i2.globals.markers.size[t3] &gt; 0) for (var s2 = i2.globals.dom.baseEl.querySelectorAll(&quot; .apexcharts-series[data\\:realIndex=&#x27;&quot;.concat(t3, &quot;&#x27;] .apexcharts-marker&quot;)), r2 = 0; r2 &lt; s2.length; r2++) parseInt(s2[r2].getAttribute(&quot;rel&quot;), 10) === e2 &amp;&amp; (a2.marker.resetPointsSize(), a2.marker.enlargeCurrentPoint(e2, s2[r2]));
    else a2.marker.resetPointsSize(), this.moveDynamicPointOnHover(e2, t3);
  } }, { key: &quot;moveDynamicPointOnHover&quot;, value: function(t3, e2) {
    var i2, a2, s2, r2, n2 = this.w, o2 = this.ttCtx, l2 = new Mi(this.ctx), h2 = n2.globals.pointsArray, c2 = o2.tooltipUtil.getHoverMarkerSize(e2), d2 = n2.config.series[e2].type;
    if (!d2 || &quot;column&quot; !== d2 &amp;&amp; &quot;candlestick&quot; !== d2 &amp;&amp; &quot;boxPlot&quot; !== d2) {
      s2 = null === (i2 = h2[e2][t3]) || void 0 === i2 ? void 0 : i2[0], r2 = (null === (a2 = h2[e2][t3]) || void 0 === a2 ? void 0 : a2[1]) || 0;
      var u2 = n2.globals.dom.baseEl.querySelector(&quot;.apexcharts-series[data\\:realIndex=&#x27;&quot;.concat(e2, &quot;&#x27;] .apexcharts-series-markers path&quot;));
      if (u2 &amp;&amp; r2 &lt; n2.globals.gridHeight &amp;&amp; r2 &gt; 0) {
        var g2 = u2.getAttribute(&quot;shape&quot;), p2 = l2.getMarkerPath(s2, r2, g2, 1.5 * c2);
        u2.setAttribute(&quot;d&quot;, p2);
      }
      this.moveXCrosshairs(s2), o2.fixedTooltip || this.moveTooltip(s2, r2, c2);
    }
  } }, { key: &quot;moveDynamicPointsOnHover&quot;, value: function(t3) {
    var e2, i2 = this.ttCtx, a2 = i2.w, s2 = 0, r2 = 0, n2 = a2.globals.pointsArray, o2 = new Zi(this.ctx), l2 = new Mi(this.ctx);
    e2 = o2.getActiveConfigSeriesIndex(&quot;asc&quot;, [&quot;line&quot;, &quot;area&quot;, &quot;scatter&quot;, &quot;bubble&quot;]);
    var h2 = i2.tooltipUtil.getHoverMarkerSize(e2);
    if (n2[e2] &amp;&amp; (s2 = n2[e2][t3][0], r2 = n2[e2][t3][1]), !isNaN(s2)) {
      var c2 = i2.tooltipUtil.getAllMarkers();
      if (c2.length) for (var d2 = 0; d2 &lt; a2.globals.series.length; d2++) {
        var u2 = n2[d2];
        if (a2.globals.comboCharts &amp;&amp; void 0 === u2 &amp;&amp; c2.splice(d2, 0, null), u2 &amp;&amp; u2.length) {
          var g2 = n2[d2][t3][1], p2 = void 0;
          c2[d2].setAttribute(&quot;cx&quot;, s2);
          var f2 = c2[d2].getAttribute(&quot;shape&quot;);
          if (&quot;rangeArea&quot; === a2.config.chart.type &amp;&amp; !a2.globals.comboCharts) {
            var x2 = t3 + a2.globals.series[d2].length;
            p2 = n2[d2][x2][1], g2 -= Math.abs(g2 - p2) / 2;
          }
          if (null !== g2 &amp;&amp; !isNaN(g2) &amp;&amp; g2 &lt; a2.globals.gridHeight + h2 &amp;&amp; g2 + h2 &gt; 0) {
            var b2 = l2.getMarkerPath(s2, g2, f2, h2);
            c2[d2].setAttribute(&quot;d&quot;, b2);
          } else c2[d2].setAttribute(&quot;d&quot;, &quot;&quot;);
        }
      }
      this.moveXCrosshairs(s2), i2.fixedTooltip || this.moveTooltip(s2, r2 || a2.globals.gridHeight, h2);
    }
  } }, { key: &quot;moveStickyTooltipOverBars&quot;, value: function(t3, e2) {
    var i2 = this.w, a2 = this.ttCtx, s2 = i2.globals.columnSeries ? i2.globals.columnSeries.length : i2.globals.series.length;
    i2.config.chart.stacked &amp;&amp; (s2 = i2.globals.barGroups.length);
    var r2 = s2 &gt;= 2 &amp;&amp; s2 % 2 == 0 ? Math.floor(s2 / 2) : Math.floor(s2 / 2) + 1;
    i2.globals.isBarHorizontal &amp;&amp; (r2 = new Zi(this.ctx).getActiveConfigSeriesIndex(&quot;desc&quot;) + 1);
    var n2 = i2.globals.dom.baseEl.querySelector(&quot;.apexcharts-bar-series .apexcharts-series[rel=&#x27;&quot;.concat(r2, &quot;&#x27;] path[j=&#x27;&quot;).concat(t3, &quot;&#x27;], .apexcharts-candlestick-series .apexcharts-series[rel=&#x27;&quot;).concat(r2, &quot;&#x27;] path[j=&#x27;&quot;).concat(t3, &quot;&#x27;], .apexcharts-boxPlot-series .apexcharts-series[rel=&#x27;&quot;).concat(r2, &quot;&#x27;] path[j=&#x27;&quot;).concat(t3, &quot;&#x27;], .apexcharts-rangebar-series .apexcharts-series[rel=&#x27;&quot;).concat(r2, &quot;&#x27;] path[j=&#x27;&quot;).concat(t3, &quot;&#x27;]&quot;));
    n2 || &quot;number&quot; != typeof e2 || (n2 = i2.globals.dom.baseEl.querySelector(&quot;.apexcharts-bar-series .apexcharts-series[data\\:realIndex=&#x27;&quot;.concat(e2, &quot;&#x27;] path[j=&#x27;&quot;).concat(t3, &quot;&#x27;],\n        .apexcharts-candlestick-series .apexcharts-series[data\\:realIndex=&#x27;&quot;).concat(e2, &quot;&#x27;] path[j=&#x27;&quot;).concat(t3, &quot;&#x27;],\n        .apexcharts-boxPlot-series .apexcharts-series[data\\:realIndex=&#x27;&quot;).concat(e2, &quot;&#x27;] path[j=&#x27;&quot;).concat(t3, &quot;&#x27;],\n        .apexcharts-rangebar-series .apexcharts-series[data\\:realIndex=&#x27;&quot;).concat(e2, &quot;&#x27;] path[j=&#x27;&quot;).concat(t3, &quot;&#x27;]&quot;)));
    var o2 = n2 ? parseFloat(n2.getAttribute(&quot;cx&quot;)) : 0, l2 = n2 ? parseFloat(n2.getAttribute(&quot;cy&quot;)) : 0, h2 = n2 ? parseFloat(n2.getAttribute(&quot;barWidth&quot;)) : 0, c2 = a2.getElGrid().getBoundingClientRect(), d2 = n2 &amp;&amp; (n2.classList.contains(&quot;apexcharts-candlestick-area&quot;) || n2.classList.contains(&quot;apexcharts-boxPlot-area&quot;));
    i2.globals.isXNumeric ? (n2 &amp;&amp; !d2 &amp;&amp; (o2 -= s2 % 2 != 0 ? h2 / 2 : 0), n2 &amp;&amp; d2 &amp;&amp; (o2 -= h2 / 2)) : i2.globals.isBarHorizontal || (o2 = a2.xAxisTicksPositions[t3 - 1] + a2.dataPointsDividedWidth / 2, isNaN(o2) &amp;&amp; (o2 = a2.xAxisTicksPositions[t3] - a2.dataPointsDividedWidth / 2)), i2.globals.isBarHorizontal ? l2 -= a2.tooltipRect.ttHeight : i2.config.tooltip.followCursor ? l2 = a2.e.clientY - c2.top - a2.tooltipRect.ttHeight / 2 : l2 + a2.tooltipRect.ttHeight + 15 &gt; i2.globals.gridHeight &amp;&amp; (l2 = i2.globals.gridHeight), i2.globals.isBarHorizontal || this.moveXCrosshairs(o2), a2.fixedTooltip || this.moveTooltip(o2, l2 || i2.globals.gridHeight);
  } }]), t2;
}();
var ka = function() {
  function t2(e2) {
    i(this, t2), this.w = e2.w, this.ttCtx = e2, this.ctx = e2.ctx, this.tooltipPosition = new wa(e2);
  }
  return s(t2, [{ key: &quot;drawDynamicPoints&quot;, value: function() {
    var t3 = this.w, e2 = new Mi(this.ctx), i2 = new Vi(this.ctx), a2 = t3.globals.dom.baseEl.querySelectorAll(&quot;.apexcharts-series&quot;);
    a2 = f(a2), t3.config.chart.stacked &amp;&amp; a2.sort(function(t4, e3) {
      return parseFloat(t4.getAttribute(&quot;data:realIndex&quot;)) - parseFloat(e3.getAttribute(&quot;data:realIndex&quot;));
    });
    for (var s2 = 0; s2 &lt; a2.length; s2++) {
      var r2 = a2[s2].querySelector(&quot;.apexcharts-series-markers-wrap&quot;);
      if (null !== r2) {
        var n2 = void 0, o2 = &quot;apexcharts-marker w&quot;.concat((Math.random() + 1).toString(36).substring(4));
        &quot;line&quot; !== t3.config.chart.type &amp;&amp; &quot;area&quot; !== t3.config.chart.type || t3.globals.comboCharts || t3.config.tooltip.intersect || (o2 += &quot; no-pointer-events&quot;);
        var l2 = i2.getMarkerConfig({ cssClass: o2, seriesIndex: Number(r2.getAttribute(&quot;data:realIndex&quot;)) });
        (n2 = e2.drawMarker(0, 0, l2)).node.setAttribute(&quot;default-marker-size&quot;, 0);
        var h2 = document.createElementNS(t3.globals.SVGNS, &quot;g&quot;);
        h2.classList.add(&quot;apexcharts-series-markers&quot;), h2.appendChild(n2.node), r2.appendChild(h2);
      }
    }
  } }, { key: &quot;enlargeCurrentPoint&quot;, value: function(t3, e2) {
    var i2 = arguments.length &gt; 2 &amp;&amp; void 0 !== arguments[2] ? arguments[2] : null, a2 = arguments.length &gt; 3 &amp;&amp; void 0 !== arguments[3] ? arguments[3] : null, s2 = this.w;
    &quot;bubble&quot; !== s2.config.chart.type &amp;&amp; this.newPointSize(t3, e2);
    var r2 = e2.getAttribute(&quot;cx&quot;), n2 = e2.getAttribute(&quot;cy&quot;);
    if (null !== i2 &amp;&amp; null !== a2 &amp;&amp; (r2 = i2, n2 = a2), this.tooltipPosition.moveXCrosshairs(r2), !this.fixedTooltip) {
      if (&quot;radar&quot; === s2.config.chart.type) {
        var o2 = this.ttCtx.getElGrid().getBoundingClientRect();
        r2 = this.ttCtx.e.clientX - o2.left;
      }
      this.tooltipPosition.moveTooltip(r2, n2, s2.config.markers.hover.size);
    }
  } }, { key: &quot;enlargePoints&quot;, value: function(t3) {
    for (var e2 = this.w, i2 = this, a2 = this.ttCtx, s2 = t3, r2 = e2.globals.dom.baseEl.querySelectorAll(&quot;.apexcharts-series:not(.apexcharts-series-collapsed) .apexcharts-marker&quot;), n2 = e2.config.markers.hover.size, o2 = 0; o2 &lt; r2.length; o2++) {
      var l2 = r2[o2].getAttribute(&quot;rel&quot;), h2 = r2[o2].getAttribute(&quot;index&quot;);
      if (void 0 === n2 &amp;&amp; (n2 = e2.globals.markers.size[h2] + e2.config.markers.hover.sizeOffset), s2 === parseInt(l2, 10)) {
        i2.newPointSize(s2, r2[o2]);
        var c2 = r2[o2].getAttribute(&quot;cx&quot;), d2 = r2[o2].getAttribute(&quot;cy&quot;);
        i2.tooltipPosition.moveXCrosshairs(c2), a2.fixedTooltip || i2.tooltipPosition.moveTooltip(c2, d2, n2);
      } else i2.oldPointSize(r2[o2]);
    }
  } }, { key: &quot;newPointSize&quot;, value: function(t3, e2) {
    var i2 = this.w, a2 = i2.config.markers.hover.size, s2 = 0 === t3 ? e2.parentNode.firstChild : e2.parentNode.lastChild;
    if (&quot;0&quot; !== s2.getAttribute(&quot;default-marker-size&quot;)) {
      var r2 = parseInt(s2.getAttribute(&quot;index&quot;), 10);
      void 0 === a2 &amp;&amp; (a2 = i2.globals.markers.size[r2] + i2.config.markers.hover.sizeOffset), a2 &lt; 0 &amp;&amp; (a2 = 0);
      var n2 = this.ttCtx.tooltipUtil.getPathFromPoint(e2, a2);
      e2.setAttribute(&quot;d&quot;, n2);
    }
  } }, { key: &quot;oldPointSize&quot;, value: function(t3) {
    var e2 = parseFloat(t3.getAttribute(&quot;default-marker-size&quot;)), i2 = this.ttCtx.tooltipUtil.getPathFromPoint(t3, e2);
    t3.setAttribute(&quot;d&quot;, i2);
  } }, { key: &quot;resetPointsSize&quot;, value: function() {
    for (var t3 = this.w.globals.dom.baseEl.querySelectorAll(&quot;.apexcharts-series:not(.apexcharts-series-collapsed) .apexcharts-marker&quot;), e2 = 0; e2 &lt; t3.length; e2++) {
      var i2 = parseFloat(t3[e2].getAttribute(&quot;default-marker-size&quot;));
      if (v.isNumber(i2) &amp;&amp; i2 &gt; 0) {
        var a2 = this.ttCtx.tooltipUtil.getPathFromPoint(t3[e2], i2);
        t3[e2].setAttribute(&quot;d&quot;, a2);
      } else t3[e2].setAttribute(&quot;d&quot;, &quot;M0,0&quot;);
    }
  } }]), t2;
}();
var Aa = function() {
  function t2(e2) {
    i(this, t2), this.w = e2.w;
    var a2 = this.w;
    this.ttCtx = e2, this.isVerticalGroupedRangeBar = !a2.globals.isBarHorizontal &amp;&amp; &quot;rangeBar&quot; === a2.config.chart.type &amp;&amp; a2.config.plotOptions.bar.rangeBarGroupRows;
  }
  return s(t2, [{ key: &quot;getAttr&quot;, value: function(t3, e2) {
    return parseFloat(t3.target.getAttribute(e2));
  } }, { key: &quot;handleHeatTreeTooltip&quot;, value: function(t3) {
    var e2 = t3.e, i2 = t3.opt, a2 = t3.x, s2 = t3.y, r2 = t3.type, n2 = this.ttCtx, o2 = this.w;
    if (e2.target.classList.contains(&quot;apexcharts-&quot;.concat(r2, &quot;-rect&quot;))) {
      var l2 = this.getAttr(e2, &quot;i&quot;), h2 = this.getAttr(e2, &quot;j&quot;), c2 = this.getAttr(e2, &quot;cx&quot;), d2 = this.getAttr(e2, &quot;cy&quot;), u2 = this.getAttr(e2, &quot;width&quot;), g2 = this.getAttr(e2, &quot;height&quot;);
      if (n2.tooltipLabels.drawSeriesTexts({ ttItems: i2.ttItems, i: l2, j: h2, shared: false, e: e2 }), o2.globals.capturedSeriesIndex = l2, o2.globals.capturedDataPointIndex = h2, a2 = c2 + n2.tooltipRect.ttWidth / 2 + u2, s2 = d2 + n2.tooltipRect.ttHeight / 2 - g2 / 2, n2.tooltipPosition.moveXCrosshairs(c2 + u2 / 2), a2 &gt; o2.globals.gridWidth / 2 &amp;&amp; (a2 = c2 - n2.tooltipRect.ttWidth / 2 + u2), n2.w.config.tooltip.followCursor) {
        var p2 = o2.globals.dom.elWrap.getBoundingClientRect();
        a2 = o2.globals.clientX - p2.left - (a2 &gt; o2.globals.gridWidth / 2 ? n2.tooltipRect.ttWidth : 0), s2 = o2.globals.clientY - p2.top - (s2 &gt; o2.globals.gridHeight / 2 ? n2.tooltipRect.ttHeight : 0);
      }
    }
    return { x: a2, y: s2 };
  } }, { key: &quot;handleMarkerTooltip&quot;, value: function(t3) {
    var e2, i2, a2 = t3.e, s2 = t3.opt, r2 = t3.x, n2 = t3.y, o2 = this.w, l2 = this.ttCtx;
    if (a2.target.classList.contains(&quot;apexcharts-marker&quot;)) {
      var h2 = parseInt(s2.paths.getAttribute(&quot;cx&quot;), 10), c2 = parseInt(s2.paths.getAttribute(&quot;cy&quot;), 10), d2 = parseFloat(s2.paths.getAttribute(&quot;val&quot;));
      if (i2 = parseInt(s2.paths.getAttribute(&quot;rel&quot;), 10), e2 = parseInt(s2.paths.parentNode.parentNode.parentNode.getAttribute(&quot;rel&quot;), 10) - 1, l2.intersect) {
        var u2 = v.findAncestor(s2.paths, &quot;apexcharts-series&quot;);
        u2 &amp;&amp; (e2 = parseInt(u2.getAttribute(&quot;data:realIndex&quot;), 10));
      }
      if (l2.tooltipLabels.drawSeriesTexts({ ttItems: s2.ttItems, i: e2, j: i2, shared: !l2.showOnIntersect &amp;&amp; o2.config.tooltip.shared, e: a2 }), &quot;mouseup&quot; === a2.type &amp;&amp; l2.markerClick(a2, e2, i2), o2.globals.capturedSeriesIndex = e2, o2.globals.capturedDataPointIndex = i2, r2 = h2, n2 = c2 + o2.globals.translateY - 1.4 * l2.tooltipRect.ttHeight, l2.w.config.tooltip.followCursor) {
        var g2 = l2.getElGrid().getBoundingClientRect();
        n2 = l2.e.clientY + o2.globals.translateY - g2.top;
      }
      d2 &lt; 0 &amp;&amp; (n2 = c2), l2.marker.enlargeCurrentPoint(i2, s2.paths, r2, n2);
    }
    return { x: r2, y: n2 };
  } }, { key: &quot;handleBarTooltip&quot;, value: function(t3) {
    var e2, i2, a2 = t3.e, s2 = t3.opt, r2 = this.w, n2 = this.ttCtx, o2 = n2.getElTooltip(), l2 = 0, h2 = 0, c2 = 0, d2 = this.getBarTooltipXY({ e: a2, opt: s2 });
    if (null !== d2.j || 0 !== d2.barHeight || 0 !== d2.barWidth) {
      e2 = d2.i;
      var u2 = d2.j;
      if (r2.globals.capturedSeriesIndex = e2, r2.globals.capturedDataPointIndex = u2, r2.globals.isBarHorizontal &amp;&amp; n2.tooltipUtil.hasBars() || !r2.config.tooltip.shared ? (h2 = d2.x, c2 = d2.y, i2 = Array.isArray(r2.config.stroke.width) ? r2.config.stroke.width[e2] : r2.config.stroke.width, l2 = h2) : r2.globals.comboCharts || r2.config.tooltip.shared || (l2 /= 2), isNaN(c2) &amp;&amp; (c2 = r2.globals.svgHeight - n2.tooltipRect.ttHeight), parseInt(s2.paths.parentNode.getAttribute(&quot;data:realIndex&quot;), 10), h2 + n2.tooltipRect.ttWidth &gt; r2.globals.gridWidth ? h2 -= n2.tooltipRect.ttWidth : h2 &lt; 0 &amp;&amp; (h2 = 0), n2.w.config.tooltip.followCursor) {
        var g2 = n2.getElGrid().getBoundingClientRect();
        c2 = n2.e.clientY - g2.top;
      }
      null === n2.tooltip &amp;&amp; (n2.tooltip = r2.globals.dom.baseEl.querySelector(&quot;.apexcharts-tooltip&quot;)), r2.config.tooltip.shared || (r2.globals.comboBarCount &gt; 0 ? n2.tooltipPosition.moveXCrosshairs(l2 + i2 / 2) : n2.tooltipPosition.moveXCrosshairs(l2)), !n2.fixedTooltip &amp;&amp; (!r2.config.tooltip.shared || r2.globals.isBarHorizontal &amp;&amp; n2.tooltipUtil.hasBars()) &amp;&amp; (c2 = c2 + r2.globals.translateY - n2.tooltipRect.ttHeight / 2, o2.style.left = h2 + r2.globals.translateX + &quot;px&quot;, o2.style.top = c2 + &quot;px&quot;);
    }
  } }, { key: &quot;getBarTooltipXY&quot;, value: function(t3) {
    var e2 = this, i2 = t3.e, a2 = t3.opt, s2 = this.w, r2 = null, n2 = this.ttCtx, o2 = 0, l2 = 0, h2 = 0, c2 = 0, d2 = 0, u2 = i2.target.classList;
    if (u2.contains(&quot;apexcharts-bar-area&quot;) || u2.contains(&quot;apexcharts-candlestick-area&quot;) || u2.contains(&quot;apexcharts-boxPlot-area&quot;) || u2.contains(&quot;apexcharts-rangebar-area&quot;)) {
      var g2 = i2.target, p2 = g2.getBoundingClientRect(), f2 = a2.elGrid.getBoundingClientRect(), x2 = p2.height;
      d2 = p2.height;
      var b2 = p2.width, m2 = parseInt(g2.getAttribute(&quot;cx&quot;), 10), v2 = parseInt(g2.getAttribute(&quot;cy&quot;), 10);
      c2 = parseFloat(g2.getAttribute(&quot;barWidth&quot;));
      var y2 = &quot;touchmove&quot; === i2.type ? i2.touches[0].clientX : i2.clientX;
      r2 = parseInt(g2.getAttribute(&quot;j&quot;), 10), o2 = parseInt(g2.parentNode.getAttribute(&quot;rel&quot;), 10) - 1;
      var w2 = g2.getAttribute(&quot;data-range-y1&quot;), k2 = g2.getAttribute(&quot;data-range-y2&quot;);
      s2.globals.comboCharts &amp;&amp; (o2 = parseInt(g2.parentNode.getAttribute(&quot;data:realIndex&quot;), 10));
      var A2 = function(t4) {
        return s2.globals.isXNumeric ? m2 - b2 / 2 : e2.isVerticalGroupedRangeBar ? m2 + b2 / 2 : m2 - n2.dataPointsDividedWidth + b2 / 2;
      }, C2 = function() {
        return v2 - n2.dataPointsDividedHeight + x2 / 2 - n2.tooltipRect.ttHeight / 2;
      };
      n2.tooltipLabels.drawSeriesTexts({ ttItems: a2.ttItems, i: o2, j: r2, y1: w2 ? parseInt(w2, 10) : null, y2: k2 ? parseInt(k2, 10) : null, shared: !n2.showOnIntersect &amp;&amp; s2.config.tooltip.shared, e: i2 }), s2.config.tooltip.followCursor ? s2.globals.isBarHorizontal ? (l2 = y2 - f2.left + 15, h2 = C2()) : (l2 = A2(), h2 = i2.clientY - f2.top - n2.tooltipRect.ttHeight / 2 - 15) : s2.globals.isBarHorizontal ? ((l2 = m2) &lt; n2.xyRatios.baseLineInvertedY &amp;&amp; (l2 = m2 - n2.tooltipRect.ttWidth), h2 = C2()) : (l2 = A2(), h2 = v2);
    }
    return { x: l2, y: h2, barHeight: d2, barWidth: c2, i: o2, j: r2 };
  } }]), t2;
}();
var Ca = function() {
  function t2(e2) {
    i(this, t2), this.w = e2.w, this.ttCtx = e2;
  }
  return s(t2, [{ key: &quot;drawXaxisTooltip&quot;, value: function() {
    var t3 = this.w, e2 = this.ttCtx, i2 = &quot;bottom&quot; === t3.config.xaxis.position;
    e2.xaxisOffY = i2 ? t3.globals.gridHeight + 1 : -t3.globals.xAxisHeight - t3.config.xaxis.axisTicks.height + 3;
    var a2 = i2 ? &quot;apexcharts-xaxistooltip apexcharts-xaxistooltip-bottom&quot; : &quot;apexcharts-xaxistooltip apexcharts-xaxistooltip-top&quot;, s2 = t3.globals.dom.elWrap;
    e2.isXAxisTooltipEnabled &amp;&amp; (null === t3.globals.dom.baseEl.querySelector(&quot;.apexcharts-xaxistooltip&quot;) &amp;&amp; (e2.xaxisTooltip = document.createElement(&quot;div&quot;), e2.xaxisTooltip.setAttribute(&quot;class&quot;, a2 + &quot; apexcharts-theme-&quot; + t3.config.tooltip.theme), s2.appendChild(e2.xaxisTooltip), e2.xaxisTooltipText = document.createElement(&quot;div&quot;), e2.xaxisTooltipText.classList.add(&quot;apexcharts-xaxistooltip-text&quot;), e2.xaxisTooltipText.style.fontFamily = t3.config.xaxis.tooltip.style.fontFamily || t3.config.chart.fontFamily, e2.xaxisTooltipText.style.fontSize = t3.config.xaxis.tooltip.style.fontSize, e2.xaxisTooltip.appendChild(e2.xaxisTooltipText)));
  } }, { key: &quot;drawYaxisTooltip&quot;, value: function() {
    for (var t3 = this.w, e2 = this.ttCtx, i2 = 0; i2 &lt; t3.config.yaxis.length; i2++) {
      var a2 = t3.config.yaxis[i2].opposite || t3.config.yaxis[i2].crosshairs.opposite;
      e2.yaxisOffX = a2 ? t3.globals.gridWidth + 1 : 1;
      var s2 = &quot;apexcharts-yaxistooltip apexcharts-yaxistooltip-&quot;.concat(i2, a2 ? &quot; apexcharts-yaxistooltip-right&quot; : &quot; apexcharts-yaxistooltip-left&quot;), r2 = t3.globals.dom.elWrap;
      null === t3.globals.dom.baseEl.querySelector(&quot;.apexcharts-yaxistooltip apexcharts-yaxistooltip-&quot;.concat(i2)) &amp;&amp; (e2.yaxisTooltip = document.createElement(&quot;div&quot;), e2.yaxisTooltip.setAttribute(&quot;class&quot;, s2 + &quot; apexcharts-theme-&quot; + t3.config.tooltip.theme), r2.appendChild(e2.yaxisTooltip), 0 === i2 &amp;&amp; (e2.yaxisTooltipText = []), e2.yaxisTooltipText[i2] = document.createElement(&quot;div&quot;), e2.yaxisTooltipText[i2].classList.add(&quot;apexcharts-yaxistooltip-text&quot;), e2.yaxisTooltip.appendChild(e2.yaxisTooltipText[i2]));
    }
  } }, { key: &quot;setXCrosshairWidth&quot;, value: function() {
    var t3 = this.w, e2 = this.ttCtx, i2 = e2.getElXCrosshairs();
    if (e2.xcrosshairsWidth = parseInt(t3.config.xaxis.crosshairs.width, 10), t3.globals.comboCharts) {
      var a2 = t3.globals.dom.baseEl.querySelector(&quot;.apexcharts-bar-area&quot;);
      if (null !== a2 &amp;&amp; &quot;barWidth&quot; === t3.config.xaxis.crosshairs.width) {
        var s2 = parseFloat(a2.getAttribute(&quot;barWidth&quot;));
        e2.xcrosshairsWidth = s2;
      } else if (&quot;tickWidth&quot; === t3.config.xaxis.crosshairs.width) {
        var r2 = t3.globals.labels.length;
        e2.xcrosshairsWidth = t3.globals.gridWidth / r2;
      }
    } else if (&quot;tickWidth&quot; === t3.config.xaxis.crosshairs.width) {
      var n2 = t3.globals.labels.length;
      e2.xcrosshairsWidth = t3.globals.gridWidth / n2;
    } else if (&quot;barWidth&quot; === t3.config.xaxis.crosshairs.width) {
      var o2 = t3.globals.dom.baseEl.querySelector(&quot;.apexcharts-bar-area&quot;);
      if (null !== o2) {
        var l2 = parseFloat(o2.getAttribute(&quot;barWidth&quot;));
        e2.xcrosshairsWidth = l2;
      } else e2.xcrosshairsWidth = 1;
    }
    t3.globals.isBarHorizontal &amp;&amp; (e2.xcrosshairsWidth = 0), null !== i2 &amp;&amp; e2.xcrosshairsWidth &gt; 0 &amp;&amp; i2.setAttribute(&quot;width&quot;, e2.xcrosshairsWidth);
  } }, { key: &quot;handleYCrosshair&quot;, value: function() {
    var t3 = this.w, e2 = this.ttCtx;
    e2.ycrosshairs = t3.globals.dom.baseEl.querySelector(&quot;.apexcharts-ycrosshairs&quot;), e2.ycrosshairsHidden = t3.globals.dom.baseEl.querySelector(&quot;.apexcharts-ycrosshairs-hidden&quot;);
  } }, { key: &quot;drawYaxisTooltipText&quot;, value: function(t3, e2, i2) {
    var a2 = this.ttCtx, s2 = this.w, r2 = s2.globals, n2 = r2.seriesYAxisMap[t3];
    if (a2.yaxisTooltips[t3] &amp;&amp; n2.length &gt; 0) {
      var o2 = r2.yLabelFormatters[t3], l2 = a2.getElGrid().getBoundingClientRect(), h2 = n2[0], c2 = 0;
      i2.yRatio.length &gt; 1 &amp;&amp; (c2 = h2);
      var d2 = (e2 - l2.top) * i2.yRatio[c2], u2 = r2.maxYArr[h2] - r2.minYArr[h2], g2 = r2.minYArr[h2] + (u2 - d2);
      s2.config.yaxis[t3].reversed &amp;&amp; (g2 = r2.maxYArr[h2] - (u2 - d2)), a2.tooltipPosition.moveYCrosshairs(e2 - l2.top), a2.yaxisTooltipText[t3].innerHTML = o2(g2), a2.tooltipPosition.moveYAxisTooltip(t3);
    }
  } }]), t2;
}();
var Sa = function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w;
    var a2 = this.w;
    this.tConfig = a2.config.tooltip, this.tooltipUtil = new va(this), this.tooltipLabels = new ya(this), this.tooltipPosition = new wa(this), this.marker = new ka(this), this.intersect = new Aa(this), this.axesTooltip = new Ca(this), this.showOnIntersect = this.tConfig.intersect, this.showTooltipTitle = this.tConfig.x.show, this.fixedTooltip = this.tConfig.fixed.enabled, this.xaxisTooltip = null, this.yaxisTTEls = null, this.isBarShared = !a2.globals.isBarHorizontal &amp;&amp; this.tConfig.shared, this.lastHoverTime = Date.now();
  }
  return s(t2, [{ key: &quot;getElTooltip&quot;, value: function(t3) {
    return t3 || (t3 = this), t3.w.globals.dom.baseEl ? t3.w.globals.dom.baseEl.querySelector(&quot;.apexcharts-tooltip&quot;) : null;
  } }, { key: &quot;getElXCrosshairs&quot;, value: function() {
    return this.w.globals.dom.baseEl.querySelector(&quot;.apexcharts-xcrosshairs&quot;);
  } }, { key: &quot;getElGrid&quot;, value: function() {
    return this.w.globals.dom.baseEl.querySelector(&quot;.apexcharts-grid&quot;);
  } }, { key: &quot;drawTooltip&quot;, value: function(t3) {
    var e2 = this.w;
    this.xyRatios = t3, this.isXAxisTooltipEnabled = e2.config.xaxis.tooltip.enabled &amp;&amp; e2.globals.axisCharts, this.yaxisTooltips = e2.config.yaxis.map(function(t4, i3) {
      return !!(t4.show &amp;&amp; t4.tooltip.enabled &amp;&amp; e2.globals.axisCharts);
    }), this.allTooltipSeriesGroups = [], e2.globals.axisCharts || (this.showTooltipTitle = false);
    var i2 = document.createElement(&quot;div&quot;);
    if (i2.classList.add(&quot;apexcharts-tooltip&quot;), e2.config.tooltip.cssClass &amp;&amp; i2.classList.add(e2.config.tooltip.cssClass), i2.classList.add(&quot;apexcharts-theme-&quot;.concat(this.tConfig.theme)), e2.globals.dom.elWrap.appendChild(i2), e2.globals.axisCharts) {
      this.axesTooltip.drawXaxisTooltip(), this.axesTooltip.drawYaxisTooltip(), this.axesTooltip.setXCrosshairWidth(), this.axesTooltip.handleYCrosshair();
      var a2 = new Qi(this.ctx);
      this.xAxisTicksPositions = a2.getXAxisTicksPositions();
    }
    if (!e2.globals.comboCharts &amp;&amp; !this.tConfig.intersect &amp;&amp; &quot;rangeBar&quot; !== e2.config.chart.type || this.tConfig.shared || (this.showOnIntersect = true), 0 !== e2.config.markers.size &amp;&amp; 0 !== e2.globals.markers.largestSize || this.marker.drawDynamicPoints(this), e2.globals.collapsedSeries.length !== e2.globals.series.length) {
      this.dataPointsDividedHeight = e2.globals.gridHeight / e2.globals.dataPoints, this.dataPointsDividedWidth = e2.globals.gridWidth / e2.globals.dataPoints, this.showTooltipTitle &amp;&amp; (this.tooltipTitle = document.createElement(&quot;div&quot;), this.tooltipTitle.classList.add(&quot;apexcharts-tooltip-title&quot;), this.tooltipTitle.style.fontFamily = this.tConfig.style.fontFamily || e2.config.chart.fontFamily, this.tooltipTitle.style.fontSize = this.tConfig.style.fontSize, i2.appendChild(this.tooltipTitle));
      var s2 = e2.globals.series.length;
      (e2.globals.xyCharts || e2.globals.comboCharts) &amp;&amp; this.tConfig.shared &amp;&amp; (s2 = this.showOnIntersect ? 1 : e2.globals.series.length), this.legendLabels = e2.globals.dom.baseEl.querySelectorAll(&quot;.apexcharts-legend-text&quot;), this.ttItems = this.createTTElements(s2), this.addSVGEvents();
    }
  } }, { key: &quot;createTTElements&quot;, value: function(t3) {
    for (var e2 = this, i2 = this.w, a2 = [], s2 = this.getElTooltip(), r2 = function(r3) {
      var n3 = document.createElement(&quot;div&quot;);
      n3.classList.add(&quot;apexcharts-tooltip-series-group&quot;, &quot;apexcharts-tooltip-series-group-&quot;.concat(r3)), n3.style.order = i2.config.tooltip.inverseOrder ? t3 - r3 : r3 + 1;
      var o2 = document.createElement(&quot;span&quot;);
      o2.classList.add(&quot;apexcharts-tooltip-marker&quot;), i2.config.tooltip.fillSeriesColor ? o2.style.backgroundColor = i2.globals.colors[r3] : o2.style.color = i2.globals.colors[r3];
      var l2 = i2.config.markers.shape, h2 = l2;
      Array.isArray(l2) &amp;&amp; (h2 = l2[r3]), o2.setAttribute(&quot;shape&quot;, h2), n3.appendChild(o2);
      var c2 = document.createElement(&quot;div&quot;);
      c2.classList.add(&quot;apexcharts-tooltip-text&quot;), c2.style.fontFamily = e2.tConfig.style.fontFamily || i2.config.chart.fontFamily, c2.style.fontSize = e2.tConfig.style.fontSize, [&quot;y&quot;, &quot;goals&quot;, &quot;z&quot;].forEach(function(t4) {
        var e3 = document.createElement(&quot;div&quot;);
        e3.classList.add(&quot;apexcharts-tooltip-&quot;.concat(t4, &quot;-group&quot;));
        var i3 = document.createElement(&quot;span&quot;);
        i3.classList.add(&quot;apexcharts-tooltip-text-&quot;.concat(t4, &quot;-label&quot;)), e3.appendChild(i3);
        var a3 = document.createElement(&quot;span&quot;);
        a3.classList.add(&quot;apexcharts-tooltip-text-&quot;.concat(t4, &quot;-value&quot;)), e3.appendChild(a3), c2.appendChild(e3);
      }), n3.appendChild(c2), s2.appendChild(n3), a2.push(n3);
    }, n2 = 0; n2 &lt; t3; n2++) r2(n2);
    return a2;
  } }, { key: &quot;addSVGEvents&quot;, value: function() {
    var t3 = this.w, e2 = t3.config.chart.type, i2 = this.getElTooltip(), a2 = !(&quot;bar&quot; !== e2 &amp;&amp; &quot;candlestick&quot; !== e2 &amp;&amp; &quot;boxPlot&quot; !== e2 &amp;&amp; &quot;rangeBar&quot; !== e2), s2 = &quot;area&quot; === e2 || &quot;line&quot; === e2 || &quot;scatter&quot; === e2 || &quot;bubble&quot; === e2 || &quot;radar&quot; === e2, r2 = t3.globals.dom.Paper.node, n2 = this.getElGrid();
    n2 &amp;&amp; (this.seriesBound = n2.getBoundingClientRect());
    var o2, l2 = [], h2 = [], c2 = { hoverArea: r2, elGrid: n2, tooltipEl: i2, tooltipY: l2, tooltipX: h2, ttItems: this.ttItems };
    if (t3.globals.axisCharts &amp;&amp; (s2 ? o2 = t3.globals.dom.baseEl.querySelectorAll(&quot;.apexcharts-series[data\\:longestSeries=&#x27;true&#x27;] .apexcharts-marker&quot;) : a2 ? o2 = t3.globals.dom.baseEl.querySelectorAll(&quot;.apexcharts-series .apexcharts-bar-area, .apexcharts-series .apexcharts-candlestick-area, .apexcharts-series .apexcharts-boxPlot-area, .apexcharts-series .apexcharts-rangebar-area&quot;) : &quot;heatmap&quot; !== e2 &amp;&amp; &quot;treemap&quot; !== e2 || (o2 = t3.globals.dom.baseEl.querySelectorAll(&quot;.apexcharts-series .apexcharts-heatmap, .apexcharts-series .apexcharts-treemap&quot;)), o2 &amp;&amp; o2.length)) for (var d2 = 0; d2 &lt; o2.length; d2++) l2.push(o2[d2].getAttribute(&quot;cy&quot;)), h2.push(o2[d2].getAttribute(&quot;cx&quot;));
    if (t3.globals.xyCharts &amp;&amp; !this.showOnIntersect || t3.globals.comboCharts &amp;&amp; !this.showOnIntersect || a2 &amp;&amp; this.tooltipUtil.hasBars() &amp;&amp; this.tConfig.shared) this.addPathsEventListeners([r2], c2);
    else if (a2 &amp;&amp; !t3.globals.comboCharts || s2 &amp;&amp; this.showOnIntersect) this.addDatapointEventsListeners(c2);
    else if (!t3.globals.axisCharts || &quot;heatmap&quot; === e2 || &quot;treemap&quot; === e2) {
      var u2 = t3.globals.dom.baseEl.querySelectorAll(&quot;.apexcharts-series&quot;);
      this.addPathsEventListeners(u2, c2);
    }
    if (this.showOnIntersect) {
      var g2 = t3.globals.dom.baseEl.querySelectorAll(&quot;.apexcharts-line-series .apexcharts-marker, .apexcharts-area-series .apexcharts-marker&quot;);
      g2.length &gt; 0 &amp;&amp; this.addPathsEventListeners(g2, c2), this.tooltipUtil.hasBars() &amp;&amp; !this.tConfig.shared &amp;&amp; this.addDatapointEventsListeners(c2);
    }
  } }, { key: &quot;drawFixedTooltipRect&quot;, value: function() {
    var t3 = this.w, e2 = this.getElTooltip(), i2 = e2.getBoundingClientRect(), a2 = i2.width + 10, s2 = i2.height + 10, r2 = this.tConfig.fixed.offsetX, n2 = this.tConfig.fixed.offsetY, o2 = this.tConfig.fixed.position.toLowerCase();
    return o2.indexOf(&quot;right&quot;) &gt; -1 &amp;&amp; (r2 = r2 + t3.globals.svgWidth - a2 + 10), o2.indexOf(&quot;bottom&quot;) &gt; -1 &amp;&amp; (n2 = n2 + t3.globals.svgHeight - s2 - 10), e2.style.left = r2 + &quot;px&quot;, e2.style.top = n2 + &quot;px&quot;, { x: r2, y: n2, ttWidth: a2, ttHeight: s2 };
  } }, { key: &quot;addDatapointEventsListeners&quot;, value: function(t3) {
    var e2 = this.w.globals.dom.baseEl.querySelectorAll(&quot;.apexcharts-series-markers .apexcharts-marker, .apexcharts-bar-area, .apexcharts-candlestick-area, .apexcharts-boxPlot-area, .apexcharts-rangebar-area&quot;);
    this.addPathsEventListeners(e2, t3);
  } }, { key: &quot;addPathsEventListeners&quot;, value: function(t3, e2) {
    for (var i2 = this, a2 = function(a3) {
      var s3 = { paths: t3[a3], tooltipEl: e2.tooltipEl, tooltipY: e2.tooltipY, tooltipX: e2.tooltipX, elGrid: e2.elGrid, hoverArea: e2.hoverArea, ttItems: e2.ttItems };
      [&quot;mousemove&quot;, &quot;mouseup&quot;, &quot;touchmove&quot;, &quot;mouseout&quot;, &quot;touchend&quot;].map(function(e3) {
        return t3[a3].addEventListener(e3, i2.onSeriesHover.bind(i2, s3), { capture: false, passive: true });
      });
    }, s2 = 0; s2 &lt; t3.length; s2++) a2(s2);
  } }, { key: &quot;onSeriesHover&quot;, value: function(t3, e2) {
    var i2 = this, a2 = Date.now() - this.lastHoverTime;
    a2 &gt;= 20 ? this.seriesHover(t3, e2) : (clearTimeout(this.seriesHoverTimeout), this.seriesHoverTimeout = setTimeout(function() {
      i2.seriesHover(t3, e2);
    }, 20 - a2));
  } }, { key: &quot;seriesHover&quot;, value: function(t3, e2) {
    var i2 = this;
    this.lastHoverTime = Date.now();
    var a2 = [], s2 = this.w;
    s2.config.chart.group &amp;&amp; (a2 = this.ctx.getGroupedCharts()), s2.globals.axisCharts &amp;&amp; (s2.globals.minX === -1 / 0 &amp;&amp; s2.globals.maxX === 1 / 0 || 0 === s2.globals.dataPoints) || (a2.length ? a2.forEach(function(a3) {
      var s3 = i2.getElTooltip(a3), r2 = { paths: t3.paths, tooltipEl: s3, tooltipY: t3.tooltipY, tooltipX: t3.tooltipX, elGrid: t3.elGrid, hoverArea: t3.hoverArea, ttItems: a3.w.globals.tooltip.ttItems };
      a3.w.globals.minX === i2.w.globals.minX &amp;&amp; a3.w.globals.maxX === i2.w.globals.maxX &amp;&amp; a3.w.globals.tooltip.seriesHoverByContext({ chartCtx: a3, ttCtx: a3.w.globals.tooltip, opt: r2, e: e2 });
    }) : this.seriesHoverByContext({ chartCtx: this.ctx, ttCtx: this.w.globals.tooltip, opt: t3, e: e2 }));
  } }, { key: &quot;seriesHoverByContext&quot;, value: function(t3) {
    var e2 = t3.chartCtx, i2 = t3.ttCtx, a2 = t3.opt, s2 = t3.e, r2 = e2.w, n2 = this.getElTooltip(e2);
    if (n2) {
      if (i2.tooltipRect = { x: 0, y: 0, ttWidth: n2.getBoundingClientRect().width, ttHeight: n2.getBoundingClientRect().height }, i2.e = s2, i2.tooltipUtil.hasBars() &amp;&amp; !r2.globals.comboCharts &amp;&amp; !i2.isBarShared) {
        if (this.tConfig.onDatasetHover.highlightDataSeries) new Zi(e2).toggleSeriesOnHover(s2, s2.target.parentNode);
      }
      i2.fixedTooltip &amp;&amp; i2.drawFixedTooltipRect(), r2.globals.axisCharts ? i2.axisChartsTooltips({ e: s2, opt: a2, tooltipRect: i2.tooltipRect }) : i2.nonAxisChartsTooltips({ e: s2, opt: a2, tooltipRect: i2.tooltipRect });
    }
  } }, { key: &quot;axisChartsTooltips&quot;, value: function(t3) {
    var e2, i2, a2 = t3.e, s2 = t3.opt, r2 = this.w, n2 = s2.elGrid.getBoundingClientRect(), o2 = &quot;touchmove&quot; === a2.type ? a2.touches[0].clientX : a2.clientX, l2 = &quot;touchmove&quot; === a2.type ? a2.touches[0].clientY : a2.clientY;
    if (this.clientY = l2, this.clientX = o2, r2.globals.capturedSeriesIndex = -1, r2.globals.capturedDataPointIndex = -1, l2 &lt; n2.top || l2 &gt; n2.top + n2.height) this.handleMouseOut(s2);
    else {
      if (Array.isArray(this.tConfig.enabledOnSeries) &amp;&amp; !r2.config.tooltip.shared) {
        var h2 = parseInt(s2.paths.getAttribute(&quot;index&quot;), 10);
        if (this.tConfig.enabledOnSeries.indexOf(h2) &lt; 0) return void this.handleMouseOut(s2);
      }
      var c2 = this.getElTooltip(), d2 = this.getElXCrosshairs(), u2 = [];
      r2.config.chart.group &amp;&amp; (u2 = this.ctx.getSyncedCharts());
      var g2 = r2.globals.xyCharts || &quot;bar&quot; === r2.config.chart.type &amp;&amp; !r2.globals.isBarHorizontal &amp;&amp; this.tooltipUtil.hasBars() &amp;&amp; this.tConfig.shared || r2.globals.comboCharts &amp;&amp; this.tooltipUtil.hasBars();
      if (&quot;mousemove&quot; === a2.type || &quot;touchmove&quot; === a2.type || &quot;mouseup&quot; === a2.type) {
        if (r2.globals.collapsedSeries.length + r2.globals.ancillaryCollapsedSeries.length === r2.globals.series.length) return;
        null !== d2 &amp;&amp; d2.classList.add(&quot;apexcharts-active&quot;);
        var p2 = this.yaxisTooltips.filter(function(t4) {
          return true === t4;
        });
        if (null !== this.ycrosshairs &amp;&amp; p2.length &amp;&amp; this.ycrosshairs.classList.add(&quot;apexcharts-active&quot;), g2 &amp;&amp; !this.showOnIntersect || u2.length &gt; 1) this.handleStickyTooltip(a2, o2, l2, s2);
        else if (&quot;heatmap&quot; === r2.config.chart.type || &quot;treemap&quot; === r2.config.chart.type) {
          var f2 = this.intersect.handleHeatTreeTooltip({ e: a2, opt: s2, x: e2, y: i2, type: r2.config.chart.type });
          e2 = f2.x, i2 = f2.y, c2.style.left = e2 + &quot;px&quot;, c2.style.top = i2 + &quot;px&quot;;
        } else this.tooltipUtil.hasBars() &amp;&amp; this.intersect.handleBarTooltip({ e: a2, opt: s2 }), this.tooltipUtil.hasMarkers() &amp;&amp; this.intersect.handleMarkerTooltip({ e: a2, opt: s2, x: e2, y: i2 });
        if (this.yaxisTooltips.length) for (var x2 = 0; x2 &lt; r2.config.yaxis.length; x2++) this.axesTooltip.drawYaxisTooltipText(x2, l2, this.xyRatios);
        r2.globals.dom.baseEl.classList.add(&quot;apexcharts-tooltip-active&quot;), s2.tooltipEl.classList.add(&quot;apexcharts-active&quot;);
      } else &quot;mouseout&quot; !== a2.type &amp;&amp; &quot;touchend&quot; !== a2.type || this.handleMouseOut(s2);
    }
  } }, { key: &quot;nonAxisChartsTooltips&quot;, value: function(t3) {
    var e2 = t3.e, i2 = t3.opt, a2 = t3.tooltipRect, s2 = this.w, r2 = i2.paths.getAttribute(&quot;rel&quot;), n2 = this.getElTooltip(), o2 = s2.globals.dom.elWrap.getBoundingClientRect();
    if (&quot;mousemove&quot; === e2.type || &quot;touchmove&quot; === e2.type) {
      s2.globals.dom.baseEl.classList.add(&quot;apexcharts-tooltip-active&quot;), n2.classList.add(&quot;apexcharts-active&quot;), this.tooltipLabels.drawSeriesTexts({ ttItems: i2.ttItems, i: parseInt(r2, 10) - 1, shared: false });
      var l2 = s2.globals.clientX - o2.left - a2.ttWidth / 2, h2 = s2.globals.clientY - o2.top - a2.ttHeight - 10;
      if (n2.style.left = l2 + &quot;px&quot;, n2.style.top = h2 + &quot;px&quot;, s2.config.legend.tooltipHoverFormatter) {
        var c2 = r2 - 1, d2 = (0, s2.config.legend.tooltipHoverFormatter)(this.legendLabels[c2].getAttribute(&quot;data:default-text&quot;), { seriesIndex: c2, dataPointIndex: c2, w: s2 });
        this.legendLabels[c2].innerHTML = d2;
      }
    } else &quot;mouseout&quot; !== e2.type &amp;&amp; &quot;touchend&quot; !== e2.type || (n2.classList.remove(&quot;apexcharts-active&quot;), s2.globals.dom.baseEl.classList.remove(&quot;apexcharts-tooltip-active&quot;), s2.config.legend.tooltipHoverFormatter &amp;&amp; this.legendLabels.forEach(function(t4) {
      var e3 = t4.getAttribute(&quot;data:default-text&quot;);
      t4.innerHTML = decodeURIComponent(e3);
    }));
  } }, { key: &quot;handleStickyTooltip&quot;, value: function(t3, e2, i2, a2) {
    var s2 = this.w, r2 = this.tooltipUtil.getNearestValues({ context: this, hoverArea: a2.hoverArea, elGrid: a2.elGrid, clientX: e2, clientY: i2 }), n2 = r2.j, o2 = r2.capturedSeries;
    s2.globals.collapsedSeriesIndices.includes(o2) &amp;&amp; (o2 = null);
    var l2 = a2.elGrid.getBoundingClientRect();
    if (r2.hoverX &lt; 0 || r2.hoverX &gt; l2.width) this.handleMouseOut(a2);
    else if (null !== o2) this.handleStickyCapturedSeries(t3, o2, a2, n2);
    else if (this.tooltipUtil.isXoverlap(n2) || s2.globals.isBarHorizontal) {
      var h2 = s2.globals.series.findIndex(function(t4, e3) {
        return !s2.globals.collapsedSeriesIndices.includes(e3);
      });
      this.create(t3, this, h2, n2, a2.ttItems);
    }
  } }, { key: &quot;handleStickyCapturedSeries&quot;, value: function(t3, e2, i2, a2) {
    var s2 = this.w;
    if (!this.tConfig.shared &amp;&amp; null === s2.globals.series[e2][a2]) return void this.handleMouseOut(i2);
    if (void 0 !== s2.globals.series[e2][a2]) this.tConfig.shared &amp;&amp; this.tooltipUtil.isXoverlap(a2) &amp;&amp; this.tooltipUtil.isInitialSeriesSameLen() ? this.create(t3, this, e2, a2, i2.ttItems) : this.create(t3, this, e2, a2, i2.ttItems, false);
    else if (this.tooltipUtil.isXoverlap(a2)) {
      var r2 = s2.globals.series.findIndex(function(t4, e3) {
        return !s2.globals.collapsedSeriesIndices.includes(e3);
      });
      this.create(t3, this, r2, a2, i2.ttItems);
    }
  } }, { key: &quot;deactivateHoverFilter&quot;, value: function() {
    for (var t3 = this.w, e2 = new Mi(this.ctx), i2 = t3.globals.dom.Paper.find(&quot;.apexcharts-bar-area&quot;), a2 = 0; a2 &lt; i2.length; a2++) e2.pathMouseLeave(i2[a2]);
  } }, { key: &quot;handleMouseOut&quot;, value: function(t3) {
    var e2 = this.w, i2 = this.getElXCrosshairs();
    if (e2.globals.dom.baseEl.classList.remove(&quot;apexcharts-tooltip-active&quot;), t3.tooltipEl.classList.remove(&quot;apexcharts-active&quot;), this.deactivateHoverFilter(), &quot;bubble&quot; !== e2.config.chart.type &amp;&amp; this.marker.resetPointsSize(), null !== i2 &amp;&amp; i2.classList.remove(&quot;apexcharts-active&quot;), null !== this.ycrosshairs &amp;&amp; this.ycrosshairs.classList.remove(&quot;apexcharts-active&quot;), this.isXAxisTooltipEnabled &amp;&amp; this.xaxisTooltip.classList.remove(&quot;apexcharts-active&quot;), this.yaxisTooltips.length) {
      null === this.yaxisTTEls &amp;&amp; (this.yaxisTTEls = e2.globals.dom.baseEl.querySelectorAll(&quot;.apexcharts-yaxistooltip&quot;));
      for (var a2 = 0; a2 &lt; this.yaxisTTEls.length; a2++) this.yaxisTTEls[a2].classList.remove(&quot;apexcharts-active&quot;);
    }
    e2.config.legend.tooltipHoverFormatter &amp;&amp; this.legendLabels.forEach(function(t4) {
      var e3 = t4.getAttribute(&quot;data:default-text&quot;);
      t4.innerHTML = decodeURIComponent(e3);
    });
  } }, { key: &quot;markerClick&quot;, value: function(t3, e2, i2) {
    var a2 = this.w;
    &quot;function&quot; == typeof a2.config.chart.events.markerClick &amp;&amp; a2.config.chart.events.markerClick(t3, this.ctx, { seriesIndex: e2, dataPointIndex: i2, w: a2 }), this.ctx.events.fireEvent(&quot;markerClick&quot;, [t3, this.ctx, { seriesIndex: e2, dataPointIndex: i2, w: a2 }]);
  } }, { key: &quot;create&quot;, value: function(t3, e2, i2, a2, s2) {
    var r2, n2, o2, l2, h2, c2, d2, g2, p2, f2, x2, b2, m2, v2, y2, w2, k2 = arguments.length &gt; 5 &amp;&amp; void 0 !== arguments[5] ? arguments[5] : null, A2 = this.w, C2 = e2;
    &quot;mouseup&quot; === t3.type &amp;&amp; this.markerClick(t3, i2, a2), null === k2 &amp;&amp; (k2 = this.tConfig.shared);
    var S2 = this.tooltipUtil.hasMarkers(i2), L2 = this.tooltipUtil.getElBars(), M2 = function() {
      A2.globals.markers.largestSize &gt; 0 ? C2.marker.enlargePoints(a2) : C2.tooltipPosition.moveDynamicPointsOnHover(a2);
    };
    if (A2.config.legend.tooltipHoverFormatter) {
      var P2 = A2.config.legend.tooltipHoverFormatter, I2 = Array.from(this.legendLabels);
      I2.forEach(function(t4) {
        var e3 = t4.getAttribute(&quot;data:default-text&quot;);
        t4.innerHTML = decodeURIComponent(e3);
      });
      for (var T2 = 0; T2 &lt; I2.length; T2++) {
        var z2 = I2[T2], X2 = parseInt(z2.getAttribute(&quot;i&quot;), 10), R2 = decodeURIComponent(z2.getAttribute(&quot;data:default-text&quot;)), E2 = P2(R2, { seriesIndex: k2 ? X2 : i2, dataPointIndex: a2, w: A2 });
        if (k2) z2.innerHTML = A2.globals.collapsedSeriesIndices.indexOf(X2) &lt; 0 ? E2 : R2;
        else if (z2.innerHTML = X2 === i2 ? E2 : R2, i2 === X2) break;
      }
    }
    var Y2 = u(u({ ttItems: s2, i: i2, j: a2 }, void 0 !== (null === (r2 = A2.globals.seriesRange) || void 0 === r2 || null === (n2 = r2[i2]) || void 0 === n2 || null === (o2 = n2[a2]) || void 0 === o2 || null === (l2 = o2.y[0]) || void 0 === l2 ? void 0 : l2.y1) &amp;&amp; { y1: null === (h2 = A2.globals.seriesRange) || void 0 === h2 || null === (c2 = h2[i2]) || void 0 === c2 || null === (d2 = c2[a2]) || void 0 === d2 || null === (g2 = d2.y[0]) || void 0 === g2 ? void 0 : g2.y1 }), void 0 !== (null === (p2 = A2.globals.seriesRange) || void 0 === p2 || null === (f2 = p2[i2]) || void 0 === f2 || null === (x2 = f2[a2]) || void 0 === x2 || null === (b2 = x2.y[0]) || void 0 === b2 ? void 0 : b2.y2) &amp;&amp; { y2: null === (m2 = A2.globals.seriesRange) || void 0 === m2 || null === (v2 = m2[i2]) || void 0 === v2 || null === (y2 = v2[a2]) || void 0 === y2 || null === (w2 = y2.y[0]) || void 0 === w2 ? void 0 : w2.y2 });
    if (k2) {
      if (C2.tooltipLabels.drawSeriesTexts(u(u({}, Y2), {}, { shared: !this.showOnIntersect &amp;&amp; this.tConfig.shared })), S2) M2();
      else if (this.tooltipUtil.hasBars() &amp;&amp; (this.barSeriesHeight = this.tooltipUtil.getBarsHeight(L2), this.barSeriesHeight &gt; 0)) {
        var H2 = new Mi(this.ctx), O2 = A2.globals.dom.Paper.find(&quot;.apexcharts-bar-area[j=&#x27;&quot;.concat(a2, &quot;&#x27;]&quot;));
        this.deactivateHoverFilter(), C2.tooltipPosition.moveStickyTooltipOverBars(a2, i2), C2.tooltipUtil.getAllMarkers(true).length &amp;&amp; M2();
        for (var F2 = 0; F2 &lt; O2.length; F2++) H2.pathMouseEnter(O2[F2]);
      }
    } else C2.tooltipLabels.drawSeriesTexts(u({ shared: false }, Y2)), this.tooltipUtil.hasBars() &amp;&amp; C2.tooltipPosition.moveStickyTooltipOverBars(a2, i2), S2 &amp;&amp; C2.tooltipPosition.moveMarkers(i2, a2);
  } }]), t2;
}();
var La = function() {
  function t2(e2) {
    i(this, t2), this.w = e2.w, this.barCtx = e2, this.totalFormatter = this.w.config.plotOptions.bar.dataLabels.total.formatter, this.totalFormatter || (this.totalFormatter = this.w.config.dataLabels.formatter);
  }
  return s(t2, [{ key: &quot;handleBarDataLabels&quot;, value: function(t3) {
    var e2, i2, a2 = t3.x, s2 = t3.y, r2 = t3.y1, n2 = t3.y2, o2 = t3.i, l2 = t3.j, h2 = t3.realIndex, c2 = t3.columnGroupIndex, d2 = t3.series, g2 = t3.barHeight, p2 = t3.barWidth, f2 = t3.barXPosition, x2 = t3.barYPosition, b2 = t3.visibleSeries, m2 = t3.renderedPath, v2 = this.w, y2 = new Mi(this.barCtx.ctx), w2 = Array.isArray(this.barCtx.strokeWidth) ? this.barCtx.strokeWidth[h2] : this.barCtx.strokeWidth;
    v2.globals.isXNumeric &amp;&amp; !v2.globals.isBarHorizontal ? (e2 = a2 + parseFloat(p2 * (b2 + 1)), i2 = s2 + parseFloat(g2 * (b2 + 1)) - w2) : (e2 = a2 + parseFloat(p2 * b2), i2 = s2 + parseFloat(g2 * b2));
    var k2, A2 = null, C2 = a2, S2 = s2, L2 = {}, M2 = v2.config.dataLabels, P2 = this.barCtx.barOptions.dataLabels, I2 = this.barCtx.barOptions.dataLabels.total;
    void 0 !== x2 &amp;&amp; this.barCtx.isRangeBar &amp;&amp; (i2 = x2, S2 = x2), void 0 !== f2 &amp;&amp; this.barCtx.isVerticalGroupedRangeBar &amp;&amp; (e2 = f2, C2 = f2);
    var T2 = M2.offsetX, z2 = M2.offsetY, X2 = { width: 0, height: 0 };
    if (v2.config.dataLabels.enabled) {
      var R2 = v2.globals.series[o2][l2];
      X2 = y2.getTextRects(v2.config.dataLabels.formatter ? v2.config.dataLabels.formatter(R2, u(u({}, v2), {}, { seriesIndex: o2, dataPointIndex: l2, w: v2 })) : v2.globals.yLabelFormatters[0](R2), parseFloat(M2.style.fontSize));
    }
    var E2 = { x: a2, y: s2, i: o2, j: l2, realIndex: h2, columnGroupIndex: c2, renderedPath: m2, bcx: e2, bcy: i2, barHeight: g2, barWidth: p2, textRects: X2, strokeWidth: w2, dataLabelsX: C2, dataLabelsY: S2, dataLabelsConfig: M2, barDataLabelsConfig: P2, barTotalDataLabelsConfig: I2, offX: T2, offY: z2 };
    return L2 = this.barCtx.isHorizontal ? this.calculateBarsDataLabelsPosition(E2) : this.calculateColumnsDataLabelsPosition(E2), m2.attr({ cy: L2.bcy, cx: L2.bcx, j: l2, val: v2.globals.series[o2][l2], barHeight: g2, barWidth: p2 }), k2 = this.drawCalculatedDataLabels({ x: L2.dataLabelsX, y: L2.dataLabelsY, val: this.barCtx.isRangeBar ? [r2, n2] : &quot;100%&quot; === v2.config.chart.stackType ? d2[h2][l2] : v2.globals.series[h2][l2], i: h2, j: l2, barWidth: p2, barHeight: g2, textRects: X2, dataLabelsConfig: M2 }), v2.config.chart.stacked &amp;&amp; I2.enabled &amp;&amp; (A2 = this.drawTotalDataLabels({ x: L2.totalDataLabelsX, y: L2.totalDataLabelsY, barWidth: p2, barHeight: g2, realIndex: h2, textAnchor: L2.totalDataLabelsAnchor, val: this.getStackedTotalDataLabel({ realIndex: h2, j: l2 }), dataLabelsConfig: M2, barTotalDataLabelsConfig: I2 })), { dataLabels: k2, totalDataLabels: A2 };
  } }, { key: &quot;getStackedTotalDataLabel&quot;, value: function(t3) {
    var e2 = t3.realIndex, i2 = t3.j, a2 = this.w, s2 = this.barCtx.stackedSeriesTotals[i2];
    return this.totalFormatter &amp;&amp; (s2 = this.totalFormatter(s2, u(u({}, a2), {}, { seriesIndex: e2, dataPointIndex: i2, w: a2 }))), s2;
  } }, { key: &quot;calculateColumnsDataLabelsPosition&quot;, value: function(t3) {
    var e2 = this, i2 = this.w, a2 = t3.i, s2 = t3.j, r2 = t3.realIndex;
    t3.columnGroupIndex;
    var n2, o2, l2 = t3.y, h2 = t3.bcx, c2 = t3.barWidth, d2 = t3.barHeight, u2 = t3.textRects, g2 = t3.dataLabelsX, p2 = t3.dataLabelsY, f2 = t3.dataLabelsConfig, x2 = t3.barDataLabelsConfig, b2 = t3.barTotalDataLabelsConfig, m2 = t3.strokeWidth, v2 = t3.offX, y2 = t3.offY, w2 = h2;
    d2 = Math.abs(d2);
    var k2 = &quot;vertical&quot; === i2.config.plotOptions.bar.dataLabels.orientation, A2 = this.barCtx.barHelpers.getZeroValueEncounters({ i: a2, j: s2 }).zeroEncounters;
    h2 -= m2 / 2;
    var C2 = i2.globals.gridWidth / i2.globals.dataPoints;
    if (this.barCtx.isVerticalGroupedRangeBar ? g2 += c2 / 2 : (g2 = i2.globals.isXNumeric ? h2 - c2 / 2 + v2 : h2 - C2 + c2 / 2 + v2, !i2.config.chart.stacked &amp;&amp; A2 &gt; 0 &amp;&amp; i2.config.plotOptions.bar.hideZeroBarsWhenGrouped &amp;&amp; (g2 -= c2 * A2)), k2) {
      g2 = g2 + u2.height / 2 - m2 / 2 - 2;
    }
    var S2 = i2.globals.series[a2][s2] &lt; 0, L2 = l2;
    switch (this.barCtx.isReversed &amp;&amp; (L2 = l2 + (S2 ? d2 : -d2)), x2.position) {
      case &quot;center&quot;:
        p2 = k2 ? S2 ? L2 - d2 / 2 + y2 : L2 + d2 / 2 - y2 : S2 ? L2 - d2 / 2 + u2.height / 2 + y2 : L2 + d2 / 2 + u2.height / 2 - y2;
        break;
      case &quot;bottom&quot;:
        p2 = k2 ? S2 ? L2 - d2 + y2 : L2 + d2 - y2 : S2 ? L2 - d2 + u2.height + m2 + y2 : L2 + d2 - u2.height / 2 + m2 - y2;
        break;
      case &quot;top&quot;:
        p2 = k2 ? S2 ? L2 + y2 : L2 - y2 : S2 ? L2 - u2.height / 2 - y2 : L2 + u2.height + y2;
    }
    var M2 = L2;
    if (i2.globals.seriesGroups.forEach(function(t4) {
      var i3;
      null === (i3 = e2.barCtx[t4.join(&quot;,&quot;)]) || void 0 === i3 || i3.prevY.forEach(function(t5) {
        M2 = S2 ? Math.max(t5[s2], M2) : Math.min(t5[s2], M2);
      });
    }), this.barCtx.lastActiveBarSerieIndex === r2 &amp;&amp; b2.enabled) {
      var P2 = new Mi(this.barCtx.ctx).getTextRects(this.getStackedTotalDataLabel({ realIndex: r2, j: s2 }), f2.fontSize);
      n2 = S2 ? M2 - P2.height / 2 - y2 - b2.offsetY + 18 : M2 + P2.height + y2 + b2.offsetY - 18;
      var I2 = C2;
      o2 = w2 + (i2.globals.isXNumeric ? -c2 * i2.globals.barGroups.length / 2 : i2.globals.barGroups.length * c2 / 2 - (i2.globals.barGroups.length - 1) * c2 - I2) + b2.offsetX;
    }
    return i2.config.chart.stacked || (p2 &lt; 0 ? p2 = 0 + m2 : p2 + u2.height / 3 &gt; i2.globals.gridHeight &amp;&amp; (p2 = i2.globals.gridHeight - m2)), { bcx: h2, bcy: l2, dataLabelsX: g2, dataLabelsY: p2, totalDataLabelsX: o2, totalDataLabelsY: n2, totalDataLabelsAnchor: &quot;middle&quot; };
  } }, { key: &quot;calculateBarsDataLabelsPosition&quot;, value: function(t3) {
    var e2 = this, i2 = this.w, a2 = t3.x, s2 = t3.i, r2 = t3.j, n2 = t3.realIndex, o2 = t3.bcy, l2 = t3.barHeight, h2 = t3.barWidth, c2 = t3.textRects, d2 = t3.dataLabelsX, u2 = t3.strokeWidth, g2 = t3.dataLabelsConfig, p2 = t3.barDataLabelsConfig, f2 = t3.barTotalDataLabelsConfig, x2 = t3.offX, b2 = t3.offY, m2 = i2.globals.gridHeight / i2.globals.dataPoints, v2 = this.barCtx.barHelpers.getZeroValueEncounters({ i: s2, j: r2 }).zeroEncounters;
    h2 = Math.abs(h2);
    var y2, w2, k2 = o2 - (this.barCtx.isRangeBar ? 0 : m2) + l2 / 2 + c2.height / 2 + b2 - 3;
    !i2.config.chart.stacked &amp;&amp; v2 &gt; 0 &amp;&amp; i2.config.plotOptions.bar.hideZeroBarsWhenGrouped &amp;&amp; (k2 -= l2 * v2);
    var A2 = &quot;start&quot;, C2 = i2.globals.series[s2][r2] &lt; 0, S2 = a2;
    switch (this.barCtx.isReversed &amp;&amp; (S2 = a2 + (C2 ? -h2 : h2), A2 = C2 ? &quot;start&quot; : &quot;end&quot;), p2.position) {
      case &quot;center&quot;:
        d2 = C2 ? S2 + h2 / 2 - x2 : Math.max(c2.width / 2, S2 - h2 / 2) + x2;
        break;
      case &quot;bottom&quot;:
        d2 = C2 ? S2 + h2 - u2 - x2 : S2 - h2 + u2 + x2;
        break;
      case &quot;top&quot;:
        d2 = C2 ? S2 - u2 - x2 : S2 - u2 + x2;
    }
    var L2 = S2;
    if (i2.globals.seriesGroups.forEach(function(t4) {
      var i3;
      null === (i3 = e2.barCtx[t4.join(&quot;,&quot;)]) || void 0 === i3 || i3.prevX.forEach(function(t5) {
        L2 = C2 ? Math.min(t5[r2], L2) : Math.max(t5[r2], L2);
      });
    }), this.barCtx.lastActiveBarSerieIndex === n2 &amp;&amp; f2.enabled) {
      var M2 = new Mi(this.barCtx.ctx).getTextRects(this.getStackedTotalDataLabel({ realIndex: n2, j: r2 }), g2.fontSize);
      C2 ? (y2 = L2 - u2 - x2 - f2.offsetX, A2 = &quot;end&quot;) : y2 = L2 + x2 + f2.offsetX + (this.barCtx.isReversed ? -(h2 + u2) : u2), w2 = k2 - c2.height / 2 + M2.height / 2 + f2.offsetY + u2, i2.globals.barGroups.length &gt; 1 &amp;&amp; (w2 -= i2.globals.barGroups.length / 2 * (l2 / 2));
    }
    return i2.config.chart.stacked || (&quot;start&quot; === g2.textAnchor ? d2 - c2.width &lt; 0 ? d2 = C2 ? c2.width + u2 : u2 : d2 + c2.width &gt; i2.globals.gridWidth &amp;&amp; (d2 = C2 ? i2.globals.gridWidth - u2 : i2.globals.gridWidth - c2.width - u2) : &quot;middle&quot; === g2.textAnchor ? d2 - c2.width / 2 &lt; 0 ? d2 = c2.width / 2 + u2 : d2 + c2.width / 2 &gt; i2.globals.gridWidth &amp;&amp; (d2 = i2.globals.gridWidth - c2.width / 2 - u2) : &quot;end&quot; === g2.textAnchor &amp;&amp; (d2 &lt; 1 ? d2 = c2.width + u2 : d2 + 1 &gt; i2.globals.gridWidth &amp;&amp; (d2 = i2.globals.gridWidth - c2.width - u2))), { bcx: a2, bcy: o2, dataLabelsX: d2, dataLabelsY: k2, totalDataLabelsX: y2, totalDataLabelsY: w2, totalDataLabelsAnchor: A2 };
  } }, { key: &quot;drawCalculatedDataLabels&quot;, value: function(t3) {
    var e2 = t3.x, i2 = t3.y, a2 = t3.val, s2 = t3.i, r2 = t3.j, n2 = t3.textRects, o2 = t3.barHeight, l2 = t3.barWidth, h2 = t3.dataLabelsConfig, c2 = this.w, d2 = &quot;rotate(0)&quot;;
    &quot;vertical&quot; === c2.config.plotOptions.bar.dataLabels.orientation &amp;&amp; (d2 = &quot;rotate(-90, &quot;.concat(e2, &quot;, &quot;).concat(i2, &quot;)&quot;));
    var g2 = new qi(this.barCtx.ctx), p2 = new Mi(this.barCtx.ctx), f2 = h2.formatter, x2 = null, b2 = c2.globals.collapsedSeriesIndices.indexOf(s2) &gt; -1;
    if (h2.enabled &amp;&amp; !b2) {
      x2 = p2.group({ class: &quot;apexcharts-data-labels&quot;, transform: d2 });
      var m2 = &quot;&quot;;
      void 0 !== a2 &amp;&amp; (m2 = f2(a2, u(u({}, c2), {}, { seriesIndex: s2, dataPointIndex: r2, w: c2 }))), !a2 &amp;&amp; c2.config.plotOptions.bar.hideZeroBarsWhenGrouped &amp;&amp; (m2 = &quot;&quot;);
      var v2 = c2.globals.series[s2][r2] &lt; 0, y2 = c2.config.plotOptions.bar.dataLabels.position;
      if (&quot;vertical&quot; === c2.config.plotOptions.bar.dataLabels.orientation &amp;&amp; (&quot;top&quot; === y2 &amp;&amp; (h2.textAnchor = v2 ? &quot;end&quot; : &quot;start&quot;), &quot;center&quot; === y2 &amp;&amp; (h2.textAnchor = &quot;middle&quot;), &quot;bottom&quot; === y2 &amp;&amp; (h2.textAnchor = v2 ? &quot;end&quot; : &quot;start&quot;)), this.barCtx.isRangeBar &amp;&amp; this.barCtx.barOptions.dataLabels.hideOverflowingLabels) l2 &lt; p2.getTextRects(m2, parseFloat(h2.style.fontSize)).width &amp;&amp; (m2 = &quot;&quot;);
      c2.config.chart.stacked &amp;&amp; this.barCtx.barOptions.dataLabels.hideOverflowingLabels &amp;&amp; (this.barCtx.isHorizontal ? n2.width / 1.6 &gt; Math.abs(l2) &amp;&amp; (m2 = &quot;&quot;) : n2.height / 1.6 &gt; Math.abs(o2) &amp;&amp; (m2 = &quot;&quot;));
      var w2 = u({}, h2);
      this.barCtx.isHorizontal &amp;&amp; a2 &lt; 0 &amp;&amp; (&quot;start&quot; === h2.textAnchor ? w2.textAnchor = &quot;end&quot; : &quot;end&quot; === h2.textAnchor &amp;&amp; (w2.textAnchor = &quot;start&quot;)), g2.plotDataLabelsText({ x: e2, y: i2, text: m2, i: s2, j: r2, parent: x2, dataLabelsConfig: w2, alwaysDrawDataLabel: true, offsetCorrection: true });
    }
    return x2;
  } }, { key: &quot;drawTotalDataLabels&quot;, value: function(t3) {
    var e2 = t3.x, i2 = t3.y, a2 = t3.val, s2 = t3.realIndex, r2 = t3.textAnchor, n2 = t3.barTotalDataLabelsConfig;
    this.w;
    var o2, l2 = new Mi(this.barCtx.ctx);
    return n2.enabled &amp;&amp; void 0 !== e2 &amp;&amp; void 0 !== i2 &amp;&amp; this.barCtx.lastActiveBarSerieIndex === s2 &amp;&amp; (o2 = l2.drawText({ x: e2, y: i2, foreColor: n2.style.color, text: a2, textAnchor: r2, fontFamily: n2.style.fontFamily, fontSize: n2.style.fontSize, fontWeight: n2.style.fontWeight })), o2;
  } }]), t2;
}();
var Ma = function() {
  function t2(e2) {
    i(this, t2), this.w = e2.w, this.barCtx = e2;
  }
  return s(t2, [{ key: &quot;initVariables&quot;, value: function(t3) {
    var e2 = this.w;
    this.barCtx.series = t3, this.barCtx.totalItems = 0, this.barCtx.seriesLen = 0, this.barCtx.visibleI = -1, this.barCtx.visibleItems = 1;
    for (var i2 = 0; i2 &lt; t3.length; i2++) if (t3[i2].length &gt; 0 &amp;&amp; (this.barCtx.seriesLen = this.barCtx.seriesLen + 1, this.barCtx.totalItems += t3[i2].length), e2.globals.isXNumeric) for (var a2 = 0; a2 &lt; t3[i2].length; a2++) e2.globals.seriesX[i2][a2] &gt; e2.globals.minX &amp;&amp; e2.globals.seriesX[i2][a2] &lt; e2.globals.maxX &amp;&amp; this.barCtx.visibleItems++;
    else this.barCtx.visibleItems = e2.globals.dataPoints;
    this.arrBorderRadius = this.createBorderRadiusArr(e2.globals.series), 0 === this.barCtx.seriesLen &amp;&amp; (this.barCtx.seriesLen = 1), this.barCtx.zeroSerieses = [], e2.globals.comboCharts || this.checkZeroSeries({ series: t3 });
  } }, { key: &quot;initialPositions&quot;, value: function(t3) {
    var e2, i2, a2, s2, r2, n2, o2, l2, h2 = this.w, c2 = h2.globals.dataPoints;
    this.barCtx.isRangeBar &amp;&amp; (c2 = h2.globals.labels.length);
    var d2 = this.barCtx.seriesLen;
    if (h2.config.plotOptions.bar.rangeBarGroupRows &amp;&amp; (d2 = 1), this.barCtx.isHorizontal) r2 = (a2 = h2.globals.gridHeight / c2) / d2, h2.globals.isXNumeric &amp;&amp; (r2 = (a2 = h2.globals.gridHeight / this.barCtx.totalItems) / this.barCtx.seriesLen), r2 = r2 * parseInt(this.barCtx.barOptions.barHeight, 10) / 100, -1 === String(this.barCtx.barOptions.barHeight).indexOf(&quot;%&quot;) &amp;&amp; (r2 = parseInt(this.barCtx.barOptions.barHeight, 10)), l2 = this.barCtx.baseLineInvertedY + h2.globals.padHorizontal + (this.barCtx.isReversed ? h2.globals.gridWidth : 0) - (this.barCtx.isReversed ? 2 * this.barCtx.baseLineInvertedY : 0), this.barCtx.isFunnel &amp;&amp; (l2 = h2.globals.gridWidth / 2), i2 = (a2 - r2 * this.barCtx.seriesLen) / 2;
    else {
      if (s2 = h2.globals.gridWidth / this.barCtx.visibleItems, h2.config.xaxis.convertedCatToNumeric &amp;&amp; (s2 = h2.globals.gridWidth / h2.globals.dataPoints), n2 = s2 / d2 * parseInt(this.barCtx.barOptions.columnWidth, 10) / 100, h2.globals.isXNumeric) {
        var u2 = this.barCtx.xRatio;
        h2.globals.minXDiff &amp;&amp; 0.5 !== h2.globals.minXDiff &amp;&amp; h2.globals.minXDiff / u2 &gt; 0 &amp;&amp; (s2 = h2.globals.minXDiff / u2), (n2 = s2 / d2 * parseInt(this.barCtx.barOptions.columnWidth, 10) / 100) &lt; 1 &amp;&amp; (n2 = 1);
      }
      if (-1 === String(this.barCtx.barOptions.columnWidth).indexOf(&quot;%&quot;) &amp;&amp; (n2 = parseInt(this.barCtx.barOptions.columnWidth, 10)), o2 = h2.globals.gridHeight - this.barCtx.baseLineY[this.barCtx.translationsIndex] - (this.barCtx.isReversed ? h2.globals.gridHeight : 0) + (this.barCtx.isReversed ? 2 * this.barCtx.baseLineY[this.barCtx.translationsIndex] : 0), h2.globals.isXNumeric) e2 = this.barCtx.getBarXForNumericXAxis({ x: e2, j: 0, realIndex: t3, barWidth: n2 }).x;
      else e2 = h2.globals.padHorizontal + v.noExponents(s2 - n2 * this.barCtx.seriesLen) / 2;
    }
    return h2.globals.barHeight = r2, h2.globals.barWidth = n2, { x: e2, y: i2, yDivision: a2, xDivision: s2, barHeight: r2, barWidth: n2, zeroH: o2, zeroW: l2 };
  } }, { key: &quot;initializeStackedPrevVars&quot;, value: function(t3) {
    t3.w.globals.seriesGroups.forEach(function(e2) {
      t3[e2] || (t3[e2] = {}), t3[e2].prevY = [], t3[e2].prevX = [], t3[e2].prevYF = [], t3[e2].prevXF = [], t3[e2].prevYVal = [], t3[e2].prevXVal = [];
    });
  } }, { key: &quot;initializeStackedXYVars&quot;, value: function(t3) {
    t3.w.globals.seriesGroups.forEach(function(e2) {
      t3[e2] || (t3[e2] = {}), t3[e2].xArrj = [], t3[e2].xArrjF = [], t3[e2].xArrjVal = [], t3[e2].yArrj = [], t3[e2].yArrjF = [], t3[e2].yArrjVal = [];
    });
  } }, { key: &quot;getPathFillColor&quot;, value: function(t3, e2, i2, a2) {
    var s2, r2, n2, o2, l2 = this.w, h2 = this.barCtx.ctx.fill, c2 = null, d2 = this.barCtx.barOptions.distributed ? i2 : e2, u2 = false;
    this.barCtx.barOptions.colors.ranges.length &gt; 0 &amp;&amp; this.barCtx.barOptions.colors.ranges.map(function(a3) {
      t3[e2][i2] &gt;= a3.from &amp;&amp; t3[e2][i2] &lt;= a3.to &amp;&amp; (c2 = a3.color, u2 = true);
    });
    return { color: h2.fillPath({ seriesNumber: this.barCtx.barOptions.distributed ? d2 : a2, dataPointIndex: i2, color: c2, value: t3[e2][i2], fillConfig: null === (s2 = l2.config.series[e2].data[i2]) || void 0 === s2 ? void 0 : s2.fill, fillType: null !== (r2 = l2.config.series[e2].data[i2]) &amp;&amp; void 0 !== r2 &amp;&amp; null !== (n2 = r2.fill) &amp;&amp; void 0 !== n2 &amp;&amp; n2.type ? null === (o2 = l2.config.series[e2].data[i2]) || void 0 === o2 ? void 0 : o2.fill.type : Array.isArray(l2.config.fill.type) ? l2.config.fill.type[a2] : l2.config.fill.type }), useRangeColor: u2 };
  } }, { key: &quot;getStrokeWidth&quot;, value: function(t3, e2, i2) {
    var a2 = 0, s2 = this.w;
    return this.barCtx.series[t3][e2] ? this.barCtx.isNullValue = false : this.barCtx.isNullValue = true, s2.config.stroke.show &amp;&amp; (this.barCtx.isNullValue || (a2 = Array.isArray(this.barCtx.strokeWidth) ? this.barCtx.strokeWidth[i2] : this.barCtx.strokeWidth)), a2;
  } }, { key: &quot;createBorderRadiusArr&quot;, value: function(t3) {
    var e2, i2 = this.w, a2 = !this.w.config.chart.stacked || i2.config.plotOptions.bar.borderRadius &lt;= 0, s2 = t3.length, n2 = 0 | (null === (e2 = t3[0]) || void 0 === e2 ? void 0 : e2.length), o2 = Array.from({ length: s2 }, function() {
      return Array(n2).fill(a2 ? &quot;top&quot; : &quot;none&quot;);
    });
    if (a2) return o2;
    for (var l2 = 0; l2 &lt; n2; l2++) {
      for (var h2 = [], c2 = [], d2 = 0, u2 = 0; u2 &lt; s2; u2++) {
        var g2 = t3[u2][l2];
        g2 &gt; 0 ? (h2.push(u2), d2++) : g2 &lt; 0 &amp;&amp; (c2.push(u2), d2++);
      }
      if (h2.length &gt; 0 &amp;&amp; 0 === c2.length) if (1 === h2.length) o2[h2[0]][l2] = &quot;both&quot;;
      else {
        var p2, f2 = h2[0], x2 = h2[h2.length - 1], b2 = r(h2);
        try {
          for (b2.s(); !(p2 = b2.n()).done; ) {
            var m2 = p2.value;
            o2[m2][l2] = m2 === f2 ? &quot;bottom&quot; : m2 === x2 ? &quot;top&quot; : &quot;none&quot;;
          }
        } catch (t4) {
          b2.e(t4);
        } finally {
          b2.f();
        }
      }
      else if (c2.length &gt; 0 &amp;&amp; 0 === h2.length) if (1 === c2.length) o2[c2[0]][l2] = &quot;both&quot;;
      else {
        var v2, y2 = Math.max.apply(Math, c2), w2 = Math.min.apply(Math, c2), k2 = r(c2);
        try {
          for (k2.s(); !(v2 = k2.n()).done; ) {
            var A2 = v2.value;
            o2[A2][l2] = A2 === y2 ? &quot;bottom&quot; : A2 === w2 ? &quot;top&quot; : &quot;none&quot;;
          }
        } catch (t4) {
          k2.e(t4);
        } finally {
          k2.f();
        }
      }
      else if (h2.length &gt; 0 &amp;&amp; c2.length &gt; 0) {
        var C2, S2 = h2[h2.length - 1], L2 = r(h2);
        try {
          for (L2.s(); !(C2 = L2.n()).done; ) {
            var M2 = C2.value;
            o2[M2][l2] = M2 === S2 ? &quot;top&quot; : &quot;none&quot;;
          }
        } catch (t4) {
          L2.e(t4);
        } finally {
          L2.f();
        }
        var P2, I2 = Math.max.apply(Math, c2), T2 = r(c2);
        try {
          for (T2.s(); !(P2 = T2.n()).done; ) {
            var z2 = P2.value;
            o2[z2][l2] = z2 === I2 ? &quot;bottom&quot; : &quot;none&quot;;
          }
        } catch (t4) {
          T2.e(t4);
        } finally {
          T2.f();
        }
      } else if (1 === d2) {
        o2[h2[0] || c2[0]][l2] = &quot;both&quot;;
      }
    }
    return o2;
  } }, { key: &quot;barBackground&quot;, value: function(t3) {
    var e2 = t3.j, i2 = t3.i, a2 = t3.x1, s2 = t3.x2, r2 = t3.y1, n2 = t3.y2, o2 = t3.elSeries, l2 = this.w, h2 = new Mi(this.barCtx.ctx), c2 = new Zi(this.barCtx.ctx).getActiveConfigSeriesIndex();
    if (this.barCtx.barOptions.colors.backgroundBarColors.length &gt; 0 &amp;&amp; c2 === i2) {
      e2 &gt;= this.barCtx.barOptions.colors.backgroundBarColors.length &amp;&amp; (e2 %= this.barCtx.barOptions.colors.backgroundBarColors.length);
      var d2 = this.barCtx.barOptions.colors.backgroundBarColors[e2], u2 = h2.drawRect(void 0 !== a2 ? a2 : 0, void 0 !== r2 ? r2 : 0, void 0 !== s2 ? s2 : l2.globals.gridWidth, void 0 !== n2 ? n2 : l2.globals.gridHeight, this.barCtx.barOptions.colors.backgroundBarRadius, d2, this.barCtx.barOptions.colors.backgroundBarOpacity);
      o2.add(u2), u2.node.classList.add(&quot;apexcharts-backgroundBar&quot;);
    }
  } }, { key: &quot;getColumnPaths&quot;, value: function(t3) {
    var e2, i2 = t3.barWidth, a2 = t3.barXPosition, s2 = t3.y1, r2 = t3.y2, n2 = t3.strokeWidth, o2 = t3.isReversed, l2 = t3.series, h2 = t3.seriesGroup, c2 = t3.realIndex, d2 = t3.i, u2 = t3.j, g2 = t3.w, p2 = new Mi(this.barCtx.ctx);
    (n2 = Array.isArray(n2) ? n2[c2] : n2) || (n2 = 0);
    var f2 = i2, x2 = a2;
    null !== (e2 = g2.config.series[c2].data[u2]) &amp;&amp; void 0 !== e2 &amp;&amp; e2.columnWidthOffset &amp;&amp; (x2 = a2 - g2.config.series[c2].data[u2].columnWidthOffset / 2, f2 = i2 + g2.config.series[c2].data[u2].columnWidthOffset);
    var b2 = n2 / 2, m2 = x2 + b2, v2 = x2 + f2 - b2, y2 = (l2[d2][u2] &gt;= 0 ? 1 : -1) * (o2 ? -1 : 1);
    s2 += 1e-3 - b2 * y2, r2 += 1e-3 + b2 * y2;
    var w2 = p2.move(m2, s2), k2 = p2.move(m2, s2), A2 = p2.line(v2, s2);
    if (g2.globals.previousPaths.length &gt; 0 &amp;&amp; (k2 = this.barCtx.getPreviousPath(c2, u2, false)), w2 = w2 + p2.line(m2, r2) + p2.line(v2, r2) + A2 + (&quot;around&quot; === g2.config.plotOptions.bar.borderRadiusApplication || &quot;both&quot; === this.arrBorderRadius[c2][u2] ? &quot; Z&quot; : &quot; z&quot;), k2 = k2 + p2.line(m2, s2) + A2 + A2 + A2 + A2 + A2 + p2.line(m2, s2) + (&quot;around&quot; === g2.config.plotOptions.bar.borderRadiusApplication || &quot;both&quot; === this.arrBorderRadius[c2][u2] ? &quot; Z&quot; : &quot; z&quot;), &quot;none&quot; !== this.arrBorderRadius[c2][u2] &amp;&amp; (w2 = p2.roundPathCorners(w2, g2.config.plotOptions.bar.borderRadius)), g2.config.chart.stacked) {
      var C2 = this.barCtx;
      (C2 = this.barCtx[h2]).yArrj.push(r2 - b2 * y2), C2.yArrjF.push(Math.abs(s2 - r2 + n2 * y2)), C2.yArrjVal.push(this.barCtx.series[d2][u2]);
    }
    return { pathTo: w2, pathFrom: k2 };
  } }, { key: &quot;getBarpaths&quot;, value: function(t3) {
    var e2, i2 = t3.barYPosition, a2 = t3.barHeight, s2 = t3.x1, r2 = t3.x2, n2 = t3.strokeWidth, o2 = t3.isReversed, l2 = t3.series, h2 = t3.seriesGroup, c2 = t3.realIndex, d2 = t3.i, u2 = t3.j, g2 = t3.w, p2 = new Mi(this.barCtx.ctx);
    (n2 = Array.isArray(n2) ? n2[c2] : n2) || (n2 = 0);
    var f2 = i2, x2 = a2;
    null !== (e2 = g2.config.series[c2].data[u2]) &amp;&amp; void 0 !== e2 &amp;&amp; e2.barHeightOffset &amp;&amp; (f2 = i2 - g2.config.series[c2].data[u2].barHeightOffset / 2, x2 = a2 + g2.config.series[c2].data[u2].barHeightOffset);
    var b2 = n2 / 2, m2 = f2 + b2, v2 = f2 + x2 - b2, y2 = (l2[d2][u2] &gt;= 0 ? 1 : -1) * (o2 ? -1 : 1);
    s2 += 1e-3 + b2 * y2, r2 += 1e-3 - b2 * y2;
    var w2 = p2.move(s2, m2), k2 = p2.move(s2, m2);
    g2.globals.previousPaths.length &gt; 0 &amp;&amp; (k2 = this.barCtx.getPreviousPath(c2, u2, false));
    var A2 = p2.line(s2, v2);
    if (w2 = w2 + p2.line(r2, m2) + p2.line(r2, v2) + A2 + (&quot;around&quot; === g2.config.plotOptions.bar.borderRadiusApplication || &quot;both&quot; === this.arrBorderRadius[c2][u2] ? &quot; Z&quot; : &quot; z&quot;), k2 = k2 + p2.line(s2, m2) + A2 + A2 + A2 + A2 + A2 + p2.line(s2, m2) + (&quot;around&quot; === g2.config.plotOptions.bar.borderRadiusApplication || &quot;both&quot; === this.arrBorderRadius[c2][u2] ? &quot; Z&quot; : &quot; z&quot;), &quot;none&quot; !== this.arrBorderRadius[c2][u2] &amp;&amp; (w2 = p2.roundPathCorners(w2, g2.config.plotOptions.bar.borderRadius)), g2.config.chart.stacked) {
      var C2 = this.barCtx;
      (C2 = this.barCtx[h2]).xArrj.push(r2 + b2 * y2), C2.xArrjF.push(Math.abs(s2 - r2 - n2 * y2)), C2.xArrjVal.push(this.barCtx.series[d2][u2]);
    }
    return { pathTo: w2, pathFrom: k2 };
  } }, { key: &quot;checkZeroSeries&quot;, value: function(t3) {
    for (var e2 = t3.series, i2 = this.w, a2 = 0; a2 &lt; e2.length; a2++) {
      for (var s2 = 0, r2 = 0; r2 &lt; e2[i2.globals.maxValsInArrayIndex].length; r2++) s2 += e2[a2][r2];
      0 === s2 &amp;&amp; this.barCtx.zeroSerieses.push(a2);
    }
  } }, { key: &quot;getXForValue&quot;, value: function(t3, e2) {
    var i2 = !(arguments.length &gt; 2 &amp;&amp; void 0 !== arguments[2]) || arguments[2] ? e2 : null;
    return null != t3 &amp;&amp; (i2 = e2 + t3 / this.barCtx.invertedYRatio - 2 * (this.barCtx.isReversed ? t3 / this.barCtx.invertedYRatio : 0)), i2;
  } }, { key: &quot;getYForValue&quot;, value: function(t3, e2, i2) {
    var a2 = !(arguments.length &gt; 3 &amp;&amp; void 0 !== arguments[3]) || arguments[3] ? e2 : null;
    return null != t3 &amp;&amp; (a2 = e2 - t3 / this.barCtx.yRatio[i2] + 2 * (this.barCtx.isReversed ? t3 / this.barCtx.yRatio[i2] : 0)), a2;
  } }, { key: &quot;getGoalValues&quot;, value: function(t3, e2, i2, a2, s2, r2) {
    var n2 = this, l2 = this.w, h2 = [], c2 = function(a3, s3) {
      var l3;
      h2.push((o(l3 = {}, t3, &quot;x&quot; === t3 ? n2.getXForValue(a3, e2, false) : n2.getYForValue(a3, i2, r2, false)), o(l3, &quot;attrs&quot;, s3), l3));
    };
    if (l2.globals.seriesGoals[a2] &amp;&amp; l2.globals.seriesGoals[a2][s2] &amp;&amp; Array.isArray(l2.globals.seriesGoals[a2][s2]) &amp;&amp; l2.globals.seriesGoals[a2][s2].forEach(function(t4) {
      c2(t4.value, t4);
    }), this.barCtx.barOptions.isDumbbell &amp;&amp; l2.globals.seriesRange.length) {
      var d2 = this.barCtx.barOptions.dumbbellColors ? this.barCtx.barOptions.dumbbellColors : l2.globals.colors, g2 = { strokeHeight: &quot;x&quot; === t3 ? 0 : l2.globals.markers.size[a2], strokeWidth: &quot;x&quot; === t3 ? l2.globals.markers.size[a2] : 0, strokeDashArray: 0, strokeLineCap: &quot;round&quot;, strokeColor: Array.isArray(d2[a2]) ? d2[a2][0] : d2[a2] };
      c2(l2.globals.seriesRangeStart[a2][s2], g2), c2(l2.globals.seriesRangeEnd[a2][s2], u(u({}, g2), {}, { strokeColor: Array.isArray(d2[a2]) ? d2[a2][1] : d2[a2] }));
    }
    return h2;
  } }, { key: &quot;drawGoalLine&quot;, value: function(t3) {
    var e2 = t3.barXPosition, i2 = t3.barYPosition, a2 = t3.goalX, s2 = t3.goalY, r2 = t3.barWidth, n2 = t3.barHeight, o2 = new Mi(this.barCtx.ctx), l2 = o2.group({ className: &quot;apexcharts-bar-goals-groups&quot; });
    l2.node.classList.add(&quot;apexcharts-element-hidden&quot;), this.barCtx.w.globals.delayedElements.push({ el: l2.node }), l2.attr(&quot;clip-path&quot;, &quot;url(#gridRectMarkerMask&quot;.concat(this.barCtx.w.globals.cuid, &quot;)&quot;));
    var h2 = null;
    return this.barCtx.isHorizontal ? Array.isArray(a2) &amp;&amp; a2.forEach(function(t4) {
      if (t4.x &gt;= -1 &amp;&amp; t4.x &lt;= o2.w.globals.gridWidth + 1) {
        var e3 = void 0 !== t4.attrs.strokeHeight ? t4.attrs.strokeHeight : n2 / 2, a3 = i2 + e3 + n2 / 2;
        h2 = o2.drawLine(t4.x, a3 - 2 * e3, t4.x, a3, t4.attrs.strokeColor ? t4.attrs.strokeColor : void 0, t4.attrs.strokeDashArray, t4.attrs.strokeWidth ? t4.attrs.strokeWidth : 2, t4.attrs.strokeLineCap), l2.add(h2);
      }
    }) : Array.isArray(s2) &amp;&amp; s2.forEach(function(t4) {
      if (t4.y &gt;= -1 &amp;&amp; t4.y &lt;= o2.w.globals.gridHeight + 1) {
        var i3 = void 0 !== t4.attrs.strokeWidth ? t4.attrs.strokeWidth : r2 / 2, a3 = e2 + i3 + r2 / 2;
        h2 = o2.drawLine(a3 - 2 * i3, t4.y, a3, t4.y, t4.attrs.strokeColor ? t4.attrs.strokeColor : void 0, t4.attrs.strokeDashArray, t4.attrs.strokeHeight ? t4.attrs.strokeHeight : 2, t4.attrs.strokeLineCap), l2.add(h2);
      }
    }), l2;
  } }, { key: &quot;drawBarShadow&quot;, value: function(t3) {
    var e2 = t3.prevPaths, i2 = t3.currPaths, a2 = t3.color, s2 = this.w, r2 = e2.x, n2 = e2.x1, o2 = e2.barYPosition, l2 = i2.x, h2 = i2.x1, c2 = i2.barYPosition, d2 = o2 + i2.barHeight, u2 = new Mi(this.barCtx.ctx), g2 = new v(), p2 = u2.move(n2, d2) + u2.line(r2, d2) + u2.line(l2, c2) + u2.line(h2, c2) + u2.line(n2, d2) + (&quot;around&quot; === s2.config.plotOptions.bar.borderRadiusApplication || &quot;both&quot; === this.arrBorderRadius[realIndex][j] ? &quot; Z&quot; : &quot; z&quot;);
    return u2.drawPath({ d: p2, fill: g2.shadeColor(0.5, v.rgb2hex(a2)), stroke: &quot;none&quot;, strokeWidth: 0, fillOpacity: 1, classes: &quot;apexcharts-bar-shadow apexcharts-decoration-element&quot; });
  } }, { key: &quot;getZeroValueEncounters&quot;, value: function(t3) {
    var e2, i2 = t3.i, a2 = t3.j, s2 = this.w, r2 = 0, n2 = 0;
    return (s2.config.plotOptions.bar.horizontal ? s2.globals.series.map(function(t4, e3) {
      return e3;
    }) : (null === (e2 = s2.globals.columnSeries) || void 0 === e2 ? void 0 : e2.i.map(function(t4) {
      return t4;
    })) || []).forEach(function(t4) {
      var e3 = s2.globals.seriesPercent[t4][a2];
      e3 &amp;&amp; r2++, t4 &lt; i2 &amp;&amp; 0 === e3 &amp;&amp; n2++;
    }), { nonZeroColumns: r2, zeroEncounters: n2 };
  } }, { key: &quot;getGroupIndex&quot;, value: function(t3) {
    var e2 = this.w, i2 = e2.globals.seriesGroups.findIndex(function(i3) {
      return i3.indexOf(e2.globals.seriesNames[t3]) &gt; -1;
    }), a2 = this.barCtx.columnGroupIndices, s2 = a2.indexOf(i2);
    return s2 &lt; 0 &amp;&amp; (a2.push(i2), s2 = a2.length - 1), { groupIndex: i2, columnGroupIndex: s2 };
  } }]), t2;
}();
var Pa = function() {
  function t2(e2, a2) {
    i(this, t2), this.ctx = e2, this.w = e2.w;
    var s2 = this.w;
    this.barOptions = s2.config.plotOptions.bar, this.isHorizontal = this.barOptions.horizontal, this.strokeWidth = s2.config.stroke.width, this.isNullValue = false, this.isRangeBar = s2.globals.seriesRange.length &amp;&amp; this.isHorizontal, this.isVerticalGroupedRangeBar = !s2.globals.isBarHorizontal &amp;&amp; s2.globals.seriesRange.length &amp;&amp; s2.config.plotOptions.bar.rangeBarGroupRows, this.isFunnel = this.barOptions.isFunnel, this.xyRatios = a2, null !== this.xyRatios &amp;&amp; (this.xRatio = a2.xRatio, this.yRatio = a2.yRatio, this.invertedXRatio = a2.invertedXRatio, this.invertedYRatio = a2.invertedYRatio, this.baseLineY = a2.baseLineY, this.baseLineInvertedY = a2.baseLineInvertedY), this.yaxisIndex = 0, this.translationsIndex = 0, this.seriesLen = 0, this.pathArr = [];
    var r2 = new Zi(this.ctx);
    this.lastActiveBarSerieIndex = r2.getActiveConfigSeriesIndex(&quot;desc&quot;, [&quot;bar&quot;, &quot;column&quot;]), this.columnGroupIndices = [];
    var n2 = r2.getBarSeriesIndices(), o2 = new Pi(this.ctx);
    this.stackedSeriesTotals = o2.getStackedSeriesTotals(this.w.config.series.map(function(t3, e3) {
      return -1 === n2.indexOf(e3) ? e3 : -1;
    }).filter(function(t3) {
      return -1 !== t3;
    })), this.barHelpers = new Ma(this);
  }
  return s(t2, [{ key: &quot;draw&quot;, value: function(t3, e2) {
    var i2 = this.w, a2 = new Mi(this.ctx), s2 = new Pi(this.ctx, i2);
    t3 = s2.getLogSeries(t3), this.series = t3, this.yRatio = s2.getLogYRatios(this.yRatio), this.barHelpers.initVariables(t3);
    var r2 = a2.group({ class: &quot;apexcharts-bar-series apexcharts-plot-series&quot; });
    i2.config.dataLabels.enabled &amp;&amp; this.totalItems &gt; this.barOptions.dataLabels.maxItems &amp;&amp; console.warn(&quot;WARNING: DataLabels are enabled but there are too many to display. This may cause performance issue when rendering - ApexCharts&quot;);
    for (var n2 = 0, o2 = 0; n2 &lt; t3.length; n2++, o2++) {
      var l2, h2, c2, d2, g2 = void 0, p2 = void 0, f2 = [], x2 = [], b2 = i2.globals.comboCharts ? e2[n2] : n2, m2 = this.barHelpers.getGroupIndex(b2).columnGroupIndex, y2 = a2.group({ class: &quot;apexcharts-series&quot;, rel: n2 + 1, seriesName: v.escapeString(i2.globals.seriesNames[b2]), &quot;data:realIndex&quot;: b2 });
      this.ctx.series.addCollapsedClassToSeries(y2, b2), t3[n2].length &gt; 0 &amp;&amp; (this.visibleI = this.visibleI + 1);
      var w2 = 0, k2 = 0;
      this.yRatio.length &gt; 1 &amp;&amp; (this.yaxisIndex = i2.globals.seriesYAxisReverseMap[b2], this.translationsIndex = b2);
      var A2 = this.translationsIndex;
      this.isReversed = i2.config.yaxis[this.yaxisIndex] &amp;&amp; i2.config.yaxis[this.yaxisIndex].reversed;
      var C2 = this.barHelpers.initialPositions(b2);
      p2 = C2.y, w2 = C2.barHeight, h2 = C2.yDivision, d2 = C2.zeroW, g2 = C2.x, k2 = C2.barWidth, l2 = C2.xDivision, c2 = C2.zeroH, this.isHorizontal || x2.push(g2 + k2 / 2);
      var S2 = a2.group({ class: &quot;apexcharts-datalabels&quot;, &quot;data:realIndex&quot;: b2 });
      i2.globals.delayedElements.push({ el: S2.node }), S2.node.classList.add(&quot;apexcharts-element-hidden&quot;);
      var L2 = a2.group({ class: &quot;apexcharts-bar-goals-markers&quot; }), M2 = a2.group({ class: &quot;apexcharts-bar-shadows&quot; });
      i2.globals.delayedElements.push({ el: M2.node }), M2.node.classList.add(&quot;apexcharts-element-hidden&quot;);
      for (var P2 = 0; P2 &lt; t3[n2].length; P2++) {
        var I2 = this.barHelpers.getStrokeWidth(n2, P2, b2), T2 = null, z2 = { indexes: { i: n2, j: P2, realIndex: b2, translationsIndex: A2, bc: o2 }, x: g2, y: p2, strokeWidth: I2, elSeries: y2 };
        this.isHorizontal ? (T2 = this.drawBarPaths(u(u({}, z2), {}, { barHeight: w2, zeroW: d2, yDivision: h2 })), k2 = this.series[n2][P2] / this.invertedYRatio) : (T2 = this.drawColumnPaths(u(u({}, z2), {}, { xDivision: l2, barWidth: k2, zeroH: c2 })), w2 = this.series[n2][P2] / this.yRatio[A2]);
        var X2 = this.barHelpers.getPathFillColor(t3, n2, P2, b2);
        if (this.isFunnel &amp;&amp; this.barOptions.isFunnel3d &amp;&amp; this.pathArr.length &amp;&amp; P2 &gt; 0) {
          var R2, E2 = this.barHelpers.drawBarShadow({ color: &quot;string&quot; == typeof X2.color &amp;&amp; -1 === (null === (R2 = X2.color) || void 0 === R2 ? void 0 : R2.indexOf(&quot;url&quot;)) ? X2.color : v.hexToRgba(i2.globals.colors[n2]), prevPaths: this.pathArr[this.pathArr.length - 1], currPaths: T2 });
          if (M2.add(E2), i2.config.chart.dropShadow.enabled) new Li(this.ctx).dropShadow(E2, i2.config.chart.dropShadow, b2);
        }
        this.pathArr.push(T2);
        var Y2 = this.barHelpers.drawGoalLine({ barXPosition: T2.barXPosition, barYPosition: T2.barYPosition, goalX: T2.goalX, goalY: T2.goalY, barHeight: w2, barWidth: k2 });
        Y2 &amp;&amp; L2.add(Y2), p2 = T2.y, g2 = T2.x, P2 &gt; 0 &amp;&amp; x2.push(g2 + k2 / 2), f2.push(p2), this.renderSeries(u(u({ realIndex: b2, pathFill: X2.color }, X2.useRangeColor ? { lineFill: X2.color } : {}), {}, { j: P2, i: n2, columnGroupIndex: m2, pathFrom: T2.pathFrom, pathTo: T2.pathTo, strokeWidth: I2, elSeries: y2, x: g2, y: p2, series: t3, barHeight: Math.abs(T2.barHeight ? T2.barHeight : w2), barWidth: Math.abs(T2.barWidth ? T2.barWidth : k2), elDataLabelsWrap: S2, elGoalsMarkers: L2, elBarShadows: M2, visibleSeries: this.visibleI, type: &quot;bar&quot; }));
      }
      i2.globals.seriesXvalues[b2] = x2, i2.globals.seriesYvalues[b2] = f2, r2.add(y2);
    }
    return r2;
  } }, { key: &quot;renderSeries&quot;, value: function(t3) {
    var e2 = t3.realIndex, i2 = t3.pathFill, a2 = t3.lineFill, s2 = t3.j, r2 = t3.i, n2 = t3.columnGroupIndex, o2 = t3.pathFrom, l2 = t3.pathTo, h2 = t3.strokeWidth, c2 = t3.elSeries, d2 = t3.x, u2 = t3.y, g2 = t3.y1, p2 = t3.y2, f2 = t3.series, x2 = t3.barHeight, b2 = t3.barWidth, m2 = t3.barXPosition, v2 = t3.barYPosition, y2 = t3.elDataLabelsWrap, w2 = t3.elGoalsMarkers, k2 = t3.elBarShadows, A2 = t3.visibleSeries, C2 = t3.type, S2 = t3.classes, L2 = this.w, M2 = new Mi(this.ctx);
    if (!a2) {
      var P2 = &quot;function&quot; == typeof L2.globals.stroke.colors[e2] ? function(t4) {
        var e3, i3 = L2.config.stroke.colors;
        return Array.isArray(i3) &amp;&amp; i3.length &gt; 0 &amp;&amp; ((e3 = i3[t4]) || (e3 = &quot;&quot;), &quot;function&quot; == typeof e3) ? e3({ value: L2.globals.series[t4][s2], dataPointIndex: s2, w: L2 }) : e3;
      }(e2) : L2.globals.stroke.colors[e2];
      a2 = this.barOptions.distributed ? L2.globals.stroke.colors[s2] : P2;
    }
    L2.config.series[r2].data[s2] &amp;&amp; L2.config.series[r2].data[s2].strokeColor &amp;&amp; (a2 = L2.config.series[r2].data[s2].strokeColor), this.isNullValue &amp;&amp; (i2 = &quot;none&quot;);
    var I2 = s2 / L2.config.chart.animations.animateGradually.delay * (L2.config.chart.animations.speed / L2.globals.dataPoints) / 2.4, T2 = M2.renderPaths({ i: r2, j: s2, realIndex: e2, pathFrom: o2, pathTo: l2, stroke: a2, strokeWidth: h2, strokeLineCap: L2.config.stroke.lineCap, fill: i2, animationDelay: I2, initialSpeed: L2.config.chart.animations.speed, dataChangeSpeed: L2.config.chart.animations.dynamicAnimation.speed, className: &quot;apexcharts-&quot;.concat(C2, &quot;-area &quot;).concat(S2), chartType: C2 });
    T2.attr(&quot;clip-path&quot;, &quot;url(#gridRectBarMask&quot;.concat(L2.globals.cuid, &quot;)&quot;));
    var z2 = L2.config.forecastDataPoints;
    z2.count &gt; 0 &amp;&amp; s2 &gt;= L2.globals.dataPoints - z2.count &amp;&amp; (T2.node.setAttribute(&quot;stroke-dasharray&quot;, z2.dashArray), T2.node.setAttribute(&quot;stroke-width&quot;, z2.strokeWidth), T2.node.setAttribute(&quot;fill-opacity&quot;, z2.fillOpacity)), void 0 !== g2 &amp;&amp; void 0 !== p2 &amp;&amp; (T2.attr(&quot;data-range-y1&quot;, g2), T2.attr(&quot;data-range-y2&quot;, p2)), new Li(this.ctx).setSelectionFilter(T2, e2, s2), c2.add(T2);
    var X2 = new La(this).handleBarDataLabels({ x: d2, y: u2, y1: g2, y2: p2, i: r2, j: s2, series: f2, realIndex: e2, columnGroupIndex: n2, barHeight: x2, barWidth: b2, barXPosition: m2, barYPosition: v2, renderedPath: T2, visibleSeries: A2 });
    return null !== X2.dataLabels &amp;&amp; y2.add(X2.dataLabels), X2.totalDataLabels &amp;&amp; y2.add(X2.totalDataLabels), c2.add(y2), w2 &amp;&amp; c2.add(w2), k2 &amp;&amp; c2.add(k2), c2;
  } }, { key: &quot;drawBarPaths&quot;, value: function(t3) {
    var e2, i2 = t3.indexes, a2 = t3.barHeight, s2 = t3.strokeWidth, r2 = t3.zeroW, n2 = t3.x, o2 = t3.y, l2 = t3.yDivision, h2 = t3.elSeries, c2 = this.w, d2 = i2.i, u2 = i2.j;
    if (c2.globals.isXNumeric) e2 = (o2 = (c2.globals.seriesX[d2][u2] - c2.globals.minX) / this.invertedXRatio - a2) + a2 * this.visibleI;
    else if (c2.config.plotOptions.bar.hideZeroBarsWhenGrouped) {
      var g2 = this.barHelpers.getZeroValueEncounters({ i: d2, j: u2 }), p2 = g2.nonZeroColumns, f2 = g2.zeroEncounters;
      p2 &gt; 0 &amp;&amp; (a2 = this.seriesLen * a2 / p2), e2 = o2 + a2 * this.visibleI, e2 -= a2 * f2;
    } else e2 = o2 + a2 * this.visibleI;
    this.isFunnel &amp;&amp; (r2 -= (this.barHelpers.getXForValue(this.series[d2][u2], r2) - r2) / 2), n2 = this.barHelpers.getXForValue(this.series[d2][u2], r2);
    var x2 = this.barHelpers.getBarpaths({ barYPosition: e2, barHeight: a2, x1: r2, x2: n2, strokeWidth: s2, isReversed: this.isReversed, series: this.series, realIndex: i2.realIndex, i: d2, j: u2, w: c2 });
    return c2.globals.isXNumeric || (o2 += l2), this.barHelpers.barBackground({ j: u2, i: d2, y1: e2 - a2 * this.visibleI, y2: a2 * this.seriesLen, elSeries: h2 }), { pathTo: x2.pathTo, pathFrom: x2.pathFrom, x1: r2, x: n2, y: o2, goalX: this.barHelpers.getGoalValues(&quot;x&quot;, r2, null, d2, u2), barYPosition: e2, barHeight: a2 };
  } }, { key: &quot;drawColumnPaths&quot;, value: function(t3) {
    var e2, i2 = t3.indexes, a2 = t3.x, s2 = t3.y, r2 = t3.xDivision, n2 = t3.barWidth, o2 = t3.zeroH, l2 = t3.strokeWidth, h2 = t3.elSeries, c2 = this.w, d2 = i2.realIndex, u2 = i2.translationsIndex, g2 = i2.i, p2 = i2.j, f2 = i2.bc;
    if (c2.globals.isXNumeric) {
      var x2 = this.getBarXForNumericXAxis({ x: a2, j: p2, realIndex: d2, barWidth: n2 });
      a2 = x2.x, e2 = x2.barXPosition;
    } else if (c2.config.plotOptions.bar.hideZeroBarsWhenGrouped) {
      var b2 = this.barHelpers.getZeroValueEncounters({ i: g2, j: p2 }), m2 = b2.nonZeroColumns, v2 = b2.zeroEncounters;
      m2 &gt; 0 &amp;&amp; (n2 = this.seriesLen * n2 / m2), e2 = a2 + n2 * this.visibleI, e2 -= n2 * v2;
    } else e2 = a2 + n2 * this.visibleI;
    s2 = this.barHelpers.getYForValue(this.series[g2][p2], o2, u2);
    var y2 = this.barHelpers.getColumnPaths({ barXPosition: e2, barWidth: n2, y1: o2, y2: s2, strokeWidth: l2, isReversed: this.isReversed, series: this.series, realIndex: d2, i: g2, j: p2, w: c2 });
    return c2.globals.isXNumeric || (a2 += r2), this.barHelpers.barBackground({ bc: f2, j: p2, i: g2, x1: e2 - l2 / 2 - n2 * this.visibleI, x2: n2 * this.seriesLen + l2 / 2, elSeries: h2 }), { pathTo: y2.pathTo, pathFrom: y2.pathFrom, x: a2, y: s2, goalY: this.barHelpers.getGoalValues(&quot;y&quot;, null, o2, g2, p2, u2), barXPosition: e2, barWidth: n2 };
  } }, { key: &quot;getBarXForNumericXAxis&quot;, value: function(t3) {
    var e2 = t3.x, i2 = t3.barWidth, a2 = t3.realIndex, s2 = t3.j, r2 = this.w, n2 = a2;
    return r2.globals.seriesX[a2].length || (n2 = r2.globals.maxValsInArrayIndex), v.isNumber(r2.globals.seriesX[n2][s2]) &amp;&amp; (e2 = (r2.globals.seriesX[n2][s2] - r2.globals.minX) / this.xRatio - i2 * this.seriesLen / 2), { barXPosition: e2 + i2 * this.visibleI, x: e2 };
  } }, { key: &quot;getPreviousPath&quot;, value: function(t3, e2) {
    for (var i2, a2 = this.w, s2 = 0; s2 &lt; a2.globals.previousPaths.length; s2++) {
      var r2 = a2.globals.previousPaths[s2];
      r2.paths &amp;&amp; r2.paths.length &gt; 0 &amp;&amp; parseInt(r2.realIndex, 10) === parseInt(t3, 10) &amp;&amp; void 0 !== a2.globals.previousPaths[s2].paths[e2] &amp;&amp; (i2 = a2.globals.previousPaths[s2].paths[e2].d);
    }
    return i2;
  } }]), t2;
}();
var Ia = function(t2) {
  h(a2, Pa);
  var e2 = n(a2);
  function a2() {
    return i(this, a2), e2.apply(this, arguments);
  }
  return s(a2, [{ key: &quot;draw&quot;, value: function(t3, e3) {
    var i2 = this, a3 = this.w;
    this.graphics = new Mi(this.ctx), this.bar = new Pa(this.ctx, this.xyRatios);
    var s2 = new Pi(this.ctx, a3);
    t3 = s2.getLogSeries(t3), this.yRatio = s2.getLogYRatios(this.yRatio), this.barHelpers.initVariables(t3), &quot;100%&quot; === a3.config.chart.stackType &amp;&amp; (t3 = a3.globals.comboCharts ? e3.map(function(t4) {
      return a3.globals.seriesPercent[t4];
    }) : a3.globals.seriesPercent.slice()), this.series = t3, this.barHelpers.initializeStackedPrevVars(this);
    for (var r2 = this.graphics.group({ class: &quot;apexcharts-bar-series apexcharts-plot-series&quot; }), n2 = 0, o2 = 0, l2 = function(s3, l3) {
      var h3 = void 0, c3 = void 0, d2 = void 0, g2 = void 0, p2 = a3.globals.comboCharts ? e3[s3] : s3, f2 = i2.barHelpers.getGroupIndex(p2), x2 = f2.groupIndex, b2 = f2.columnGroupIndex;
      i2.groupCtx = i2[a3.globals.seriesGroups[x2]];
      var m2 = [], y2 = [], w2 = 0;
      i2.yRatio.length &gt; 1 &amp;&amp; (i2.yaxisIndex = a3.globals.seriesYAxisReverseMap[p2][0], w2 = p2), i2.isReversed = a3.config.yaxis[i2.yaxisIndex] &amp;&amp; a3.config.yaxis[i2.yaxisIndex].reversed;
      var k2 = i2.graphics.group({ class: &quot;apexcharts-series&quot;, seriesName: v.escapeString(a3.globals.seriesNames[p2]), rel: s3 + 1, &quot;data:realIndex&quot;: p2 });
      i2.ctx.series.addCollapsedClassToSeries(k2, p2);
      var A2 = i2.graphics.group({ class: &quot;apexcharts-datalabels&quot;, &quot;data:realIndex&quot;: p2 }), C2 = i2.graphics.group({ class: &quot;apexcharts-bar-goals-markers&quot; }), S2 = 0, L2 = 0, M2 = i2.initialPositions(n2, o2, h3, c3, d2, g2, w2);
      o2 = M2.y, S2 = M2.barHeight, c3 = M2.yDivision, g2 = M2.zeroW, n2 = M2.x, L2 = M2.barWidth, h3 = M2.xDivision, d2 = M2.zeroH, a3.globals.barHeight = S2, a3.globals.barWidth = L2, i2.barHelpers.initializeStackedXYVars(i2), 1 === i2.groupCtx.prevY.length &amp;&amp; i2.groupCtx.prevY[0].every(function(t4) {
        return isNaN(t4);
      }) &amp;&amp; (i2.groupCtx.prevY[0] = i2.groupCtx.prevY[0].map(function() {
        return d2;
      }), i2.groupCtx.prevYF[0] = i2.groupCtx.prevYF[0].map(function() {
        return 0;
      }));
      for (var P2 = 0; P2 &lt; a3.globals.dataPoints; P2++) {
        var I2 = i2.barHelpers.getStrokeWidth(s3, P2, p2), T2 = { indexes: { i: s3, j: P2, realIndex: p2, translationsIndex: w2, bc: l3 }, strokeWidth: I2, x: n2, y: o2, elSeries: k2, columnGroupIndex: b2, seriesGroup: a3.globals.seriesGroups[x2] }, z2 = null;
        i2.isHorizontal ? (z2 = i2.drawStackedBarPaths(u(u({}, T2), {}, { zeroW: g2, barHeight: S2, yDivision: c3 })), L2 = i2.series[s3][P2] / i2.invertedYRatio) : (z2 = i2.drawStackedColumnPaths(u(u({}, T2), {}, { xDivision: h3, barWidth: L2, zeroH: d2 })), S2 = i2.series[s3][P2] / i2.yRatio[w2]);
        var X2 = i2.barHelpers.drawGoalLine({ barXPosition: z2.barXPosition, barYPosition: z2.barYPosition, goalX: z2.goalX, goalY: z2.goalY, barHeight: S2, barWidth: L2 });
        X2 &amp;&amp; C2.add(X2), o2 = z2.y, n2 = z2.x, m2.push(n2), y2.push(o2);
        var R2 = i2.barHelpers.getPathFillColor(t3, s3, P2, p2), E2 = &quot;&quot;, Y2 = a3.globals.isBarHorizontal ? &quot;apexcharts-flip-x&quot; : &quot;apexcharts-flip-y&quot;;
        (&quot;bottom&quot; === i2.barHelpers.arrBorderRadius[p2][P2] &amp;&amp; a3.globals.series[p2][P2] &gt; 0 || &quot;top&quot; === i2.barHelpers.arrBorderRadius[p2][P2] &amp;&amp; a3.globals.series[p2][P2] &lt; 0) &amp;&amp; (E2 = Y2), k2 = i2.renderSeries(u(u({ realIndex: p2, pathFill: R2.color }, R2.useRangeColor ? { lineFill: R2.color } : {}), {}, { j: P2, i: s3, columnGroupIndex: b2, pathFrom: z2.pathFrom, pathTo: z2.pathTo, strokeWidth: I2, elSeries: k2, x: n2, y: o2, series: t3, barHeight: S2, barWidth: L2, elDataLabelsWrap: A2, elGoalsMarkers: C2, type: &quot;bar&quot;, visibleSeries: b2, classes: E2 }));
      }
      a3.globals.seriesXvalues[p2] = m2, a3.globals.seriesYvalues[p2] = y2, i2.groupCtx.prevY.push(i2.groupCtx.yArrj), i2.groupCtx.prevYF.push(i2.groupCtx.yArrjF), i2.groupCtx.prevYVal.push(i2.groupCtx.yArrjVal), i2.groupCtx.prevX.push(i2.groupCtx.xArrj), i2.groupCtx.prevXF.push(i2.groupCtx.xArrjF), i2.groupCtx.prevXVal.push(i2.groupCtx.xArrjVal), r2.add(k2);
    }, h2 = 0, c2 = 0; h2 &lt; t3.length; h2++, c2++) l2(h2, c2);
    return r2;
  } }, { key: &quot;initialPositions&quot;, value: function(t3, e3, i2, a3, s2, r2, n2) {
    var o2, l2, h2 = this.w;
    if (this.isHorizontal) {
      a3 = h2.globals.gridHeight / h2.globals.dataPoints;
      var c2 = h2.config.plotOptions.bar.barHeight;
      o2 = -1 === String(c2).indexOf(&quot;%&quot;) ? parseInt(c2, 10) : a3 * parseInt(c2, 10) / 100, r2 = h2.globals.padHorizontal + (this.isReversed ? h2.globals.gridWidth - this.baseLineInvertedY : this.baseLineInvertedY), e3 = (a3 - o2) / 2;
    } else {
      l2 = i2 = h2.globals.gridWidth / h2.globals.dataPoints;
      var d2 = h2.config.plotOptions.bar.columnWidth;
      h2.globals.isXNumeric &amp;&amp; h2.globals.dataPoints &gt; 1 ? l2 = (i2 = h2.globals.minXDiff / this.xRatio) * parseInt(this.barOptions.columnWidth, 10) / 100 : -1 === String(d2).indexOf(&quot;%&quot;) ? l2 = parseInt(d2, 10) : l2 *= parseInt(d2, 10) / 100, s2 = this.isReversed ? this.baseLineY[n2] : h2.globals.gridHeight - this.baseLineY[n2], t3 = h2.globals.padHorizontal + (i2 - l2) / 2;
    }
    var u2 = h2.globals.barGroups.length || 1;
    return { x: t3, y: e3, yDivision: a3, xDivision: i2, barHeight: o2 / u2, barWidth: l2 / u2, zeroH: s2, zeroW: r2 };
  } }, { key: &quot;drawStackedBarPaths&quot;, value: function(t3) {
    for (var e3, i2 = t3.indexes, a3 = t3.barHeight, s2 = t3.strokeWidth, r2 = t3.zeroW, n2 = t3.x, o2 = t3.y, l2 = t3.columnGroupIndex, h2 = t3.seriesGroup, c2 = t3.yDivision, d2 = t3.elSeries, u2 = this.w, g2 = o2 + l2 * a3, p2 = i2.i, f2 = i2.j, x2 = i2.realIndex, b2 = i2.translationsIndex, m2 = 0, v2 = 0; v2 &lt; this.groupCtx.prevXF.length; v2++) m2 += this.groupCtx.prevXF[v2][f2];
    var y2 = p2;
    if (u2.config.series[x2].name &amp;&amp; (y2 = h2.indexOf(u2.config.series[x2].name)), y2 &gt; 0) {
      var w2 = r2;
      this.groupCtx.prevXVal[y2 - 1][f2] &lt; 0 ? w2 = this.series[p2][f2] &gt;= 0 ? this.groupCtx.prevX[y2 - 1][f2] + m2 - 2 * (this.isReversed ? m2 : 0) : this.groupCtx.prevX[y2 - 1][f2] : this.groupCtx.prevXVal[y2 - 1][f2] &gt;= 0 &amp;&amp; (w2 = this.series[p2][f2] &gt;= 0 ? this.groupCtx.prevX[y2 - 1][f2] : this.groupCtx.prevX[y2 - 1][f2] - m2 + 2 * (this.isReversed ? m2 : 0)), e3 = w2;
    } else e3 = r2;
    n2 = null === this.series[p2][f2] ? e3 : e3 + this.series[p2][f2] / this.invertedYRatio - 2 * (this.isReversed ? this.series[p2][f2] / this.invertedYRatio : 0);
    var k2 = this.barHelpers.getBarpaths({ barYPosition: g2, barHeight: a3, x1: e3, x2: n2, strokeWidth: s2, isReversed: this.isReversed, series: this.series, realIndex: i2.realIndex, seriesGroup: h2, i: p2, j: f2, w: u2 });
    return this.barHelpers.barBackground({ j: f2, i: p2, y1: g2, y2: a3, elSeries: d2 }), o2 += c2, { pathTo: k2.pathTo, pathFrom: k2.pathFrom, goalX: this.barHelpers.getGoalValues(&quot;x&quot;, r2, null, p2, f2, b2), barXPosition: e3, barYPosition: g2, x: n2, y: o2 };
  } }, { key: &quot;drawStackedColumnPaths&quot;, value: function(t3) {
    var e3 = t3.indexes, i2 = t3.x, a3 = t3.y, s2 = t3.xDivision, r2 = t3.barWidth, n2 = t3.zeroH, o2 = t3.columnGroupIndex, l2 = t3.seriesGroup, h2 = t3.elSeries, c2 = this.w, d2 = e3.i, u2 = e3.j, g2 = e3.bc, p2 = e3.realIndex, f2 = e3.translationsIndex;
    if (c2.globals.isXNumeric) {
      var x2 = c2.globals.seriesX[p2][u2];
      x2 || (x2 = 0), i2 = (x2 - c2.globals.minX) / this.xRatio - r2 / 2 * c2.globals.barGroups.length;
    }
    for (var b2, m2 = i2 + o2 * r2, v2 = 0, y2 = 0; y2 &lt; this.groupCtx.prevYF.length; y2++) v2 += isNaN(this.groupCtx.prevYF[y2][u2]) ? 0 : this.groupCtx.prevYF[y2][u2];
    var w2 = d2;
    if (l2 &amp;&amp; (w2 = l2.indexOf(c2.globals.seriesNames[p2])), w2 &gt; 0 &amp;&amp; !c2.globals.isXNumeric || w2 &gt; 0 &amp;&amp; c2.globals.isXNumeric &amp;&amp; c2.globals.seriesX[p2 - 1][u2] === c2.globals.seriesX[p2][u2]) {
      var k2, A2, C2, S2 = Math.min(this.yRatio.length + 1, p2 + 1);
      if (void 0 !== this.groupCtx.prevY[w2 - 1] &amp;&amp; this.groupCtx.prevY[w2 - 1].length) for (var L2 = 1; L2 &lt; S2; L2++) {
        var M2;
        if (!isNaN(null === (M2 = this.groupCtx.prevY[w2 - L2]) || void 0 === M2 ? void 0 : M2[u2])) {
          C2 = this.groupCtx.prevY[w2 - L2][u2];
          break;
        }
      }
      for (var P2 = 1; P2 &lt; S2; P2++) {
        var I2, T2;
        if ((null === (I2 = this.groupCtx.prevYVal[w2 - P2]) || void 0 === I2 ? void 0 : I2[u2]) &lt; 0) {
          A2 = this.series[d2][u2] &gt;= 0 ? C2 - v2 + 2 * (this.isReversed ? v2 : 0) : C2;
          break;
        }
        if ((null === (T2 = this.groupCtx.prevYVal[w2 - P2]) || void 0 === T2 ? void 0 : T2[u2]) &gt;= 0) {
          A2 = this.series[d2][u2] &gt;= 0 ? C2 : C2 + v2 - 2 * (this.isReversed ? v2 : 0);
          break;
        }
      }
      void 0 === A2 &amp;&amp; (A2 = c2.globals.gridHeight), b2 = null !== (k2 = this.groupCtx.prevYF[0]) &amp;&amp; void 0 !== k2 &amp;&amp; k2.every(function(t4) {
        return 0 === t4;
      }) &amp;&amp; this.groupCtx.prevYF.slice(1, w2).every(function(t4) {
        return t4.every(function(t5) {
          return isNaN(t5);
        });
      }) ? n2 : A2;
    } else b2 = n2;
    a3 = this.series[d2][u2] ? b2 - this.series[d2][u2] / this.yRatio[f2] + 2 * (this.isReversed ? this.series[d2][u2] / this.yRatio[f2] : 0) : b2;
    var z2 = this.barHelpers.getColumnPaths({ barXPosition: m2, barWidth: r2, y1: b2, y2: a3, yRatio: this.yRatio[f2], strokeWidth: this.strokeWidth, isReversed: this.isReversed, series: this.series, seriesGroup: l2, realIndex: e3.realIndex, i: d2, j: u2, w: c2 });
    return this.barHelpers.barBackground({ bc: g2, j: u2, i: d2, x1: m2, x2: r2, elSeries: h2 }), { pathTo: z2.pathTo, pathFrom: z2.pathFrom, goalY: this.barHelpers.getGoalValues(&quot;y&quot;, null, n2, d2, u2), barXPosition: m2, x: c2.globals.isXNumeric ? i2 : i2 + s2, y: a3 };
  } }]), a2;
}();
var Ta = function(t2) {
  h(a2, Pa);
  var e2 = n(a2);
  function a2() {
    return i(this, a2), e2.apply(this, arguments);
  }
  return s(a2, [{ key: &quot;draw&quot;, value: function(t3, e3, i2) {
    var a3 = this, s2 = this.w, r2 = new Mi(this.ctx), n2 = s2.globals.comboCharts ? e3 : s2.config.chart.type, o2 = new ji(this.ctx);
    this.candlestickOptions = this.w.config.plotOptions.candlestick, this.boxOptions = this.w.config.plotOptions.boxPlot, this.isHorizontal = s2.config.plotOptions.bar.horizontal;
    var l2 = new Pi(this.ctx, s2);
    t3 = l2.getLogSeries(t3), this.series = t3, this.yRatio = l2.getLogYRatios(this.yRatio), this.barHelpers.initVariables(t3);
    for (var h2 = r2.group({ class: &quot;apexcharts-&quot;.concat(n2, &quot;-series apexcharts-plot-series&quot;) }), c2 = function(e4) {
      a3.isBoxPlot = &quot;boxPlot&quot; === s2.config.chart.type || &quot;boxPlot&quot; === s2.config.series[e4].type;
      var n3, l3, c3, d3, g2 = void 0, p2 = void 0, f2 = [], x2 = [], b2 = s2.globals.comboCharts ? i2[e4] : e4, m2 = a3.barHelpers.getGroupIndex(b2).columnGroupIndex, y2 = r2.group({ class: &quot;apexcharts-series&quot;, seriesName: v.escapeString(s2.globals.seriesNames[b2]), rel: e4 + 1, &quot;data:realIndex&quot;: b2 });
      a3.ctx.series.addCollapsedClassToSeries(y2, b2), t3[e4].length &gt; 0 &amp;&amp; (a3.visibleI = a3.visibleI + 1);
      var w2, k2, A2 = 0;
      a3.yRatio.length &gt; 1 &amp;&amp; (a3.yaxisIndex = s2.globals.seriesYAxisReverseMap[b2][0], A2 = b2);
      var C2 = a3.barHelpers.initialPositions(b2);
      p2 = C2.y, w2 = C2.barHeight, l3 = C2.yDivision, d3 = C2.zeroW, g2 = C2.x, k2 = C2.barWidth, n3 = C2.xDivision, c3 = C2.zeroH, x2.push(g2 + k2 / 2);
      for (var S2 = r2.group({ class: &quot;apexcharts-datalabels&quot;, &quot;data:realIndex&quot;: b2 }), L2 = r2.group({ class: &quot;apexcharts-bar-goals-markers&quot; }), M2 = function(i3) {
        var r3 = a3.barHelpers.getStrokeWidth(e4, i3, b2), h3 = null, v2 = { indexes: { i: e4, j: i3, realIndex: b2, translationsIndex: A2 }, x: g2, y: p2, strokeWidth: r3, elSeries: y2 };
        h3 = a3.isHorizontal ? a3.drawHorizontalBoxPaths(u(u({}, v2), {}, { yDivision: l3, barHeight: w2, zeroW: d3 })) : a3.drawVerticalBoxPaths(u(u({}, v2), {}, { xDivision: n3, barWidth: k2, zeroH: c3 })), p2 = h3.y, g2 = h3.x;
        var C3 = a3.barHelpers.drawGoalLine({ barXPosition: h3.barXPosition, barYPosition: h3.barYPosition, goalX: h3.goalX, goalY: h3.goalY, barHeight: w2, barWidth: k2 });
        C3 &amp;&amp; L2.add(C3), i3 &gt; 0 &amp;&amp; x2.push(g2 + k2 / 2), f2.push(p2), h3.pathTo.forEach(function(n4, l4) {
          var c4 = !a3.isBoxPlot &amp;&amp; a3.candlestickOptions.wick.useFillColor ? h3.color[l4] : s2.globals.stroke.colors[e4], d4 = o2.fillPath({ seriesNumber: b2, dataPointIndex: i3, color: h3.color[l4], value: t3[e4][i3] });
          a3.renderSeries({ realIndex: b2, pathFill: d4, lineFill: c4, j: i3, i: e4, pathFrom: h3.pathFrom, pathTo: n4, strokeWidth: r3, elSeries: y2, x: g2, y: p2, series: t3, columnGroupIndex: m2, barHeight: w2, barWidth: k2, elDataLabelsWrap: S2, elGoalsMarkers: L2, visibleSeries: a3.visibleI, type: s2.config.chart.type });
        });
      }, P2 = 0; P2 &lt; s2.globals.dataPoints; P2++) M2(P2);
      s2.globals.seriesXvalues[b2] = x2, s2.globals.seriesYvalues[b2] = f2, h2.add(y2);
    }, d2 = 0; d2 &lt; t3.length; d2++) c2(d2);
    return h2;
  } }, { key: &quot;drawVerticalBoxPaths&quot;, value: function(t3) {
    var e3 = t3.indexes, i2 = t3.x;
    t3.y;
    var a3 = t3.xDivision, s2 = t3.barWidth, r2 = t3.zeroH, n2 = t3.strokeWidth, o2 = this.w, l2 = new Mi(this.ctx), h2 = e3.i, c2 = e3.j, d2 = o2.config.plotOptions.candlestick.colors, u2 = this.boxOptions.colors, g2 = e3.realIndex, p2 = function(t4) {
      return Array.isArray(t4) ? t4[g2] : t4;
    }, f2 = p2(d2.upward), x2 = p2(d2.downward), b2 = this.yRatio[e3.translationsIndex], m2 = this.getOHLCValue(g2, c2), v2 = r2, y2 = r2, w2 = m2.o &lt; m2.c ? [f2] : [x2];
    this.isBoxPlot &amp;&amp; (w2 = [p2(u2.lower), p2(u2.upper)]);
    var k2 = Math.min(m2.o, m2.c), A2 = Math.max(m2.o, m2.c), C2 = m2.m;
    o2.globals.isXNumeric &amp;&amp; (i2 = (o2.globals.seriesX[g2][c2] - o2.globals.minX) / this.xRatio - s2 / 2);
    var S2 = i2 + s2 * this.visibleI;
    void 0 === this.series[h2][c2] || null === this.series[h2][c2] ? (k2 = r2, A2 = r2) : (k2 = r2 - k2 / b2, A2 = r2 - A2 / b2, v2 = r2 - m2.h / b2, y2 = r2 - m2.l / b2, C2 = r2 - m2.m / b2);
    var L2 = l2.move(S2, r2), M2 = l2.move(S2 + s2 / 2, k2);
    return o2.globals.previousPaths.length &gt; 0 &amp;&amp; (M2 = this.getPreviousPath(g2, c2, true)), L2 = this.isBoxPlot ? [l2.move(S2, k2) + l2.line(S2 + s2 / 2, k2) + l2.line(S2 + s2 / 2, v2) + l2.line(S2 + s2 / 4, v2) + l2.line(S2 + s2 - s2 / 4, v2) + l2.line(S2 + s2 / 2, v2) + l2.line(S2 + s2 / 2, k2) + l2.line(S2 + s2, k2) + l2.line(S2 + s2, C2) + l2.line(S2, C2) + l2.line(S2, k2 + n2 / 2), l2.move(S2, C2) + l2.line(S2 + s2, C2) + l2.line(S2 + s2, A2) + l2.line(S2 + s2 / 2, A2) + l2.line(S2 + s2 / 2, y2) + l2.line(S2 + s2 - s2 / 4, y2) + l2.line(S2 + s2 / 4, y2) + l2.line(S2 + s2 / 2, y2) + l2.line(S2 + s2 / 2, A2) + l2.line(S2, A2) + l2.line(S2, C2) + &quot;z&quot;] : [l2.move(S2, A2) + l2.line(S2 + s2 / 2, A2) + l2.line(S2 + s2 / 2, v2) + l2.line(S2 + s2 / 2, A2) + l2.line(S2 + s2, A2) + l2.line(S2 + s2, k2) + l2.line(S2 + s2 / 2, k2) + l2.line(S2 + s2 / 2, y2) + l2.line(S2 + s2 / 2, k2) + l2.line(S2, k2) + l2.line(S2, A2 - n2 / 2)], M2 += l2.move(S2, k2), o2.globals.isXNumeric || (i2 += a3), { pathTo: L2, pathFrom: M2, x: i2, y: A2, goalY: this.barHelpers.getGoalValues(&quot;y&quot;, null, r2, h2, c2, e3.translationsIndex), barXPosition: S2, color: w2 };
  } }, { key: &quot;drawHorizontalBoxPaths&quot;, value: function(t3) {
    var e3 = t3.indexes;
    t3.x;
    var i2 = t3.y, a3 = t3.yDivision, s2 = t3.barHeight, r2 = t3.zeroW, n2 = t3.strokeWidth, o2 = this.w, l2 = new Mi(this.ctx), h2 = e3.i, c2 = e3.j, d2 = this.boxOptions.colors.lower;
    this.isBoxPlot &amp;&amp; (d2 = [this.boxOptions.colors.lower, this.boxOptions.colors.upper]);
    var u2 = this.invertedYRatio, g2 = e3.realIndex, p2 = this.getOHLCValue(g2, c2), f2 = r2, x2 = r2, b2 = Math.min(p2.o, p2.c), m2 = Math.max(p2.o, p2.c), v2 = p2.m;
    o2.globals.isXNumeric &amp;&amp; (i2 = (o2.globals.seriesX[g2][c2] - o2.globals.minX) / this.invertedXRatio - s2 / 2);
    var y2 = i2 + s2 * this.visibleI;
    void 0 === this.series[h2][c2] || null === this.series[h2][c2] ? (b2 = r2, m2 = r2) : (b2 = r2 + b2 / u2, m2 = r2 + m2 / u2, f2 = r2 + p2.h / u2, x2 = r2 + p2.l / u2, v2 = r2 + p2.m / u2);
    var w2 = l2.move(r2, y2), k2 = l2.move(b2, y2 + s2 / 2);
    return o2.globals.previousPaths.length &gt; 0 &amp;&amp; (k2 = this.getPreviousPath(g2, c2, true)), w2 = [l2.move(b2, y2) + l2.line(b2, y2 + s2 / 2) + l2.line(f2, y2 + s2 / 2) + l2.line(f2, y2 + s2 / 2 - s2 / 4) + l2.line(f2, y2 + s2 / 2 + s2 / 4) + l2.line(f2, y2 + s2 / 2) + l2.line(b2, y2 + s2 / 2) + l2.line(b2, y2 + s2) + l2.line(v2, y2 + s2) + l2.line(v2, y2) + l2.line(b2 + n2 / 2, y2), l2.move(v2, y2) + l2.line(v2, y2 + s2) + l2.line(m2, y2 + s2) + l2.line(m2, y2 + s2 / 2) + l2.line(x2, y2 + s2 / 2) + l2.line(x2, y2 + s2 - s2 / 4) + l2.line(x2, y2 + s2 / 4) + l2.line(x2, y2 + s2 / 2) + l2.line(m2, y2 + s2 / 2) + l2.line(m2, y2) + l2.line(v2, y2) + &quot;z&quot;], k2 += l2.move(b2, y2), o2.globals.isXNumeric || (i2 += a3), { pathTo: w2, pathFrom: k2, x: m2, y: i2, goalX: this.barHelpers.getGoalValues(&quot;x&quot;, r2, null, h2, c2), barYPosition: y2, color: d2 };
  } }, { key: &quot;getOHLCValue&quot;, value: function(t3, e3) {
    var i2 = this.w, a3 = new Pi(this.ctx, i2), s2 = a3.getLogValAtSeriesIndex(i2.globals.seriesCandleH[t3][e3], t3), r2 = a3.getLogValAtSeriesIndex(i2.globals.seriesCandleO[t3][e3], t3), n2 = a3.getLogValAtSeriesIndex(i2.globals.seriesCandleM[t3][e3], t3), o2 = a3.getLogValAtSeriesIndex(i2.globals.seriesCandleC[t3][e3], t3), l2 = a3.getLogValAtSeriesIndex(i2.globals.seriesCandleL[t3][e3], t3);
    return { o: this.isBoxPlot ? s2 : r2, h: this.isBoxPlot ? r2 : s2, m: n2, l: this.isBoxPlot ? o2 : l2, c: this.isBoxPlot ? l2 : o2 };
  } }]), a2;
}();
var za = function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w;
  }
  return s(t2, [{ key: &quot;checkColorRange&quot;, value: function() {
    var t3 = this.w, e2 = false, i2 = t3.config.plotOptions[t3.config.chart.type];
    return i2.colorScale.ranges.length &gt; 0 &amp;&amp; i2.colorScale.ranges.map(function(t4, i3) {
      t4.from &lt;= 0 &amp;&amp; (e2 = true);
    }), e2;
  } }, { key: &quot;getShadeColor&quot;, value: function(t3, e2, i2, a2) {
    var s2 = this.w, r2 = 1, n2 = s2.config.plotOptions[t3].shadeIntensity, o2 = this.determineColor(t3, e2, i2);
    s2.globals.hasNegs || a2 ? r2 = s2.config.plotOptions[t3].reverseNegativeShade ? o2.percent &lt; 0 ? o2.percent / 100 * (1.25 * n2) : (1 - o2.percent / 100) * (1.25 * n2) : o2.percent &lt;= 0 ? 1 - (1 + o2.percent / 100) * n2 : (1 - o2.percent / 100) * n2 : (r2 = 1 - o2.percent / 100, &quot;treemap&quot; === t3 &amp;&amp; (r2 = (1 - o2.percent / 100) * (1.25 * n2)));
    var l2 = o2.color, h2 = new v();
    if (s2.config.plotOptions[t3].enableShades) if (&quot;dark&quot; === this.w.config.theme.mode) {
      var c2 = h2.shadeColor(-1 * r2, o2.color);
      l2 = v.hexToRgba(v.isColorHex(c2) ? c2 : v.rgb2hex(c2), s2.config.fill.opacity);
    } else {
      var d2 = h2.shadeColor(r2, o2.color);
      l2 = v.hexToRgba(v.isColorHex(d2) ? d2 : v.rgb2hex(d2), s2.config.fill.opacity);
    }
    return { color: l2, colorProps: o2 };
  } }, { key: &quot;determineColor&quot;, value: function(t3, e2, i2) {
    var a2 = this.w, s2 = a2.globals.series[e2][i2], r2 = a2.config.plotOptions[t3], n2 = r2.colorScale.inverse ? i2 : e2;
    r2.distributed &amp;&amp; &quot;treemap&quot; === a2.config.chart.type &amp;&amp; (n2 = i2);
    var o2 = a2.globals.colors[n2], l2 = null, h2 = Math.min.apply(Math, f(a2.globals.series[e2])), c2 = Math.max.apply(Math, f(a2.globals.series[e2]));
    r2.distributed || &quot;heatmap&quot; !== t3 || (h2 = a2.globals.minY, c2 = a2.globals.maxY), void 0 !== r2.colorScale.min &amp;&amp; (h2 = r2.colorScale.min &lt; a2.globals.minY ? r2.colorScale.min : a2.globals.minY, c2 = r2.colorScale.max &gt; a2.globals.maxY ? r2.colorScale.max : a2.globals.maxY);
    var d2 = Math.abs(c2) + Math.abs(h2), u2 = 100 * s2 / (0 === d2 ? d2 - 1e-6 : d2);
    r2.colorScale.ranges.length &gt; 0 &amp;&amp; r2.colorScale.ranges.map(function(t4, e3) {
      if (s2 &gt;= t4.from &amp;&amp; s2 &lt;= t4.to) {
        o2 = t4.color, l2 = t4.foreColor ? t4.foreColor : null, h2 = t4.from, c2 = t4.to;
        var i3 = Math.abs(c2) + Math.abs(h2);
        u2 = 100 * s2 / (0 === i3 ? i3 - 1e-6 : i3);
      }
    });
    return { color: o2, foreColor: l2, percent: u2 };
  } }, { key: &quot;calculateDataLabels&quot;, value: function(t3) {
    var e2 = t3.text, i2 = t3.x, a2 = t3.y, s2 = t3.i, r2 = t3.j, n2 = t3.colorProps, o2 = t3.fontSize, l2 = this.w.config.dataLabels, h2 = new Mi(this.ctx), c2 = new qi(this.ctx), d2 = null;
    if (l2.enabled) {
      d2 = h2.group({ class: &quot;apexcharts-data-labels&quot; });
      var u2 = l2.offsetX, g2 = l2.offsetY, p2 = i2 + u2, f2 = a2 + parseFloat(l2.style.fontSize) / 3 + g2;
      c2.plotDataLabelsText({ x: p2, y: f2, text: e2, i: s2, j: r2, color: n2.foreColor, parent: d2, fontSize: o2, dataLabelsConfig: l2 });
    }
    return d2;
  } }, { key: &quot;addListeners&quot;, value: function(t3) {
    var e2 = new Mi(this.ctx);
    t3.node.addEventListener(&quot;mouseenter&quot;, e2.pathMouseEnter.bind(this, t3)), t3.node.addEventListener(&quot;mouseleave&quot;, e2.pathMouseLeave.bind(this, t3)), t3.node.addEventListener(&quot;mousedown&quot;, e2.pathMouseDown.bind(this, t3));
  } }]), t2;
}();
var Xa = function() {
  function t2(e2, a2) {
    i(this, t2), this.ctx = e2, this.w = e2.w, this.xRatio = a2.xRatio, this.yRatio = a2.yRatio, this.dynamicAnim = this.w.config.chart.animations.dynamicAnimation, this.helpers = new za(e2), this.rectRadius = this.w.config.plotOptions.heatmap.radius, this.strokeWidth = this.w.config.stroke.show ? this.w.config.stroke.width : 0;
  }
  return s(t2, [{ key: &quot;draw&quot;, value: function(t3) {
    var e2 = this.w, i2 = new Mi(this.ctx), a2 = i2.group({ class: &quot;apexcharts-heatmap&quot; });
    a2.attr(&quot;clip-path&quot;, &quot;url(#gridRectMask&quot;.concat(e2.globals.cuid, &quot;)&quot;));
    var s2 = e2.globals.gridWidth / e2.globals.dataPoints, r2 = e2.globals.gridHeight / e2.globals.series.length, n2 = 0, o2 = false;
    this.negRange = this.helpers.checkColorRange();
    var l2 = t3.slice();
    e2.config.yaxis[0].reversed &amp;&amp; (o2 = true, l2.reverse());
    for (var h2 = o2 ? 0 : l2.length - 1; o2 ? h2 &lt; l2.length : h2 &gt;= 0; o2 ? h2++ : h2--) {
      var c2 = i2.group({ class: &quot;apexcharts-series apexcharts-heatmap-series&quot;, seriesName: v.escapeString(e2.globals.seriesNames[h2]), rel: h2 + 1, &quot;data:realIndex&quot;: h2 });
      if (this.ctx.series.addCollapsedClassToSeries(c2, h2), e2.config.chart.dropShadow.enabled) {
        var d2 = e2.config.chart.dropShadow;
        new Li(this.ctx).dropShadow(c2, d2, h2);
      }
      for (var u2 = 0, g2 = e2.config.plotOptions.heatmap.shadeIntensity, p2 = 0, f2 = 0; f2 &lt; e2.globals.dataPoints; f2++) if (e2.globals.seriesX.length &amp;&amp; !e2.globals.allSeriesHasEqualX &amp;&amp; e2.globals.minX + e2.globals.minXDiff * f2 &lt; e2.globals.seriesX[h2][p2]) u2 += s2;
      else {
        if (p2 &gt;= l2[h2].length) break;
        var x2 = this.helpers.getShadeColor(e2.config.chart.type, h2, p2, this.negRange), b2 = x2.color, m2 = x2.colorProps;
        if (&quot;image&quot; === e2.config.fill.type) b2 = new ji(this.ctx).fillPath({ seriesNumber: h2, dataPointIndex: p2, opacity: e2.globals.hasNegs ? m2.percent &lt; 0 ? 1 - (1 + m2.percent / 100) : g2 + m2.percent / 100 : m2.percent / 100, patternID: v.randomId(), width: e2.config.fill.image.width ? e2.config.fill.image.width : s2, height: e2.config.fill.image.height ? e2.config.fill.image.height : r2 });
        var y2 = this.rectRadius, w2 = i2.drawRect(u2, n2, s2, r2, y2);
        if (w2.attr({ cx: u2, cy: n2 }), w2.node.classList.add(&quot;apexcharts-heatmap-rect&quot;), c2.add(w2), w2.attr({ fill: b2, i: h2, index: h2, j: p2, val: t3[h2][p2], &quot;stroke-width&quot;: this.strokeWidth, stroke: e2.config.plotOptions.heatmap.useFillColorAsStroke ? b2 : e2.globals.stroke.colors[0], color: b2 }), this.helpers.addListeners(w2), e2.config.chart.animations.enabled &amp;&amp; !e2.globals.dataChanged) {
          var k2 = 1;
          e2.globals.resized || (k2 = e2.config.chart.animations.speed), this.animateHeatMap(w2, u2, n2, s2, r2, k2);
        }
        if (e2.globals.dataChanged) {
          var A2 = 1;
          if (this.dynamicAnim.enabled &amp;&amp; e2.globals.shouldAnimate) {
            A2 = this.dynamicAnim.speed;
            var C2 = e2.globals.previousPaths[h2] &amp;&amp; e2.globals.previousPaths[h2][p2] &amp;&amp; e2.globals.previousPaths[h2][p2].color;
            C2 || (C2 = &quot;rgba(255, 255, 255, 0)&quot;), this.animateHeatColor(w2, v.isColorHex(C2) ? C2 : v.rgb2hex(C2), v.isColorHex(b2) ? b2 : v.rgb2hex(b2), A2);
          }
        }
        var S2 = (0, e2.config.dataLabels.formatter)(e2.globals.series[h2][p2], { value: e2.globals.series[h2][p2], seriesIndex: h2, dataPointIndex: p2, w: e2 }), L2 = this.helpers.calculateDataLabels({ text: S2, x: u2 + s2 / 2, y: n2 + r2 / 2, i: h2, j: p2, colorProps: m2, series: l2 });
        null !== L2 &amp;&amp; c2.add(L2), u2 += s2, p2++;
      }
      n2 += r2, a2.add(c2);
    }
    var M2 = e2.globals.yAxisScale[0].result.slice();
    return e2.config.yaxis[0].reversed ? M2.unshift(&quot;&quot;) : M2.push(&quot;&quot;), e2.globals.yAxisScale[0].result = M2, a2;
  } }, { key: &quot;animateHeatMap&quot;, value: function(t3, e2, i2, a2, s2, r2) {
    var n2 = new y(this.ctx);
    n2.animateRect(t3, { x: e2 + a2 / 2, y: i2 + s2 / 2, width: 0, height: 0 }, { x: e2, y: i2, width: a2, height: s2 }, r2, function() {
      n2.animationCompleted(t3);
    });
  } }, { key: &quot;animateHeatColor&quot;, value: function(t3, e2, i2, a2) {
    t3.attr({ fill: e2 }).animate(a2).attr({ fill: i2 });
  } }]), t2;
}();
var Ra = function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w;
  }
  return s(t2, [{ key: &quot;drawYAxisTexts&quot;, value: function(t3, e2, i2, a2) {
    var s2 = this.w, r2 = s2.config.yaxis[0], n2 = s2.globals.yLabelFormatters[0];
    return new Mi(this.ctx).drawText({ x: t3 + r2.labels.offsetX, y: e2 + r2.labels.offsetY, text: n2(a2, i2), textAnchor: &quot;middle&quot;, fontSize: r2.labels.style.fontSize, fontFamily: r2.labels.style.fontFamily, foreColor: Array.isArray(r2.labels.style.colors) ? r2.labels.style.colors[i2] : r2.labels.style.colors });
  } }]), t2;
}();
var Ea = function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w;
    var a2 = this.w;
    this.chartType = this.w.config.chart.type, this.initialAnim = this.w.config.chart.animations.enabled, this.dynamicAnim = this.initialAnim &amp;&amp; this.w.config.chart.animations.dynamicAnimation.enabled, this.animBeginArr = [0], this.animDur = 0, this.donutDataLabels = this.w.config.plotOptions.pie.donut.labels, this.lineColorArr = void 0 !== a2.globals.stroke.colors ? a2.globals.stroke.colors : a2.globals.colors, this.defaultSize = Math.min(a2.globals.gridWidth, a2.globals.gridHeight), this.centerY = this.defaultSize / 2, this.centerX = a2.globals.gridWidth / 2, &quot;radialBar&quot; === a2.config.chart.type ? this.fullAngle = 360 : this.fullAngle = Math.abs(a2.config.plotOptions.pie.endAngle - a2.config.plotOptions.pie.startAngle), this.initialAngle = a2.config.plotOptions.pie.startAngle % this.fullAngle, a2.globals.radialSize = this.defaultSize / 2.05 - a2.config.stroke.width - (a2.config.chart.sparkline.enabled ? 0 : a2.config.chart.dropShadow.blur), this.donutSize = a2.globals.radialSize * parseInt(a2.config.plotOptions.pie.donut.size, 10) / 100;
    var s2 = a2.config.plotOptions.pie.customScale, r2 = a2.globals.gridWidth / 2, n2 = a2.globals.gridHeight / 2;
    this.translateX = r2 - r2 * s2, this.translateY = n2 - n2 * s2, this.dataLabelsGroup = new Mi(this.ctx).group({ class: &quot;apexcharts-datalabels-group&quot;, transform: &quot;translate(&quot;.concat(this.translateX, &quot;, &quot;).concat(this.translateY, &quot;) scale(&quot;).concat(s2, &quot;)&quot;) }), this.maxY = 0, this.sliceLabels = [], this.sliceSizes = [], this.prevSectorAngleArr = [];
  }
  return s(t2, [{ key: &quot;draw&quot;, value: function(t3) {
    var e2 = this, i2 = this.w, a2 = new Mi(this.ctx), s2 = a2.group({ class: &quot;apexcharts-pie&quot; });
    if (i2.globals.noData) return s2;
    for (var r2 = 0, n2 = 0; n2 &lt; t3.length; n2++) r2 += v.negToZero(t3[n2]);
    var o2 = [], l2 = a2.group();
    0 === r2 &amp;&amp; (r2 = 1e-5), t3.forEach(function(t4) {
      e2.maxY = Math.max(e2.maxY, t4);
    }), i2.config.yaxis[0].max &amp;&amp; (this.maxY = i2.config.yaxis[0].max), &quot;back&quot; === i2.config.grid.position &amp;&amp; &quot;polarArea&quot; === this.chartType &amp;&amp; this.drawPolarElements(s2);
    for (var h2 = 0; h2 &lt; t3.length; h2++) {
      var c2 = this.fullAngle * v.negToZero(t3[h2]) / r2;
      o2.push(c2), &quot;polarArea&quot; === this.chartType ? (o2[h2] = this.fullAngle / t3.length, this.sliceSizes.push(i2.globals.radialSize * t3[h2] / this.maxY)) : this.sliceSizes.push(i2.globals.radialSize);
    }
    if (i2.globals.dataChanged) {
      for (var d2, u2 = 0, g2 = 0; g2 &lt; i2.globals.previousPaths.length; g2++) u2 += v.negToZero(i2.globals.previousPaths[g2]);
      for (var p2 = 0; p2 &lt; i2.globals.previousPaths.length; p2++) d2 = this.fullAngle * v.negToZero(i2.globals.previousPaths[p2]) / u2, this.prevSectorAngleArr.push(d2);
    }
    if (this.donutSize &lt; 0 &amp;&amp; (this.donutSize = 0), &quot;donut&quot; === this.chartType) {
      var f2 = a2.drawCircle(this.donutSize);
      f2.attr({ cx: this.centerX, cy: this.centerY, fill: i2.config.plotOptions.pie.donut.background ? i2.config.plotOptions.pie.donut.background : &quot;transparent&quot; }), l2.add(f2);
    }
    var x2 = this.drawArcs(o2, t3);
    if (this.sliceLabels.forEach(function(t4) {
      x2.add(t4);
    }), l2.attr({ transform: &quot;translate(&quot;.concat(this.translateX, &quot;, &quot;).concat(this.translateY, &quot;) scale(&quot;).concat(i2.config.plotOptions.pie.customScale, &quot;)&quot;) }), l2.add(x2), s2.add(l2), this.donutDataLabels.show) {
      var b2 = this.renderInnerDataLabels(this.dataLabelsGroup, this.donutDataLabels, { hollowSize: this.donutSize, centerX: this.centerX, centerY: this.centerY, opacity: this.donutDataLabels.show });
      s2.add(b2);
    }
    return &quot;front&quot; === i2.config.grid.position &amp;&amp; &quot;polarArea&quot; === this.chartType &amp;&amp; this.drawPolarElements(s2), s2;
  } }, { key: &quot;drawArcs&quot;, value: function(t3, e2) {
    var i2 = this.w, a2 = new Li(this.ctx), s2 = new Mi(this.ctx), r2 = new ji(this.ctx), n2 = s2.group({ class: &quot;apexcharts-slices&quot; }), o2 = this.initialAngle, l2 = this.initialAngle, h2 = this.initialAngle, c2 = this.initialAngle;
    this.strokeWidth = i2.config.stroke.show ? i2.config.stroke.width : 0;
    for (var d2 = 0; d2 &lt; t3.length; d2++) {
      var u2 = s2.group({ class: &quot;apexcharts-series apexcharts-pie-series&quot;, seriesName: v.escapeString(i2.globals.seriesNames[d2]), rel: d2 + 1, &quot;data:realIndex&quot;: d2 });
      n2.add(u2), l2 = c2, h2 = (o2 = h2) + t3[d2], c2 = l2 + this.prevSectorAngleArr[d2];
      var g2 = h2 &lt; o2 ? this.fullAngle + h2 - o2 : h2 - o2, p2 = r2.fillPath({ seriesNumber: d2, size: this.sliceSizes[d2], value: e2[d2] }), f2 = this.getChangedPath(l2, c2), x2 = s2.drawPath({ d: f2, stroke: Array.isArray(this.lineColorArr) ? this.lineColorArr[d2] : this.lineColorArr, strokeWidth: 0, fill: p2, fillOpacity: i2.config.fill.opacity, classes: &quot;apexcharts-pie-area apexcharts-&quot;.concat(this.chartType.toLowerCase(), &quot;-slice-&quot;).concat(d2) });
      if (x2.attr({ index: 0, j: d2 }), a2.setSelectionFilter(x2, 0, d2), i2.config.chart.dropShadow.enabled) {
        var b2 = i2.config.chart.dropShadow;
        a2.dropShadow(x2, b2, d2);
      }
      this.addListeners(x2, this.donutDataLabels), Mi.setAttrs(x2.node, { &quot;data:angle&quot;: g2, &quot;data:startAngle&quot;: o2, &quot;data:strokeWidth&quot;: this.strokeWidth, &quot;data:value&quot;: e2[d2] });
      var m2 = { x: 0, y: 0 };
      &quot;pie&quot; === this.chartType || &quot;polarArea&quot; === this.chartType ? m2 = v.polarToCartesian(this.centerX, this.centerY, i2.globals.radialSize / 1.25 + i2.config.plotOptions.pie.dataLabels.offset, (o2 + g2 / 2) % this.fullAngle) : &quot;donut&quot; === this.chartType &amp;&amp; (m2 = v.polarToCartesian(this.centerX, this.centerY, (i2.globals.radialSize + this.donutSize) / 2 + i2.config.plotOptions.pie.dataLabels.offset, (o2 + g2 / 2) % this.fullAngle)), u2.add(x2);
      var y2 = 0;
      if (!this.initialAnim || i2.globals.resized || i2.globals.dataChanged ? this.animBeginArr.push(0) : (0 === (y2 = g2 / this.fullAngle * i2.config.chart.animations.speed) &amp;&amp; (y2 = 1), this.animDur = y2 + this.animDur, this.animBeginArr.push(this.animDur)), this.dynamicAnim &amp;&amp; i2.globals.dataChanged ? this.animatePaths(x2, { size: this.sliceSizes[d2], endAngle: h2, startAngle: o2, prevStartAngle: l2, prevEndAngle: c2, animateStartingPos: true, i: d2, animBeginArr: this.animBeginArr, shouldSetPrevPaths: true, dur: i2.config.chart.animations.dynamicAnimation.speed }) : this.animatePaths(x2, { size: this.sliceSizes[d2], endAngle: h2, startAngle: o2, i: d2, totalItems: t3.length - 1, animBeginArr: this.animBeginArr, dur: y2 }), i2.config.plotOptions.pie.expandOnClick &amp;&amp; &quot;polarArea&quot; !== this.chartType &amp;&amp; x2.node.addEventListener(&quot;mouseup&quot;, this.pieClicked.bind(this, d2)), void 0 !== i2.globals.selectedDataPoints[0] &amp;&amp; i2.globals.selectedDataPoints[0].indexOf(d2) &gt; -1 &amp;&amp; this.pieClicked(d2), i2.config.dataLabels.enabled) {
        var w2 = m2.x, k2 = m2.y, A2 = 100 * g2 / this.fullAngle + &quot;%&quot;;
        if (0 !== g2 &amp;&amp; i2.config.plotOptions.pie.dataLabels.minAngleToShowLabel &lt; t3[d2]) {
          var C2 = i2.config.dataLabels.formatter;
          void 0 !== C2 &amp;&amp; (A2 = C2(i2.globals.seriesPercent[d2][0], { seriesIndex: d2, w: i2 }));
          var S2 = i2.globals.dataLabels.style.colors[d2], L2 = s2.group({ class: &quot;apexcharts-datalabels&quot; }), M2 = s2.drawText({ x: w2, y: k2, text: A2, textAnchor: &quot;middle&quot;, fontSize: i2.config.dataLabels.style.fontSize, fontFamily: i2.config.dataLabels.style.fontFamily, fontWeight: i2.config.dataLabels.style.fontWeight, foreColor: S2 });
          if (L2.add(M2), i2.config.dataLabels.dropShadow.enabled) {
            var P2 = i2.config.dataLabels.dropShadow;
            a2.dropShadow(M2, P2);
          }
          M2.node.classList.add(&quot;apexcharts-pie-label&quot;), i2.config.chart.animations.animate &amp;&amp; false === i2.globals.resized &amp;&amp; (M2.node.classList.add(&quot;apexcharts-pie-label-delay&quot;), M2.node.style.animationDelay = i2.config.chart.animations.speed / 940 + &quot;s&quot;), this.sliceLabels.push(L2);
        }
      }
    }
    return n2;
  } }, { key: &quot;addListeners&quot;, value: function(t3, e2) {
    var i2 = new Mi(this.ctx);
    t3.node.addEventListener(&quot;mouseenter&quot;, i2.pathMouseEnter.bind(this, t3)), t3.node.addEventListener(&quot;mouseleave&quot;, i2.pathMouseLeave.bind(this, t3)), t3.node.addEventListener(&quot;mouseleave&quot;, this.revertDataLabelsInner.bind(this, t3.node, e2)), t3.node.addEventListener(&quot;mousedown&quot;, i2.pathMouseDown.bind(this, t3)), this.donutDataLabels.total.showAlways || (t3.node.addEventListener(&quot;mouseenter&quot;, this.printDataLabelsInner.bind(this, t3.node, e2)), t3.node.addEventListener(&quot;mousedown&quot;, this.printDataLabelsInner.bind(this, t3.node, e2)));
  } }, { key: &quot;animatePaths&quot;, value: function(t3, e2) {
    var i2 = this.w, a2 = e2.endAngle &lt; e2.startAngle ? this.fullAngle + e2.endAngle - e2.startAngle : e2.endAngle - e2.startAngle, s2 = a2, r2 = e2.startAngle, n2 = e2.startAngle;
    void 0 !== e2.prevStartAngle &amp;&amp; void 0 !== e2.prevEndAngle &amp;&amp; (r2 = e2.prevEndAngle, s2 = e2.prevEndAngle &lt; e2.prevStartAngle ? this.fullAngle + e2.prevEndAngle - e2.prevStartAngle : e2.prevEndAngle - e2.prevStartAngle), e2.i === i2.config.series.length - 1 &amp;&amp; (a2 + n2 &gt; this.fullAngle ? e2.endAngle = e2.endAngle - (a2 + n2) : a2 + n2 &lt; this.fullAngle &amp;&amp; (e2.endAngle = e2.endAngle + (this.fullAngle - (a2 + n2)))), a2 === this.fullAngle &amp;&amp; (a2 = this.fullAngle - 0.01), this.animateArc(t3, r2, n2, a2, s2, e2);
  } }, { key: &quot;animateArc&quot;, value: function(t3, e2, i2, a2, s2, r2) {
    var n2, o2 = this, l2 = this.w, h2 = new y(this.ctx), c2 = r2.size;
    (isNaN(e2) || isNaN(s2)) &amp;&amp; (e2 = i2, s2 = a2, r2.dur = 0);
    var d2 = a2, u2 = i2, g2 = e2 &lt; i2 ? this.fullAngle + e2 - i2 : e2 - i2;
    l2.globals.dataChanged &amp;&amp; r2.shouldSetPrevPaths &amp;&amp; r2.prevEndAngle &amp;&amp; (n2 = o2.getPiePath({ me: o2, startAngle: r2.prevStartAngle, angle: r2.prevEndAngle &lt; r2.prevStartAngle ? this.fullAngle + r2.prevEndAngle - r2.prevStartAngle : r2.prevEndAngle - r2.prevStartAngle, size: c2 }), t3.attr({ d: n2 })), 0 !== r2.dur ? t3.animate(r2.dur, r2.animBeginArr[r2.i]).after(function() {
      &quot;pie&quot; !== o2.chartType &amp;&amp; &quot;donut&quot; !== o2.chartType &amp;&amp; &quot;polarArea&quot; !== o2.chartType || this.animate(l2.config.chart.animations.dynamicAnimation.speed).attr({ &quot;stroke-width&quot;: o2.strokeWidth }), r2.i === l2.config.series.length - 1 &amp;&amp; h2.animationCompleted(t3);
    }).during(function(l3) {
      d2 = g2 + (a2 - g2) * l3, r2.animateStartingPos &amp;&amp; (d2 = s2 + (a2 - s2) * l3, u2 = e2 - s2 + (i2 - (e2 - s2)) * l3), n2 = o2.getPiePath({ me: o2, startAngle: u2, angle: d2, size: c2 }), t3.node.setAttribute(&quot;data:pathOrig&quot;, n2), t3.attr({ d: n2 });
    }) : (n2 = o2.getPiePath({ me: o2, startAngle: u2, angle: a2, size: c2 }), r2.isTrack || (l2.globals.animationEnded = true), t3.node.setAttribute(&quot;data:pathOrig&quot;, n2), t3.attr({ d: n2, &quot;stroke-width&quot;: o2.strokeWidth }));
  } }, { key: &quot;pieClicked&quot;, value: function(t3) {
    var e2, i2 = this.w, a2 = this, s2 = a2.sliceSizes[t3] + (i2.config.plotOptions.pie.expandOnClick ? 4 : 0), r2 = i2.globals.dom.Paper.findOne(&quot;.apexcharts-&quot;.concat(a2.chartType.toLowerCase(), &quot;-slice-&quot;).concat(t3));
    if (&quot;true&quot; !== r2.attr(&quot;data:pieClicked&quot;)) {
      var n2 = i2.globals.dom.baseEl.getElementsByClassName(&quot;apexcharts-pie-area&quot;);
      Array.prototype.forEach.call(n2, function(t4) {
        t4.setAttribute(&quot;data:pieClicked&quot;, &quot;false&quot;);
        var e3 = t4.getAttribute(&quot;data:pathOrig&quot;);
        e3 &amp;&amp; t4.setAttribute(&quot;d&quot;, e3);
      }), i2.globals.capturedDataPointIndex = t3, r2.attr(&quot;data:pieClicked&quot;, &quot;true&quot;);
      var o2 = parseInt(r2.attr(&quot;data:startAngle&quot;), 10), l2 = parseInt(r2.attr(&quot;data:angle&quot;), 10);
      e2 = a2.getPiePath({ me: a2, startAngle: o2, angle: l2, size: s2 }), 360 !== l2 &amp;&amp; r2.plot(e2);
    } else {
      r2.attr({ &quot;data:pieClicked&quot;: &quot;false&quot; }), this.revertDataLabelsInner(r2.node, this.donutDataLabels);
      var h2 = r2.attr(&quot;data:pathOrig&quot;);
      r2.attr({ d: h2 });
    }
  } }, { key: &quot;getChangedPath&quot;, value: function(t3, e2) {
    var i2 = &quot;&quot;;
    return this.dynamicAnim &amp;&amp; this.w.globals.dataChanged &amp;&amp; (i2 = this.getPiePath({ me: this, startAngle: t3, angle: e2 - t3, size: this.size })), i2;
  } }, { key: &quot;getPiePath&quot;, value: function(t3) {
    var e2, i2 = t3.me, a2 = t3.startAngle, s2 = t3.angle, r2 = t3.size, n2 = new Mi(this.ctx), o2 = a2, l2 = Math.PI * (o2 - 90) / 180, h2 = s2 + a2;
    Math.ceil(h2) &gt;= this.fullAngle + this.w.config.plotOptions.pie.startAngle % this.fullAngle &amp;&amp; (h2 = this.fullAngle + this.w.config.plotOptions.pie.startAngle % this.fullAngle - 0.01), Math.ceil(h2) &gt; this.fullAngle &amp;&amp; (h2 -= this.fullAngle);
    var c2 = Math.PI * (h2 - 90) / 180, d2 = i2.centerX + r2 * Math.cos(l2), u2 = i2.centerY + r2 * Math.sin(l2), g2 = i2.centerX + r2 * Math.cos(c2), p2 = i2.centerY + r2 * Math.sin(c2), f2 = v.polarToCartesian(i2.centerX, i2.centerY, i2.donutSize, h2), x2 = v.polarToCartesian(i2.centerX, i2.centerY, i2.donutSize, o2), b2 = s2 &gt; 180 ? 1 : 0, m2 = [&quot;M&quot;, d2, u2, &quot;A&quot;, r2, r2, 0, b2, 1, g2, p2];
    return e2 = &quot;donut&quot; === i2.chartType ? [].concat(m2, [&quot;L&quot;, f2.x, f2.y, &quot;A&quot;, i2.donutSize, i2.donutSize, 0, b2, 0, x2.x, x2.y, &quot;L&quot;, d2, u2, &quot;z&quot;]).join(&quot; &quot;) : &quot;pie&quot; === i2.chartType || &quot;polarArea&quot; === i2.chartType ? [].concat(m2, [&quot;L&quot;, i2.centerX, i2.centerY, &quot;L&quot;, d2, u2]).join(&quot; &quot;) : [].concat(m2).join(&quot; &quot;), n2.roundPathCorners(e2, 2 * this.strokeWidth);
  } }, { key: &quot;drawPolarElements&quot;, value: function(t3) {
    var e2 = this.w, i2 = new ta(this.ctx), a2 = new Mi(this.ctx), s2 = new Ra(this.ctx), r2 = a2.group(), n2 = a2.group(), o2 = i2.niceScale(0, Math.ceil(this.maxY), 0), l2 = o2.result.reverse(), h2 = o2.result.length;
    this.maxY = o2.niceMax;
    for (var c2 = e2.globals.radialSize, d2 = c2 / (h2 - 1), u2 = 0; u2 &lt; h2 - 1; u2++) {
      var g2 = a2.drawCircle(c2);
      if (g2.attr({ cx: this.centerX, cy: this.centerY, fill: &quot;none&quot;, &quot;stroke-width&quot;: e2.config.plotOptions.polarArea.rings.strokeWidth, stroke: e2.config.plotOptions.polarArea.rings.strokeColor }), e2.config.yaxis[0].show) {
        var p2 = s2.drawYAxisTexts(this.centerX, this.centerY - c2 + parseInt(e2.config.yaxis[0].labels.style.fontSize, 10) / 2, u2, l2[u2]);
        n2.add(p2);
      }
      r2.add(g2), c2 -= d2;
    }
    this.drawSpokes(t3), t3.add(r2), t3.add(n2);
  } }, { key: &quot;renderInnerDataLabels&quot;, value: function(t3, e2, i2) {
    var a2 = this.w, s2 = new Mi(this.ctx), r2 = e2.total.show;
    t3.node.innerHTML = &quot;&quot;, t3.node.style.opacity = i2.opacity;
    var n2, o2, l2 = i2.centerX, h2 = this.donutDataLabels.total.label ? i2.centerY : i2.centerY - i2.centerY / 6;
    n2 = void 0 === e2.name.color ? a2.globals.colors[0] : e2.name.color;
    var c2 = e2.name.fontSize, d2 = e2.name.fontFamily, u2 = e2.name.fontWeight;
    o2 = void 0 === e2.value.color ? a2.config.chart.foreColor : e2.value.color;
    var g2 = e2.value.formatter, p2 = &quot;&quot;, f2 = &quot;&quot;;
    if (r2 ? (n2 = e2.total.color, c2 = e2.total.fontSize, d2 = e2.total.fontFamily, u2 = e2.total.fontWeight, f2 = this.donutDataLabels.total.label ? e2.total.label : &quot;&quot;, p2 = e2.total.formatter(a2)) : 1 === a2.globals.series.length &amp;&amp; (p2 = g2(a2.globals.series[0], a2), f2 = a2.globals.seriesNames[0]), f2 &amp;&amp; (f2 = e2.name.formatter(f2, e2.total.show, a2)), e2.name.show) {
      var x2 = s2.drawText({ x: l2, y: h2 + parseFloat(e2.name.offsetY), text: f2, textAnchor: &quot;middle&quot;, foreColor: n2, fontSize: c2, fontWeight: u2, fontFamily: d2 });
      x2.node.classList.add(&quot;apexcharts-datalabel-label&quot;), t3.add(x2);
    }
    if (e2.value.show) {
      var b2 = e2.name.show ? parseFloat(e2.value.offsetY) + 16 : e2.value.offsetY, m2 = s2.drawText({ x: l2, y: h2 + b2, text: p2, textAnchor: &quot;middle&quot;, foreColor: o2, fontWeight: e2.value.fontWeight, fontSize: e2.value.fontSize, fontFamily: e2.value.fontFamily });
      m2.node.classList.add(&quot;apexcharts-datalabel-value&quot;), t3.add(m2);
    }
    return t3;
  } }, { key: &quot;printInnerLabels&quot;, value: function(t3, e2, i2, a2) {
    var s2, r2 = this.w;
    a2 ? s2 = void 0 === t3.name.color ? r2.globals.colors[parseInt(a2.parentNode.getAttribute(&quot;rel&quot;), 10) - 1] : t3.name.color : r2.globals.series.length &gt; 1 &amp;&amp; t3.total.show &amp;&amp; (s2 = t3.total.color);
    var n2 = r2.globals.dom.baseEl.querySelector(&quot;.apexcharts-datalabel-label&quot;), o2 = r2.globals.dom.baseEl.querySelector(&quot;.apexcharts-datalabel-value&quot;);
    i2 = (0, t3.value.formatter)(i2, r2), a2 || &quot;function&quot; != typeof t3.total.formatter || (i2 = t3.total.formatter(r2));
    var l2 = e2 === t3.total.label;
    e2 = this.donutDataLabels.total.label ? t3.name.formatter(e2, l2, r2) : &quot;&quot;, null !== n2 &amp;&amp; (n2.textContent = e2), null !== o2 &amp;&amp; (o2.textContent = i2), null !== n2 &amp;&amp; (n2.style.fill = s2);
  } }, { key: &quot;printDataLabelsInner&quot;, value: function(t3, e2) {
    var i2 = this.w, a2 = t3.getAttribute(&quot;data:value&quot;), s2 = i2.globals.seriesNames[parseInt(t3.parentNode.getAttribute(&quot;rel&quot;), 10) - 1];
    i2.globals.series.length &gt; 1 &amp;&amp; this.printInnerLabels(e2, s2, a2, t3);
    var r2 = i2.globals.dom.baseEl.querySelector(&quot;.apexcharts-datalabels-group&quot;);
    null !== r2 &amp;&amp; (r2.style.opacity = 1);
  } }, { key: &quot;drawSpokes&quot;, value: function(t3) {
    var e2 = this, i2 = this.w, a2 = new Mi(this.ctx), s2 = i2.config.plotOptions.polarArea.spokes;
    if (0 !== s2.strokeWidth) {
      for (var r2 = [], n2 = 360 / i2.globals.series.length, o2 = 0; o2 &lt; i2.globals.series.length; o2++) r2.push(v.polarToCartesian(this.centerX, this.centerY, i2.globals.radialSize, i2.config.plotOptions.pie.startAngle + n2 * o2));
      r2.forEach(function(i3, r3) {
        var n3 = a2.drawLine(i3.x, i3.y, e2.centerX, e2.centerY, Array.isArray(s2.connectorColors) ? s2.connectorColors[r3] : s2.connectorColors);
        t3.add(n3);
      });
    }
  } }, { key: &quot;revertDataLabelsInner&quot;, value: function() {
    var t3 = this.w;
    if (this.donutDataLabels.show) {
      var e2 = t3.globals.dom.Paper.findOne(&quot;.apexcharts-datalabels-group&quot;), i2 = this.renderInnerDataLabels(e2, this.donutDataLabels, { hollowSize: this.donutSize, centerX: this.centerX, centerY: this.centerY, opacity: this.donutDataLabels.show });
      t3.globals.dom.Paper.findOne(&quot;.apexcharts-radialbar, .apexcharts-pie&quot;).add(i2);
    }
  } }]), t2;
}();
var Ya = function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w, this.chartType = this.w.config.chart.type, this.initialAnim = this.w.config.chart.animations.enabled, this.dynamicAnim = this.initialAnim &amp;&amp; this.w.config.chart.animations.dynamicAnimation.enabled, this.animDur = 0;
    var a2 = this.w;
    this.graphics = new Mi(this.ctx), this.lineColorArr = void 0 !== a2.globals.stroke.colors ? a2.globals.stroke.colors : a2.globals.colors, this.defaultSize = a2.globals.svgHeight &lt; a2.globals.svgWidth ? a2.globals.gridHeight : a2.globals.gridWidth, this.isLog = a2.config.yaxis[0].logarithmic, this.logBase = a2.config.yaxis[0].logBase, this.coreUtils = new Pi(this.ctx), this.maxValue = this.isLog ? this.coreUtils.getLogVal(this.logBase, a2.globals.maxY, 0) : a2.globals.maxY, this.minValue = this.isLog ? this.coreUtils.getLogVal(this.logBase, this.w.globals.minY, 0) : a2.globals.minY, this.polygons = a2.config.plotOptions.radar.polygons, this.strokeWidth = a2.config.stroke.show ? a2.config.stroke.width : 0, this.size = this.defaultSize / 2.1 - this.strokeWidth - a2.config.chart.dropShadow.blur, a2.config.xaxis.labels.show &amp;&amp; (this.size = this.size - a2.globals.xAxisLabelsWidth / 1.75), void 0 !== a2.config.plotOptions.radar.size &amp;&amp; (this.size = a2.config.plotOptions.radar.size), this.dataRadiusOfPercent = [], this.dataRadius = [], this.angleArr = [], this.yaxisLabelsTextsPos = [];
  }
  return s(t2, [{ key: &quot;draw&quot;, value: function(t3) {
    var e2 = this, i2 = this.w, a2 = new ji(this.ctx), s2 = [], r2 = new qi(this.ctx);
    t3.length &amp;&amp; (this.dataPointsLen = t3[i2.globals.maxValsInArrayIndex].length), this.disAngle = 2 * Math.PI / this.dataPointsLen;
    var n2 = i2.globals.gridWidth / 2, o2 = i2.globals.gridHeight / 2, l2 = n2 + i2.config.plotOptions.radar.offsetX, h2 = o2 + i2.config.plotOptions.radar.offsetY, c2 = this.graphics.group({ class: &quot;apexcharts-radar-series apexcharts-plot-series&quot;, transform: &quot;translate(&quot;.concat(l2 || 0, &quot;, &quot;).concat(h2 || 0, &quot;)&quot;) }), d2 = [], g2 = null, p2 = null;
    if (this.yaxisLabels = this.graphics.group({ class: &quot;apexcharts-yaxis&quot; }), t3.forEach(function(t4, n3) {
      var o3 = t4.length === i2.globals.dataPoints, l3 = e2.graphics.group().attr({ class: &quot;apexcharts-series&quot;, &quot;data:longestSeries&quot;: o3, seriesName: v.escapeString(i2.globals.seriesNames[n3]), rel: n3 + 1, &quot;data:realIndex&quot;: n3 });
      e2.dataRadiusOfPercent[n3] = [], e2.dataRadius[n3] = [], e2.angleArr[n3] = [], t4.forEach(function(t5, i3) {
        var a3 = Math.abs(e2.maxValue - e2.minValue);
        t5 -= e2.minValue, e2.isLog &amp;&amp; (t5 = e2.coreUtils.getLogVal(e2.logBase, t5, 0)), e2.dataRadiusOfPercent[n3][i3] = t5 / a3, e2.dataRadius[n3][i3] = e2.dataRadiusOfPercent[n3][i3] * e2.size, e2.angleArr[n3][i3] = i3 * e2.disAngle;
      }), d2 = e2.getDataPointsPos(e2.dataRadius[n3], e2.angleArr[n3]);
      var h3 = e2.createPaths(d2, { x: 0, y: 0 });
      g2 = e2.graphics.group({ class: &quot;apexcharts-series-markers-wrap apexcharts-element-hidden&quot; }), p2 = e2.graphics.group({ class: &quot;apexcharts-datalabels&quot;, &quot;data:realIndex&quot;: n3 }), i2.globals.delayedElements.push({ el: g2.node, index: n3 });
      var c3 = { i: n3, realIndex: n3, animationDelay: n3, initialSpeed: i2.config.chart.animations.speed, dataChangeSpeed: i2.config.chart.animations.dynamicAnimation.speed, className: &quot;apexcharts-radar&quot;, shouldClipToGrid: false, bindEventsOnPaths: false, stroke: i2.globals.stroke.colors[n3], strokeLineCap: i2.config.stroke.lineCap }, f3 = null;
      i2.globals.previousPaths.length &gt; 0 &amp;&amp; (f3 = e2.getPreviousPath(n3));
      for (var x2 = 0; x2 &lt; h3.linePathsTo.length; x2++) {
        var b2 = e2.graphics.renderPaths(u(u({}, c3), {}, { pathFrom: null === f3 ? h3.linePathsFrom[x2] : f3, pathTo: h3.linePathsTo[x2], strokeWidth: Array.isArray(e2.strokeWidth) ? e2.strokeWidth[n3] : e2.strokeWidth, fill: &quot;none&quot;, drawShadow: false }));
        l3.add(b2);
        var m2 = a2.fillPath({ seriesNumber: n3 }), y2 = e2.graphics.renderPaths(u(u({}, c3), {}, { pathFrom: null === f3 ? h3.areaPathsFrom[x2] : f3, pathTo: h3.areaPathsTo[x2], strokeWidth: 0, fill: m2, drawShadow: false }));
        if (i2.config.chart.dropShadow.enabled) {
          var w2 = new Li(e2.ctx), k2 = i2.config.chart.dropShadow;
          w2.dropShadow(y2, Object.assign({}, k2, { noUserSpaceOnUse: true }), n3);
        }
        l3.add(y2);
      }
      t4.forEach(function(t5, a3) {
        var s3 = new Vi(e2.ctx).getMarkerConfig({ cssClass: &quot;apexcharts-marker&quot;, seriesIndex: n3, dataPointIndex: a3 }), o4 = e2.graphics.drawMarker(d2[a3].x, d2[a3].y, s3);
        o4.attr(&quot;rel&quot;, a3), o4.attr(&quot;j&quot;, a3), o4.attr(&quot;index&quot;, n3), o4.node.setAttribute(&quot;default-marker-size&quot;, s3.pSize);
        var h4 = e2.graphics.group({ class: &quot;apexcharts-series-markers&quot; });
        h4 &amp;&amp; h4.add(o4), g2.add(h4), l3.add(g2);
        var c4 = i2.config.dataLabels;
        if (c4.enabled) {
          var f4 = c4.formatter(i2.globals.series[n3][a3], { seriesIndex: n3, dataPointIndex: a3, w: i2 });
          r2.plotDataLabelsText({ x: d2[a3].x, y: d2[a3].y, text: f4, textAnchor: &quot;middle&quot;, i: n3, j: n3, parent: p2, offsetCorrection: false, dataLabelsConfig: u({}, c4) });
        }
        l3.add(p2);
      }), s2.push(l3);
    }), this.drawPolygons({ parent: c2 }), i2.config.xaxis.labels.show) {
      var f2 = this.drawXAxisTexts();
      c2.add(f2);
    }
    return s2.forEach(function(t4) {
      c2.add(t4);
    }), c2.add(this.yaxisLabels), c2;
  } }, { key: &quot;drawPolygons&quot;, value: function(t3) {
    for (var e2 = this, i2 = this.w, a2 = t3.parent, s2 = new Ra(this.ctx), r2 = i2.globals.yAxisScale[0].result.reverse(), n2 = r2.length, o2 = [], l2 = this.size / (n2 - 1), h2 = 0; h2 &lt; n2; h2++) o2[h2] = l2 * h2;
    o2.reverse();
    var c2 = [], d2 = [];
    o2.forEach(function(t4, i3) {
      var a3 = v.getPolygonPos(t4, e2.dataPointsLen), s3 = &quot;&quot;;
      a3.forEach(function(t5, a4) {
        if (0 === i3) {
          var r3 = e2.graphics.drawLine(t5.x, t5.y, 0, 0, Array.isArray(e2.polygons.connectorColors) ? e2.polygons.connectorColors[a4] : e2.polygons.connectorColors);
          d2.push(r3);
        }
        0 === a4 &amp;&amp; e2.yaxisLabelsTextsPos.push({ x: t5.x, y: t5.y }), s3 += t5.x + &quot;,&quot; + t5.y + &quot; &quot;;
      }), c2.push(s3);
    }), c2.forEach(function(t4, s3) {
      var r3 = e2.polygons.strokeColors, n3 = e2.polygons.strokeWidth, o3 = e2.graphics.drawPolygon(t4, Array.isArray(r3) ? r3[s3] : r3, Array.isArray(n3) ? n3[s3] : n3, i2.globals.radarPolygons.fill.colors[s3]);
      a2.add(o3);
    }), d2.forEach(function(t4) {
      a2.add(t4);
    }), i2.config.yaxis[0].show &amp;&amp; this.yaxisLabelsTextsPos.forEach(function(t4, i3) {
      var a3 = s2.drawYAxisTexts(t4.x, t4.y, i3, r2[i3]);
      e2.yaxisLabels.add(a3);
    });
  } }, { key: &quot;drawXAxisTexts&quot;, value: function() {
    var t3 = this, e2 = this.w, i2 = e2.config.xaxis.labels, a2 = this.graphics.group({ class: &quot;apexcharts-xaxis&quot; }), s2 = v.getPolygonPos(this.size, this.dataPointsLen);
    return e2.globals.labels.forEach(function(r2, n2) {
      var o2 = e2.config.xaxis.labels.formatter, l2 = new qi(t3.ctx);
      if (s2[n2]) {
        var h2 = t3.getTextPos(s2[n2], t3.size), c2 = o2(r2, { seriesIndex: -1, dataPointIndex: n2, w: e2 });
        l2.plotDataLabelsText({ x: h2.newX, y: h2.newY, text: c2, textAnchor: h2.textAnchor, i: n2, j: n2, parent: a2, className: &quot;apexcharts-xaxis-label&quot;, color: Array.isArray(i2.style.colors) &amp;&amp; i2.style.colors[n2] ? i2.style.colors[n2] : &quot;#a8a8a8&quot;, dataLabelsConfig: u({ textAnchor: h2.textAnchor, dropShadow: { enabled: false } }, i2), offsetCorrection: false }).on(&quot;click&quot;, function(i3) {
          if (&quot;function&quot; == typeof e2.config.chart.events.xAxisLabelClick) {
            var a3 = Object.assign({}, e2, { labelIndex: n2 });
            e2.config.chart.events.xAxisLabelClick(i3, t3.ctx, a3);
          }
        });
      }
    }), a2;
  } }, { key: &quot;createPaths&quot;, value: function(t3, e2) {
    var i2 = this, a2 = [], s2 = [], r2 = [], n2 = [];
    if (t3.length) {
      s2 = [this.graphics.move(e2.x, e2.y)], n2 = [this.graphics.move(e2.x, e2.y)];
      var o2 = this.graphics.move(t3[0].x, t3[0].y), l2 = this.graphics.move(t3[0].x, t3[0].y);
      t3.forEach(function(e3, a3) {
        o2 += i2.graphics.line(e3.x, e3.y), l2 += i2.graphics.line(e3.x, e3.y), a3 === t3.length - 1 &amp;&amp; (o2 += &quot;Z&quot;, l2 += &quot;Z&quot;);
      }), a2.push(o2), r2.push(l2);
    }
    return { linePathsFrom: s2, linePathsTo: a2, areaPathsFrom: n2, areaPathsTo: r2 };
  } }, { key: &quot;getTextPos&quot;, value: function(t3, e2) {
    var i2 = &quot;middle&quot;, a2 = t3.x, s2 = t3.y;
    return Math.abs(t3.x) &gt;= 10 ? t3.x &gt; 0 ? (i2 = &quot;start&quot;, a2 += 10) : t3.x &lt; 0 &amp;&amp; (i2 = &quot;end&quot;, a2 -= 10) : i2 = &quot;middle&quot;, Math.abs(t3.y) &gt;= e2 - 10 &amp;&amp; (t3.y &lt; 0 ? s2 -= 10 : t3.y &gt; 0 &amp;&amp; (s2 += 10)), { textAnchor: i2, newX: a2, newY: s2 };
  } }, { key: &quot;getPreviousPath&quot;, value: function(t3) {
    for (var e2 = this.w, i2 = null, a2 = 0; a2 &lt; e2.globals.previousPaths.length; a2++) {
      var s2 = e2.globals.previousPaths[a2];
      s2.paths.length &gt; 0 &amp;&amp; parseInt(s2.realIndex, 10) === parseInt(t3, 10) &amp;&amp; void 0 !== e2.globals.previousPaths[a2].paths[0] &amp;&amp; (i2 = e2.globals.previousPaths[a2].paths[0].d);
    }
    return i2;
  } }, { key: &quot;getDataPointsPos&quot;, value: function(t3, e2) {
    var i2 = arguments.length &gt; 2 &amp;&amp; void 0 !== arguments[2] ? arguments[2] : this.dataPointsLen;
    t3 = t3 || [], e2 = e2 || [];
    for (var a2 = [], s2 = 0; s2 &lt; i2; s2++) {
      var r2 = {};
      r2.x = t3[s2] * Math.sin(e2[s2]), r2.y = -t3[s2] * Math.cos(e2[s2]), a2.push(r2);
    }
    return a2;
  } }]), t2;
}();
var Ha = function(t2) {
  h(r2, Ea);
  var a2 = n(r2);
  function r2(t3) {
    var s2;
    i(this, r2), (s2 = a2.call(this, t3)).ctx = t3, s2.w = t3.w, s2.animBeginArr = [0], s2.animDur = 0;
    var n2 = s2.w;
    return s2.startAngle = n2.config.plotOptions.radialBar.startAngle, s2.endAngle = n2.config.plotOptions.radialBar.endAngle, s2.totalAngle = Math.abs(n2.config.plotOptions.radialBar.endAngle - n2.config.plotOptions.radialBar.startAngle), s2.trackStartAngle = n2.config.plotOptions.radialBar.track.startAngle, s2.trackEndAngle = n2.config.plotOptions.radialBar.track.endAngle, s2.barLabels = s2.w.config.plotOptions.radialBar.barLabels, s2.donutDataLabels = s2.w.config.plotOptions.radialBar.dataLabels, s2.radialDataLabels = s2.donutDataLabels, s2.trackStartAngle || (s2.trackStartAngle = s2.startAngle), s2.trackEndAngle || (s2.trackEndAngle = s2.endAngle), 360 === s2.endAngle &amp;&amp; (s2.endAngle = 359.99), s2.margin = parseInt(n2.config.plotOptions.radialBar.track.margin, 10), s2.onBarLabelClick = s2.onBarLabelClick.bind(e(s2)), s2;
  }
  return s(r2, [{ key: &quot;draw&quot;, value: function(t3) {
    var e2 = this.w, i2 = new Mi(this.ctx), a3 = i2.group({ class: &quot;apexcharts-radialbar&quot; });
    if (e2.globals.noData) return a3;
    var s2 = i2.group(), r3 = this.defaultSize / 2, n2 = e2.globals.gridWidth / 2, o2 = this.defaultSize / 2.05;
    e2.config.chart.sparkline.enabled || (o2 = o2 - e2.config.stroke.width - e2.config.chart.dropShadow.blur);
    var l2 = e2.globals.fill.colors;
    if (e2.config.plotOptions.radialBar.track.show) {
      var h2 = this.drawTracks({ size: o2, centerX: n2, centerY: r3, colorArr: l2, series: t3 });
      s2.add(h2);
    }
    var c2 = this.drawArcs({ size: o2, centerX: n2, centerY: r3, colorArr: l2, series: t3 }), d2 = 360;
    e2.config.plotOptions.radialBar.startAngle &lt; 0 &amp;&amp; (d2 = this.totalAngle);
    var u2 = (360 - d2) / 360;
    if (e2.globals.radialSize = o2 - o2 * u2, this.radialDataLabels.value.show) {
      var g2 = Math.max(this.radialDataLabels.value.offsetY, this.radialDataLabels.name.offsetY);
      e2.globals.radialSize += g2 * u2;
    }
    return s2.add(c2.g), &quot;front&quot; === e2.config.plotOptions.radialBar.hollow.position &amp;&amp; (c2.g.add(c2.elHollow), c2.dataLabels &amp;&amp; c2.g.add(c2.dataLabels)), a3.add(s2), a3;
  } }, { key: &quot;drawTracks&quot;, value: function(t3) {
    var e2 = this.w, i2 = new Mi(this.ctx), a3 = i2.group({ class: &quot;apexcharts-tracks&quot; }), s2 = new Li(this.ctx), r3 = new ji(this.ctx), n2 = this.getStrokeWidth(t3);
    t3.size = t3.size - n2 / 2;
    for (var o2 = 0; o2 &lt; t3.series.length; o2++) {
      var l2 = i2.group({ class: &quot;apexcharts-radialbar-track apexcharts-track&quot; });
      a3.add(l2), l2.attr({ rel: o2 + 1 }), t3.size = t3.size - n2 - this.margin;
      var h2 = e2.config.plotOptions.radialBar.track, c2 = r3.fillPath({ seriesNumber: 0, size: t3.size, fillColors: Array.isArray(h2.background) ? h2.background[o2] : h2.background, solid: true }), d2 = this.trackStartAngle, u2 = this.trackEndAngle;
      Math.abs(u2) + Math.abs(d2) &gt;= 360 &amp;&amp; (u2 = 360 - Math.abs(this.startAngle) - 0.1);
      var g2 = i2.drawPath({ d: &quot;&quot;, stroke: c2, strokeWidth: n2 * parseInt(h2.strokeWidth, 10) / 100, fill: &quot;none&quot;, strokeOpacity: h2.opacity, classes: &quot;apexcharts-radialbar-area&quot; });
      if (h2.dropShadow.enabled) {
        var p2 = h2.dropShadow;
        s2.dropShadow(g2, p2);
      }
      l2.add(g2), g2.attr(&quot;id&quot;, &quot;apexcharts-radialbarTrack-&quot; + o2), this.animatePaths(g2, { centerX: t3.centerX, centerY: t3.centerY, endAngle: u2, startAngle: d2, size: t3.size, i: o2, totalItems: 2, animBeginArr: 0, dur: 0, isTrack: true });
    }
    return a3;
  } }, { key: &quot;drawArcs&quot;, value: function(t3) {
    var e2 = this.w, i2 = new Mi(this.ctx), a3 = new ji(this.ctx), s2 = new Li(this.ctx), r3 = i2.group(), n2 = this.getStrokeWidth(t3);
    t3.size = t3.size - n2 / 2;
    var o2 = e2.config.plotOptions.radialBar.hollow.background, l2 = t3.size - n2 * t3.series.length - this.margin * t3.series.length - n2 * parseInt(e2.config.plotOptions.radialBar.track.strokeWidth, 10) / 100 / 2, h2 = l2 - e2.config.plotOptions.radialBar.hollow.margin;
    void 0 !== e2.config.plotOptions.radialBar.hollow.image &amp;&amp; (o2 = this.drawHollowImage(t3, r3, l2, o2));
    var c2 = this.drawHollow({ size: h2, centerX: t3.centerX, centerY: t3.centerY, fill: o2 || &quot;transparent&quot; });
    if (e2.config.plotOptions.radialBar.hollow.dropShadow.enabled) {
      var d2 = e2.config.plotOptions.radialBar.hollow.dropShadow;
      s2.dropShadow(c2, d2);
    }
    var u2 = 1;
    !this.radialDataLabels.total.show &amp;&amp; e2.globals.series.length &gt; 1 &amp;&amp; (u2 = 0);
    var g2 = null;
    if (this.radialDataLabels.show) {
      var p2 = e2.globals.dom.Paper.findOne(&quot;.apexcharts-datalabels-group&quot;);
      g2 = this.renderInnerDataLabels(p2, this.radialDataLabels, { hollowSize: l2, centerX: t3.centerX, centerY: t3.centerY, opacity: u2 });
    }
    &quot;back&quot; === e2.config.plotOptions.radialBar.hollow.position &amp;&amp; (r3.add(c2), g2 &amp;&amp; r3.add(g2));
    var f2 = false;
    e2.config.plotOptions.radialBar.inverseOrder &amp;&amp; (f2 = true);
    for (var x2 = f2 ? t3.series.length - 1 : 0; f2 ? x2 &gt;= 0 : x2 &lt; t3.series.length; f2 ? x2-- : x2++) {
      var b2 = i2.group({ class: &quot;apexcharts-series apexcharts-radial-series&quot;, seriesName: v.escapeString(e2.globals.seriesNames[x2]) });
      r3.add(b2), b2.attr({ rel: x2 + 1, &quot;data:realIndex&quot;: x2 }), this.ctx.series.addCollapsedClassToSeries(b2, x2), t3.size = t3.size - n2 - this.margin;
      var m2 = a3.fillPath({ seriesNumber: x2, size: t3.size, value: t3.series[x2] }), y2 = this.startAngle, w2 = void 0, k2 = v.negToZero(t3.series[x2] &gt; 100 ? 100 : t3.series[x2]) / 100, A2 = Math.round(this.totalAngle * k2) + this.startAngle, C2 = void 0;
      e2.globals.dataChanged &amp;&amp; (w2 = this.startAngle, C2 = Math.round(this.totalAngle * v.negToZero(e2.globals.previousPaths[x2]) / 100) + w2), Math.abs(A2) + Math.abs(y2) &gt; 360 &amp;&amp; (A2 -= 0.01), Math.abs(C2) + Math.abs(w2) &gt; 360 &amp;&amp; (C2 -= 0.01);
      var S2 = A2 - y2, L2 = Array.isArray(e2.config.stroke.dashArray) ? e2.config.stroke.dashArray[x2] : e2.config.stroke.dashArray, M2 = i2.drawPath({ d: &quot;&quot;, stroke: m2, strokeWidth: n2, fill: &quot;none&quot;, fillOpacity: e2.config.fill.opacity, classes: &quot;apexcharts-radialbar-area apexcharts-radialbar-slice-&quot; + x2, strokeDashArray: L2 });
      if (Mi.setAttrs(M2.node, { &quot;data:angle&quot;: S2, &quot;data:value&quot;: t3.series[x2] }), e2.config.chart.dropShadow.enabled) {
        var P2 = e2.config.chart.dropShadow;
        s2.dropShadow(M2, P2, x2);
      }
      if (s2.setSelectionFilter(M2, 0, x2), this.addListeners(M2, this.radialDataLabels), b2.add(M2), M2.attr({ index: 0, j: x2 }), this.barLabels.enabled) {
        var I2 = v.polarToCartesian(t3.centerX, t3.centerY, t3.size, y2), T2 = this.barLabels.formatter(e2.globals.seriesNames[x2], { seriesIndex: x2, w: e2 }), z2 = [&quot;apexcharts-radialbar-label&quot;];
        this.barLabels.onClick || z2.push(&quot;apexcharts-no-click&quot;);
        var X2 = this.barLabels.useSeriesColors ? e2.globals.colors[x2] : e2.config.chart.foreColor;
        X2 || (X2 = e2.config.chart.foreColor);
        var R2 = I2.x + this.barLabels.offsetX, E2 = I2.y + this.barLabels.offsetY, Y2 = i2.drawText({ x: R2, y: E2, text: T2, textAnchor: &quot;end&quot;, dominantBaseline: &quot;middle&quot;, fontFamily: this.barLabels.fontFamily, fontWeight: this.barLabels.fontWeight, fontSize: this.barLabels.fontSize, foreColor: X2, cssClass: z2.join(&quot; &quot;) });
        Y2.on(&quot;click&quot;, this.onBarLabelClick), Y2.attr({ rel: x2 + 1 }), 0 !== y2 &amp;&amp; Y2.attr({ &quot;transform-origin&quot;: &quot;&quot;.concat(R2, &quot; &quot;).concat(E2), transform: &quot;rotate(&quot;.concat(y2, &quot; 0 0)&quot;) }), b2.add(Y2);
      }
      var H2 = 0;
      !this.initialAnim || e2.globals.resized || e2.globals.dataChanged || (H2 = e2.config.chart.animations.speed), e2.globals.dataChanged &amp;&amp; (H2 = e2.config.chart.animations.dynamicAnimation.speed), this.animDur = H2 / (1.2 * t3.series.length) + this.animDur, this.animBeginArr.push(this.animDur), this.animatePaths(M2, { centerX: t3.centerX, centerY: t3.centerY, endAngle: A2, startAngle: y2, prevEndAngle: C2, prevStartAngle: w2, size: t3.size, i: x2, totalItems: 2, animBeginArr: this.animBeginArr, dur: H2, shouldSetPrevPaths: true });
    }
    return { g: r3, elHollow: c2, dataLabels: g2 };
  } }, { key: &quot;drawHollow&quot;, value: function(t3) {
    var e2 = new Mi(this.ctx).drawCircle(2 * t3.size);
    return e2.attr({ class: &quot;apexcharts-radialbar-hollow&quot;, cx: t3.centerX, cy: t3.centerY, r: t3.size, fill: t3.fill }), e2;
  } }, { key: &quot;drawHollowImage&quot;, value: function(t3, e2, i2, a3) {
    var s2 = this.w, r3 = new ji(this.ctx), n2 = v.randomId(), o2 = s2.config.plotOptions.radialBar.hollow.image;
    if (s2.config.plotOptions.radialBar.hollow.imageClipped) r3.clippedImgArea({ width: i2, height: i2, image: o2, patternID: &quot;pattern&quot;.concat(s2.globals.cuid).concat(n2) }), a3 = &quot;url(#pattern&quot;.concat(s2.globals.cuid).concat(n2, &quot;)&quot;);
    else {
      var l2 = s2.config.plotOptions.radialBar.hollow.imageWidth, h2 = s2.config.plotOptions.radialBar.hollow.imageHeight;
      if (void 0 === l2 &amp;&amp; void 0 === h2) {
        var c2 = s2.globals.dom.Paper.image(o2, function(e3) {
          this.move(t3.centerX - e3.width / 2 + s2.config.plotOptions.radialBar.hollow.imageOffsetX, t3.centerY - e3.height / 2 + s2.config.plotOptions.radialBar.hollow.imageOffsetY);
        });
        e2.add(c2);
      } else {
        var d2 = s2.globals.dom.Paper.image(o2, function(e3) {
          this.move(t3.centerX - l2 / 2 + s2.config.plotOptions.radialBar.hollow.imageOffsetX, t3.centerY - h2 / 2 + s2.config.plotOptions.radialBar.hollow.imageOffsetY), this.size(l2, h2);
        });
        e2.add(d2);
      }
    }
    return a3;
  } }, { key: &quot;getStrokeWidth&quot;, value: function(t3) {
    var e2 = this.w;
    return t3.size * (100 - parseInt(e2.config.plotOptions.radialBar.hollow.size, 10)) / 100 / (t3.series.length + 1) - this.margin;
  } }, { key: &quot;onBarLabelClick&quot;, value: function(t3) {
    var e2 = parseInt(t3.target.getAttribute(&quot;rel&quot;), 10) - 1, i2 = this.barLabels.onClick, a3 = this.w;
    i2 &amp;&amp; i2(a3.globals.seriesNames[e2], { w: a3, seriesIndex: e2 });
  } }]), r2;
}();
var Oa = function(t2) {
  h(a2, Pa);
  var e2 = n(a2);
  function a2() {
    return i(this, a2), e2.apply(this, arguments);
  }
  return s(a2, [{ key: &quot;draw&quot;, value: function(t3, e3) {
    var i2 = this.w, a3 = new Mi(this.ctx);
    this.rangeBarOptions = this.w.config.plotOptions.rangeBar, this.series = t3, this.seriesRangeStart = i2.globals.seriesRangeStart, this.seriesRangeEnd = i2.globals.seriesRangeEnd, this.barHelpers.initVariables(t3);
    for (var s2 = a3.group({ class: &quot;apexcharts-rangebar-series apexcharts-plot-series&quot; }), r2 = 0; r2 &lt; t3.length; r2++) {
      var n2, o2, l2, h2, c2 = void 0, d2 = void 0, g2 = i2.globals.comboCharts ? e3[r2] : r2, p2 = this.barHelpers.getGroupIndex(g2).columnGroupIndex, f2 = a3.group({ class: &quot;apexcharts-series&quot;, seriesName: v.escapeString(i2.globals.seriesNames[g2]), rel: r2 + 1, &quot;data:realIndex&quot;: g2 });
      this.ctx.series.addCollapsedClassToSeries(f2, g2), t3[r2].length &gt; 0 &amp;&amp; (this.visibleI = this.visibleI + 1);
      var x2 = 0, b2 = 0, m2 = 0;
      this.yRatio.length &gt; 1 &amp;&amp; (this.yaxisIndex = i2.globals.seriesYAxisReverseMap[g2][0], m2 = g2);
      var y2 = this.barHelpers.initialPositions(g2);
      d2 = y2.y, h2 = y2.zeroW, c2 = y2.x, b2 = y2.barWidth, x2 = y2.barHeight, n2 = y2.xDivision, o2 = y2.yDivision, l2 = y2.zeroH;
      for (var w2 = a3.group({ class: &quot;apexcharts-datalabels&quot;, &quot;data:realIndex&quot;: g2 }), k2 = a3.group({ class: &quot;apexcharts-rangebar-goals-markers&quot; }), A2 = 0; A2 &lt; i2.globals.dataPoints; A2++) {
        var C2 = this.barHelpers.getStrokeWidth(r2, A2, g2), S2 = this.seriesRangeStart[r2][A2], L2 = this.seriesRangeEnd[r2][A2], M2 = null, P2 = null, I2 = null, T2 = { x: c2, y: d2, strokeWidth: C2, elSeries: f2 }, z2 = this.seriesLen;
        if (i2.config.plotOptions.bar.rangeBarGroupRows &amp;&amp; (z2 = 1), void 0 === i2.config.series[r2].data[A2]) break;
        if (this.isHorizontal) {
          I2 = d2 + x2 * this.visibleI;
          var X2 = (o2 - x2 * z2) / 2;
          if (i2.config.series[r2].data[A2].x) {
            var R2 = this.detectOverlappingBars({ i: r2, j: A2, barYPosition: I2, srty: X2, barHeight: x2, yDivision: o2, initPositions: y2 });
            x2 = R2.barHeight, I2 = R2.barYPosition;
          }
          b2 = (M2 = this.drawRangeBarPaths(u({ indexes: { i: r2, j: A2, realIndex: g2 }, barHeight: x2, barYPosition: I2, zeroW: h2, yDivision: o2, y1: S2, y2: L2 }, T2))).barWidth;
        } else {
          i2.globals.isXNumeric &amp;&amp; (c2 = (i2.globals.seriesX[r2][A2] - i2.globals.minX) / this.xRatio - b2 / 2), P2 = c2 + b2 * this.visibleI;
          var E2 = (n2 - b2 * z2) / 2;
          if (i2.config.series[r2].data[A2].x) {
            var Y2 = this.detectOverlappingBars({ i: r2, j: A2, barXPosition: P2, srtx: E2, barWidth: b2, xDivision: n2, initPositions: y2 });
            b2 = Y2.barWidth, P2 = Y2.barXPosition;
          }
          x2 = (M2 = this.drawRangeColumnPaths(u({ indexes: { i: r2, j: A2, realIndex: g2, translationsIndex: m2 }, barWidth: b2, barXPosition: P2, zeroH: l2, xDivision: n2 }, T2))).barHeight;
        }
        var H2 = this.barHelpers.drawGoalLine({ barXPosition: M2.barXPosition, barYPosition: I2, goalX: M2.goalX, goalY: M2.goalY, barHeight: x2, barWidth: b2 });
        H2 &amp;&amp; k2.add(H2), d2 = M2.y, c2 = M2.x;
        var O2 = this.barHelpers.getPathFillColor(t3, r2, A2, g2);
        this.renderSeries({ realIndex: g2, pathFill: O2.color, lineFill: O2.useRangeColor ? O2.color : i2.globals.stroke.colors[g2], j: A2, i: r2, x: c2, y: d2, y1: S2, y2: L2, pathFrom: M2.pathFrom, pathTo: M2.pathTo, strokeWidth: C2, elSeries: f2, series: t3, barHeight: x2, barWidth: b2, barXPosition: P2, barYPosition: I2, columnGroupIndex: p2, elDataLabelsWrap: w2, elGoalsMarkers: k2, visibleSeries: this.visibleI, type: &quot;rangebar&quot; });
      }
      s2.add(f2);
    }
    return s2;
  } }, { key: &quot;detectOverlappingBars&quot;, value: function(t3) {
    var e3 = t3.i, i2 = t3.j, a3 = t3.barYPosition, s2 = t3.barXPosition, r2 = t3.srty, n2 = t3.srtx, o2 = t3.barHeight, l2 = t3.barWidth, h2 = t3.yDivision, c2 = t3.xDivision, d2 = t3.initPositions, u2 = this.w, g2 = [], p2 = u2.config.series[e3].data[i2].rangeName, f2 = u2.config.series[e3].data[i2].x, x2 = Array.isArray(f2) ? f2.join(&quot; &quot;) : f2, b2 = u2.globals.labels.map(function(t4) {
      return Array.isArray(t4) ? t4.join(&quot; &quot;) : t4;
    }).indexOf(x2), m2 = u2.globals.seriesRange[e3].findIndex(function(t4) {
      return t4.x === x2 &amp;&amp; t4.overlaps.length &gt; 0;
    });
    return this.isHorizontal ? (a3 = u2.config.plotOptions.bar.rangeBarGroupRows ? r2 + h2 * b2 : r2 + o2 * this.visibleI + h2 * b2, m2 &gt; -1 &amp;&amp; !u2.config.plotOptions.bar.rangeBarOverlap &amp;&amp; (g2 = u2.globals.seriesRange[e3][m2].overlaps).indexOf(p2) &gt; -1 &amp;&amp; (a3 = (o2 = d2.barHeight / g2.length) * this.visibleI + h2 * (100 - parseInt(this.barOptions.barHeight, 10)) / 100 / 2 + o2 * (this.visibleI + g2.indexOf(p2)) + h2 * b2)) : (b2 &gt; -1 &amp;&amp; !u2.globals.timescaleLabels.length &amp;&amp; (s2 = u2.config.plotOptions.bar.rangeBarGroupRows ? n2 + c2 * b2 : n2 + l2 * this.visibleI + c2 * b2), m2 &gt; -1 &amp;&amp; !u2.config.plotOptions.bar.rangeBarOverlap &amp;&amp; (g2 = u2.globals.seriesRange[e3][m2].overlaps).indexOf(p2) &gt; -1 &amp;&amp; (s2 = (l2 = d2.barWidth / g2.length) * this.visibleI + c2 * (100 - parseInt(this.barOptions.barWidth, 10)) / 100 / 2 + l2 * (this.visibleI + g2.indexOf(p2)) + c2 * b2)), { barYPosition: a3, barXPosition: s2, barHeight: o2, barWidth: l2 };
  } }, { key: &quot;drawRangeColumnPaths&quot;, value: function(t3) {
    var e3 = t3.indexes, i2 = t3.x, a3 = t3.xDivision, s2 = t3.barWidth, r2 = t3.barXPosition, n2 = t3.zeroH, o2 = this.w, l2 = e3.i, h2 = e3.j, c2 = e3.realIndex, d2 = e3.translationsIndex, u2 = this.yRatio[d2], g2 = this.getRangeValue(c2, h2), p2 = Math.min(g2.start, g2.end), f2 = Math.max(g2.start, g2.end);
    void 0 === this.series[l2][h2] || null === this.series[l2][h2] ? p2 = n2 : (p2 = n2 - p2 / u2, f2 = n2 - f2 / u2);
    var x2 = Math.abs(f2 - p2), b2 = this.barHelpers.getColumnPaths({ barXPosition: r2, barWidth: s2, y1: p2, y2: f2, strokeWidth: this.strokeWidth, series: this.seriesRangeEnd, realIndex: c2, i: c2, j: h2, w: o2 });
    if (o2.globals.isXNumeric) {
      var m2 = this.getBarXForNumericXAxis({ x: i2, j: h2, realIndex: c2, barWidth: s2 });
      i2 = m2.x, r2 = m2.barXPosition;
    } else i2 += a3;
    return { pathTo: b2.pathTo, pathFrom: b2.pathFrom, barHeight: x2, x: i2, y: g2.start &lt; 0 &amp;&amp; g2.end &lt; 0 ? p2 : f2, goalY: this.barHelpers.getGoalValues(&quot;y&quot;, null, n2, l2, h2, d2), barXPosition: r2 };
  } }, { key: &quot;preventBarOverflow&quot;, value: function(t3) {
    var e3 = this.w;
    return t3 &lt; 0 &amp;&amp; (t3 = 0), t3 &gt; e3.globals.gridWidth &amp;&amp; (t3 = e3.globals.gridWidth), t3;
  } }, { key: &quot;drawRangeBarPaths&quot;, value: function(t3) {
    var e3 = t3.indexes, i2 = t3.y, a3 = t3.y1, s2 = t3.y2, r2 = t3.yDivision, n2 = t3.barHeight, o2 = t3.barYPosition, l2 = t3.zeroW, h2 = this.w, c2 = e3.realIndex, d2 = e3.j, u2 = this.preventBarOverflow(l2 + a3 / this.invertedYRatio), g2 = this.preventBarOverflow(l2 + s2 / this.invertedYRatio), p2 = this.getRangeValue(c2, d2), f2 = Math.abs(g2 - u2), x2 = this.barHelpers.getBarpaths({ barYPosition: o2, barHeight: n2, x1: u2, x2: g2, strokeWidth: this.strokeWidth, series: this.seriesRangeEnd, i: c2, realIndex: c2, j: d2, w: h2 });
    return h2.globals.isXNumeric || (i2 += r2), { pathTo: x2.pathTo, pathFrom: x2.pathFrom, barWidth: f2, x: p2.start &lt; 0 &amp;&amp; p2.end &lt; 0 ? u2 : g2, goalX: this.barHelpers.getGoalValues(&quot;x&quot;, l2, null, c2, d2), y: i2 };
  } }, { key: &quot;getRangeValue&quot;, value: function(t3, e3) {
    var i2 = this.w;
    return { start: i2.globals.seriesRangeStart[t3][e3], end: i2.globals.seriesRangeEnd[t3][e3] };
  } }]), a2;
}();
var Fa = function() {
  function t2(e2) {
    i(this, t2), this.w = e2.w, this.lineCtx = e2;
  }
  return s(t2, [{ key: &quot;sameValueSeriesFix&quot;, value: function(t3, e2) {
    var i2 = this.w;
    if ((&quot;gradient&quot; === i2.config.fill.type || &quot;gradient&quot; === i2.config.fill.type[t3]) &amp;&amp; new Pi(this.lineCtx.ctx, i2).seriesHaveSameValues(t3)) {
      var a2 = e2[t3].slice();
      a2[a2.length - 1] = a2[a2.length - 1] + 1e-6, e2[t3] = a2;
    }
    return e2;
  } }, { key: &quot;calculatePoints&quot;, value: function(t3) {
    var e2 = t3.series, i2 = t3.realIndex, a2 = t3.x, s2 = t3.y, r2 = t3.i, n2 = t3.j, o2 = t3.prevY, l2 = this.w, h2 = [], c2 = [], d2 = this.lineCtx.categoryAxisCorrection + l2.config.markers.offsetX;
    return l2.globals.isXNumeric &amp;&amp; (d2 = (l2.globals.seriesX[i2][0] - l2.globals.minX) / this.lineCtx.xRatio + l2.config.markers.offsetX), 0 === n2 &amp;&amp; (h2.push(d2), c2.push(v.isNumber(e2[r2][0]) ? o2 + l2.config.markers.offsetY : null)), h2.push(a2 + l2.config.markers.offsetX), c2.push(v.isNumber(e2[r2][n2 + 1]) ? s2 + l2.config.markers.offsetY : null), { x: h2, y: c2 };
  } }, { key: &quot;checkPreviousPaths&quot;, value: function(t3) {
    for (var e2 = t3.pathFromLine, i2 = t3.pathFromArea, a2 = t3.realIndex, s2 = this.w, r2 = 0; r2 &lt; s2.globals.previousPaths.length; r2++) {
      var n2 = s2.globals.previousPaths[r2];
      (&quot;line&quot; === n2.type || &quot;area&quot; === n2.type) &amp;&amp; n2.paths.length &gt; 0 &amp;&amp; parseInt(n2.realIndex, 10) === parseInt(a2, 10) &amp;&amp; (&quot;line&quot; === n2.type ? (this.lineCtx.appendPathFrom = false, e2 = s2.globals.previousPaths[r2].paths[0].d) : &quot;area&quot; === n2.type &amp;&amp; (this.lineCtx.appendPathFrom = false, i2 = s2.globals.previousPaths[r2].paths[0].d, s2.config.stroke.show &amp;&amp; s2.globals.previousPaths[r2].paths[1] &amp;&amp; (e2 = s2.globals.previousPaths[r2].paths[1].d)));
    }
    return { pathFromLine: e2, pathFromArea: i2 };
  } }, { key: &quot;determineFirstPrevY&quot;, value: function(t3) {
    var e2, i2, a2, s2 = t3.i, r2 = t3.realIndex, n2 = t3.series, o2 = t3.prevY, l2 = t3.lineYPosition, h2 = t3.translationsIndex, c2 = this.w, d2 = c2.config.chart.stacked &amp;&amp; !c2.globals.comboCharts || c2.config.chart.stacked &amp;&amp; c2.globals.comboCharts &amp;&amp; (!this.w.config.chart.stackOnlyBar || &quot;bar&quot; === (null === (e2 = this.w.config.series[r2]) || void 0 === e2 ? void 0 : e2.type) || &quot;column&quot; === (null === (i2 = this.w.config.series[r2]) || void 0 === i2 ? void 0 : i2.type));
    if (void 0 !== (null === (a2 = n2[s2]) || void 0 === a2 ? void 0 : a2[0])) o2 = (l2 = d2 &amp;&amp; s2 &gt; 0 ? this.lineCtx.prevSeriesY[s2 - 1][0] : this.lineCtx.zeroY) - n2[s2][0] / this.lineCtx.yRatio[h2] + 2 * (this.lineCtx.isReversed ? n2[s2][0] / this.lineCtx.yRatio[h2] : 0);
    else if (d2 &amp;&amp; s2 &gt; 0 &amp;&amp; void 0 === n2[s2][0]) {
      for (var u2 = s2 - 1; u2 &gt;= 0; u2--) if (null !== n2[u2][0] &amp;&amp; void 0 !== n2[u2][0]) {
        o2 = l2 = this.lineCtx.prevSeriesY[u2][0];
        break;
      }
    }
    return { prevY: o2, lineYPosition: l2 };
  } }]), t2;
}();
var Da = function(t2) {
  for (var e2, i2, a2, s2, r2 = function(t3) {
    for (var e3 = [], i3 = t3[0], a3 = t3[1], s3 = e3[0] = Wa(i3, a3), r3 = 1, n3 = t3.length - 1; r3 &lt; n3; r3++) i3 = a3, a3 = t3[r3 + 1], e3[r3] = 0.5 * (s3 + (s3 = Wa(i3, a3)));
    return e3[r3] = s3, e3;
  }(t2), n2 = t2.length - 1, o2 = [], l2 = 0; l2 &lt; n2; l2++) a2 = Wa(t2[l2], t2[l2 + 1]), Math.abs(a2) &lt; 1e-6 ? r2[l2] = r2[l2 + 1] = 0 : (s2 = (e2 = r2[l2] / a2) * e2 + (i2 = r2[l2 + 1] / a2) * i2) &gt; 9 &amp;&amp; (s2 = 3 * a2 / Math.sqrt(s2), r2[l2] = s2 * e2, r2[l2 + 1] = s2 * i2);
  for (var h2 = 0; h2 &lt;= n2; h2++) s2 = (t2[Math.min(n2, h2 + 1)][0] - t2[Math.max(0, h2 - 1)][0]) / (6 * (1 + r2[h2] * r2[h2])), o2.push([s2 || 0, r2[h2] * s2 || 0]);
  return o2;
};
var _a = function(t2) {
  var e2 = Da(t2), i2 = t2[1], a2 = t2[0], s2 = [], r2 = e2[1], n2 = e2[0];
  s2.push(a2, [a2[0] + n2[0], a2[1] + n2[1], i2[0] - r2[0], i2[1] - r2[1], i2[0], i2[1]]);
  for (var o2 = 2, l2 = e2.length; o2 &lt; l2; o2++) {
    var h2 = t2[o2], c2 = e2[o2];
    s2.push([h2[0] - c2[0], h2[1] - c2[1], h2[0], h2[1]]);
  }
  return s2;
};
var Na = function(t2, e2, i2) {
  var a2 = t2.slice(e2, i2);
  if (e2) {
    if (i2 - e2 &gt; 1 &amp;&amp; a2[1].length &lt; 6) {
      var s2 = a2[0].length;
      a2[1] = [2 * a2[0][s2 - 2] - a2[0][s2 - 4], 2 * a2[0][s2 - 1] - a2[0][s2 - 3]].concat(a2[1]);
    }
    a2[0] = a2[0].slice(-2);
  }
  return a2;
};
function Wa(t2, e2) {
  return (e2[1] - t2[1]) / (e2[0] - t2[0]);
}
var Ba = function() {
  function t2(e2, a2, s2) {
    i(this, t2), this.ctx = e2, this.w = e2.w, this.xyRatios = a2, this.pointsChart = !(&quot;bubble&quot; !== this.w.config.chart.type &amp;&amp; &quot;scatter&quot; !== this.w.config.chart.type) || s2, this.scatter = new Ui(this.ctx), this.noNegatives = this.w.globals.minX === Number.MAX_VALUE, this.lineHelpers = new Fa(this), this.markers = new Vi(this.ctx), this.prevSeriesY = [], this.categoryAxisCorrection = 0, this.yaxisIndex = 0;
  }
  return s(t2, [{ key: &quot;draw&quot;, value: function(t3, e2, i2, a2) {
    var s2, r2 = this.w, n2 = new Mi(this.ctx), o2 = r2.globals.comboCharts ? e2 : r2.config.chart.type, l2 = n2.group({ class: &quot;apexcharts-&quot;.concat(o2, &quot;-series apexcharts-plot-series&quot;) }), h2 = new Pi(this.ctx, r2);
    this.yRatio = this.xyRatios.yRatio, this.zRatio = this.xyRatios.zRatio, this.xRatio = this.xyRatios.xRatio, this.baseLineY = this.xyRatios.baseLineY, t3 = h2.getLogSeries(t3), this.yRatio = h2.getLogYRatios(this.yRatio), this.prevSeriesY = [];
    for (var c2 = [], d2 = 0; d2 &lt; t3.length; d2++) {
      t3 = this.lineHelpers.sameValueSeriesFix(d2, t3);
      var g2 = r2.globals.comboCharts ? i2[d2] : d2, p2 = this.yRatio.length &gt; 1 ? g2 : 0;
      this._initSerieVariables(t3, d2, g2);
      var f2 = [], x2 = [], b2 = [], m2 = r2.globals.padHorizontal + this.categoryAxisCorrection;
      this.ctx.series.addCollapsedClassToSeries(this.elSeries, g2), r2.globals.isXNumeric &amp;&amp; r2.globals.seriesX.length &gt; 0 &amp;&amp; (m2 = (r2.globals.seriesX[g2][0] - r2.globals.minX) / this.xRatio), b2.push(m2);
      var v2, y2 = m2, w2 = void 0, k2 = y2, A2 = this.zeroY, C2 = this.zeroY;
      A2 = this.lineHelpers.determineFirstPrevY({ i: d2, realIndex: g2, series: t3, prevY: A2, lineYPosition: 0, translationsIndex: p2 }).prevY, &quot;monotoneCubic&quot; === r2.config.stroke.curve &amp;&amp; null === t3[d2][0] ? f2.push(null) : f2.push(A2), v2 = A2;
      &quot;rangeArea&quot; === o2 &amp;&amp; (w2 = C2 = this.lineHelpers.determineFirstPrevY({ i: d2, realIndex: g2, series: a2, prevY: C2, lineYPosition: 0, translationsIndex: p2 }).prevY, x2.push(null !== f2[0] ? C2 : null));
      var S2 = this._calculatePathsFrom({ type: o2, series: t3, i: d2, realIndex: g2, translationsIndex: p2, prevX: k2, prevY: A2, prevY2: C2 }), L2 = [f2[0]], M2 = [x2[0]], P2 = { type: o2, series: t3, realIndex: g2, translationsIndex: p2, i: d2, x: m2, y: 1, pX: y2, pY: v2, pathsFrom: S2, linePaths: [], areaPaths: [], seriesIndex: i2, lineYPosition: 0, xArrj: b2, yArrj: f2, y2Arrj: x2, seriesRangeEnd: a2 }, I2 = this._iterateOverDataPoints(u(u({}, P2), {}, { iterations: &quot;rangeArea&quot; === o2 ? t3[d2].length - 1 : void 0, isRangeStart: true }));
      if (&quot;rangeArea&quot; === o2) {
        for (var T2 = this._calculatePathsFrom({ series: a2, i: d2, realIndex: g2, prevX: k2, prevY: C2 }), z2 = this._iterateOverDataPoints(u(u({}, P2), {}, { series: a2, xArrj: [m2], yArrj: L2, y2Arrj: M2, pY: w2, areaPaths: I2.areaPaths, pathsFrom: T2, iterations: a2[d2].length - 1, isRangeStart: false })), X2 = I2.linePaths.length / 2, R2 = 0; R2 &lt; X2; R2++) I2.linePaths[R2] = z2.linePaths[R2 + X2] + I2.linePaths[R2];
        I2.linePaths.splice(X2), I2.pathFromLine = z2.pathFromLine + I2.pathFromLine;
      } else I2.pathFromArea += &quot;z&quot;;
      this._handlePaths({ type: o2, realIndex: g2, i: d2, paths: I2 }), this.elSeries.add(this.elPointsMain), this.elSeries.add(this.elDataLabelsWrap), c2.push(this.elSeries);
    }
    if (void 0 !== (null === (s2 = r2.config.series[0]) || void 0 === s2 ? void 0 : s2.zIndex) &amp;&amp; c2.sort(function(t4, e3) {
      return Number(t4.node.getAttribute(&quot;zIndex&quot;)) - Number(e3.node.getAttribute(&quot;zIndex&quot;));
    }), r2.config.chart.stacked) for (var E2 = c2.length - 1; E2 &gt;= 0; E2--) l2.add(c2[E2]);
    else for (var Y2 = 0; Y2 &lt; c2.length; Y2++) l2.add(c2[Y2]);
    return l2;
  } }, { key: &quot;_initSerieVariables&quot;, value: function(t3, e2, i2) {
    var a2 = this.w, s2 = new Mi(this.ctx);
    this.xDivision = a2.globals.gridWidth / (a2.globals.dataPoints - (&quot;on&quot; === a2.config.xaxis.tickPlacement ? 1 : 0)), this.strokeWidth = Array.isArray(a2.config.stroke.width) ? a2.config.stroke.width[i2] : a2.config.stroke.width;
    var r2 = 0;
    if (this.yRatio.length &gt; 1 &amp;&amp; (this.yaxisIndex = a2.globals.seriesYAxisReverseMap[i2], r2 = i2), this.isReversed = a2.config.yaxis[this.yaxisIndex] &amp;&amp; a2.config.yaxis[this.yaxisIndex].reversed, this.zeroY = a2.globals.gridHeight - this.baseLineY[r2] - (this.isReversed ? a2.globals.gridHeight : 0) + (this.isReversed ? 2 * this.baseLineY[r2] : 0), this.areaBottomY = this.zeroY, (this.zeroY &gt; a2.globals.gridHeight || &quot;end&quot; === a2.config.plotOptions.area.fillTo) &amp;&amp; (this.areaBottomY = a2.globals.gridHeight), this.categoryAxisCorrection = this.xDivision / 2, this.elSeries = s2.group({ class: &quot;apexcharts-series&quot;, zIndex: void 0 !== a2.config.series[i2].zIndex ? a2.config.series[i2].zIndex : i2, seriesName: v.escapeString(a2.globals.seriesNames[i2]) }), this.elPointsMain = s2.group({ class: &quot;apexcharts-series-markers-wrap&quot;, &quot;data:realIndex&quot;: i2 }), a2.globals.hasNullValues) {
      var n2 = this.markers.plotChartMarkers({ pointsPos: { x: [0], y: [a2.globals.gridHeight + a2.globals.markers.largestSize] }, seriesIndex: e2, j: 0, pSize: 0.1, alwaysDrawMarker: true, isVirtualPoint: true });
      null !== n2 &amp;&amp; this.elPointsMain.add(n2);
    }
    this.elDataLabelsWrap = s2.group({ class: &quot;apexcharts-datalabels&quot;, &quot;data:realIndex&quot;: i2 });
    var o2 = t3[e2].length === a2.globals.dataPoints;
    this.elSeries.attr({ &quot;data:longestSeries&quot;: o2, rel: e2 + 1, &quot;data:realIndex&quot;: i2 }), this.appendPathFrom = true;
  } }, { key: &quot;_calculatePathsFrom&quot;, value: function(t3) {
    var e2, i2, a2, s2, r2 = t3.type, n2 = t3.series, o2 = t3.i, l2 = t3.realIndex, h2 = t3.translationsIndex, c2 = t3.prevX, d2 = t3.prevY, u2 = t3.prevY2, g2 = this.w, p2 = new Mi(this.ctx);
    if (null === n2[o2][0]) {
      for (var f2 = 0; f2 &lt; n2[o2].length; f2++) if (null !== n2[o2][f2]) {
        c2 = this.xDivision * f2, d2 = this.zeroY - n2[o2][f2] / this.yRatio[h2], e2 = p2.move(c2, d2), i2 = p2.move(c2, this.areaBottomY);
        break;
      }
    } else e2 = p2.move(c2, d2), &quot;rangeArea&quot; === r2 &amp;&amp; (e2 = p2.move(c2, u2) + p2.line(c2, d2)), i2 = p2.move(c2, this.areaBottomY) + p2.line(c2, d2);
    if (a2 = p2.move(0, this.areaBottomY) + p2.line(0, this.areaBottomY), s2 = p2.move(0, this.areaBottomY) + p2.line(0, this.areaBottomY), g2.globals.previousPaths.length &gt; 0) {
      var x2 = this.lineHelpers.checkPreviousPaths({ pathFromLine: a2, pathFromArea: s2, realIndex: l2 });
      a2 = x2.pathFromLine, s2 = x2.pathFromArea;
    }
    return { prevX: c2, prevY: d2, linePath: e2, areaPath: i2, pathFromLine: a2, pathFromArea: s2 };
  } }, { key: &quot;_handlePaths&quot;, value: function(t3) {
    var e2 = t3.type, i2 = t3.realIndex, a2 = t3.i, s2 = t3.paths, r2 = this.w, n2 = new Mi(this.ctx), o2 = new ji(this.ctx);
    this.prevSeriesY.push(s2.yArrj), r2.globals.seriesXvalues[i2] = s2.xArrj, r2.globals.seriesYvalues[i2] = s2.yArrj;
    var l2 = r2.config.forecastDataPoints;
    if (l2.count &gt; 0 &amp;&amp; &quot;rangeArea&quot; !== e2) {
      var h2 = r2.globals.seriesXvalues[i2][r2.globals.seriesXvalues[i2].length - l2.count - 1], c2 = n2.drawRect(h2, 0, r2.globals.gridWidth, r2.globals.gridHeight, 0);
      r2.globals.dom.elForecastMask.appendChild(c2.node);
      var d2 = n2.drawRect(0, 0, h2, r2.globals.gridHeight, 0);
      r2.globals.dom.elNonForecastMask.appendChild(d2.node);
    }
    this.pointsChart || r2.globals.delayedElements.push({ el: this.elPointsMain.node, index: i2 });
    var g2 = { i: a2, realIndex: i2, animationDelay: a2, initialSpeed: r2.config.chart.animations.speed, dataChangeSpeed: r2.config.chart.animations.dynamicAnimation.speed, className: &quot;apexcharts-&quot;.concat(e2) };
    if (&quot;area&quot; === e2) for (var p2 = o2.fillPath({ seriesNumber: i2 }), f2 = 0; f2 &lt; s2.areaPaths.length; f2++) {
      var x2 = n2.renderPaths(u(u({}, g2), {}, { pathFrom: s2.pathFromArea, pathTo: s2.areaPaths[f2], stroke: &quot;none&quot;, strokeWidth: 0, strokeLineCap: null, fill: p2 }));
      this.elSeries.add(x2);
    }
    if (r2.config.stroke.show &amp;&amp; !this.pointsChart) {
      var b2 = null;
      if (&quot;line&quot; === e2) b2 = o2.fillPath({ seriesNumber: i2, i: a2 });
      else if (&quot;solid&quot; === r2.config.stroke.fill.type) b2 = r2.globals.stroke.colors[i2];
      else {
        var m2 = r2.config.fill;
        r2.config.fill = r2.config.stroke.fill, b2 = o2.fillPath({ seriesNumber: i2, i: a2 }), r2.config.fill = m2;
      }
      for (var v2 = 0; v2 &lt; s2.linePaths.length; v2++) {
        var y2 = b2;
        &quot;rangeArea&quot; === e2 &amp;&amp; (y2 = o2.fillPath({ seriesNumber: i2 }));
        var w2 = u(u({}, g2), {}, { pathFrom: s2.pathFromLine, pathTo: s2.linePaths[v2], stroke: b2, strokeWidth: this.strokeWidth, strokeLineCap: r2.config.stroke.lineCap, fill: &quot;rangeArea&quot; === e2 ? y2 : &quot;none&quot; }), k2 = n2.renderPaths(w2);
        if (this.elSeries.add(k2), k2.attr(&quot;fill-rule&quot;, &quot;evenodd&quot;), l2.count &gt; 0 &amp;&amp; &quot;rangeArea&quot; !== e2) {
          var A2 = n2.renderPaths(w2);
          A2.node.setAttribute(&quot;stroke-dasharray&quot;, l2.dashArray), l2.strokeWidth &amp;&amp; A2.node.setAttribute(&quot;stroke-width&quot;, l2.strokeWidth), this.elSeries.add(A2), A2.attr(&quot;clip-path&quot;, &quot;url(#forecastMask&quot;.concat(r2.globals.cuid, &quot;)&quot;)), k2.attr(&quot;clip-path&quot;, &quot;url(#nonForecastMask&quot;.concat(r2.globals.cuid, &quot;)&quot;));
        }
      }
    }
  } }, { key: &quot;_iterateOverDataPoints&quot;, value: function(t3) {
    var e2, i2, a2 = this, s2 = t3.type, r2 = t3.series, n2 = t3.iterations, o2 = t3.realIndex, l2 = t3.translationsIndex, h2 = t3.i, c2 = t3.x, d2 = t3.y, u2 = t3.pX, g2 = t3.pY, p2 = t3.pathsFrom, f2 = t3.linePaths, x2 = t3.areaPaths, b2 = t3.seriesIndex, m2 = t3.lineYPosition, y2 = t3.xArrj, w2 = t3.yArrj, k2 = t3.y2Arrj, A2 = t3.isRangeStart, C2 = t3.seriesRangeEnd, S2 = this.w, L2 = new Mi(this.ctx), M2 = this.yRatio, P2 = p2.prevY, I2 = p2.linePath, T2 = p2.areaPath, z2 = p2.pathFromLine, X2 = p2.pathFromArea, R2 = v.isNumber(S2.globals.minYArr[o2]) ? S2.globals.minYArr[o2] : S2.globals.minY;
    n2 || (n2 = S2.globals.dataPoints &gt; 1 ? S2.globals.dataPoints - 1 : S2.globals.dataPoints);
    var E2 = function(t4, e3) {
      return e3 - t4 / M2[l2] + 2 * (a2.isReversed ? t4 / M2[l2] : 0);
    }, Y2 = d2, H2 = S2.config.chart.stacked &amp;&amp; !S2.globals.comboCharts || S2.config.chart.stacked &amp;&amp; S2.globals.comboCharts &amp;&amp; (!this.w.config.chart.stackOnlyBar || &quot;bar&quot; === (null === (e2 = this.w.config.series[o2]) || void 0 === e2 ? void 0 : e2.type) || &quot;column&quot; === (null === (i2 = this.w.config.series[o2]) || void 0 === i2 ? void 0 : i2.type)), O2 = S2.config.stroke.curve;
    Array.isArray(O2) &amp;&amp; (O2 = Array.isArray(b2) ? O2[b2[h2]] : O2[h2]);
    for (var F2, D2 = 0, _2 = 0; _2 &lt; n2 &amp;&amp; 0 !== r2[h2].length; _2++) {
      var N2 = void 0 === r2[h2][_2 + 1] || null === r2[h2][_2 + 1];
      if (S2.globals.isXNumeric) {
        var W2 = S2.globals.seriesX[o2][_2 + 1];
        void 0 === S2.globals.seriesX[o2][_2 + 1] &amp;&amp; (W2 = S2.globals.seriesX[o2][n2 - 1]), c2 = (W2 - S2.globals.minX) / this.xRatio;
      } else c2 += this.xDivision;
      if (H2) if (h2 &gt; 0 &amp;&amp; S2.globals.collapsedSeries.length &lt; S2.config.series.length - 1) {
        m2 = this.prevSeriesY[function(t4) {
          for (var e3 = t4; e3 &gt; 0; e3--) {
            if (!(S2.globals.collapsedSeriesIndices.indexOf((null == b2 ? void 0 : b2[e3]) || e3) &gt; -1)) return e3;
            e3--;
          }
          return 0;
        }(h2 - 1)][_2 + 1];
      } else m2 = this.zeroY;
      else m2 = this.zeroY;
      N2 ? d2 = E2(R2, m2) : (d2 = E2(r2[h2][_2 + 1], m2), &quot;rangeArea&quot; === s2 &amp;&amp; (Y2 = E2(C2[h2][_2 + 1], m2))), y2.push(null === r2[h2][_2 + 1] ? null : c2), !N2 || &quot;smooth&quot; !== S2.config.stroke.curve &amp;&amp; &quot;monotoneCubic&quot; !== S2.config.stroke.curve ? (w2.push(d2), k2.push(Y2)) : (w2.push(null), k2.push(null));
      var B2 = this.lineHelpers.calculatePoints({ series: r2, x: c2, y: d2, realIndex: o2, i: h2, j: _2, prevY: P2 }), G2 = this._createPaths({ type: s2, series: r2, i: h2, realIndex: o2, j: _2, x: c2, y: d2, y2: Y2, xArrj: y2, yArrj: w2, y2Arrj: k2, pX: u2, pY: g2, pathState: D2, segmentStartX: F2, linePath: I2, areaPath: T2, linePaths: f2, areaPaths: x2, curve: O2, isRangeStart: A2 });
      x2 = G2.areaPaths, f2 = G2.linePaths, u2 = G2.pX, g2 = G2.pY, D2 = G2.pathState, F2 = G2.segmentStartX, T2 = G2.areaPath, I2 = G2.linePath, !this.appendPathFrom || S2.globals.hasNullValues || &quot;monotoneCubic&quot; === O2 &amp;&amp; &quot;rangeArea&quot; === s2 || (z2 += L2.line(c2, this.areaBottomY), X2 += L2.line(c2, this.areaBottomY)), this.handleNullDataPoints(r2, B2, h2, _2, o2), this._handleMarkersAndLabels({ type: s2, pointsPos: B2, i: h2, j: _2, realIndex: o2, isRangeStart: A2 });
    }
    return { yArrj: w2, xArrj: y2, pathFromArea: X2, areaPaths: x2, pathFromLine: z2, linePaths: f2, linePath: I2, areaPath: T2 };
  } }, { key: &quot;_handleMarkersAndLabels&quot;, value: function(t3) {
    var e2 = t3.type, i2 = t3.pointsPos, a2 = t3.isRangeStart, s2 = t3.i, r2 = t3.j, n2 = t3.realIndex, o2 = this.w, l2 = new qi(this.ctx);
    if (this.pointsChart) this.scatter.draw(this.elSeries, r2, { realIndex: n2, pointsPos: i2, zRatio: this.zRatio, elParent: this.elPointsMain });
    else {
      o2.globals.series[s2].length &gt; 1 &amp;&amp; this.elPointsMain.node.classList.add(&quot;apexcharts-element-hidden&quot;);
      var h2 = this.markers.plotChartMarkers({ pointsPos: i2, seriesIndex: n2, j: r2 + 1 });
      null !== h2 &amp;&amp; this.elPointsMain.add(h2);
    }
    var c2 = l2.drawDataLabel({ type: e2, isRangeStart: a2, pos: i2, i: n2, j: r2 + 1 });
    null !== c2 &amp;&amp; this.elDataLabelsWrap.add(c2);
  } }, { key: &quot;_createPaths&quot;, value: function(t3) {
    var e2 = t3.type, i2 = t3.series, a2 = t3.i;
    t3.realIndex;
    var s2, r2 = t3.j, n2 = t3.x, o2 = t3.y, l2 = t3.xArrj, h2 = t3.yArrj, c2 = t3.y2, d2 = t3.y2Arrj, u2 = t3.pX, g2 = t3.pY, p2 = t3.pathState, f2 = t3.segmentStartX, x2 = t3.linePath, b2 = t3.areaPath, m2 = t3.linePaths, v2 = t3.areaPaths, y2 = t3.curve, w2 = t3.isRangeStart, k2 = new Mi(this.ctx), A2 = this.areaBottomY, C2 = &quot;rangeArea&quot; === e2, S2 = &quot;rangeArea&quot; === e2 &amp;&amp; w2;
    switch (y2) {
      case &quot;monotoneCubic&quot;:
        var L2 = w2 ? h2 : d2;
        switch (p2) {
          case 0:
            if (null === L2[r2 + 1]) break;
            p2 = 1;
          case 1:
            if (!(C2 ? l2.length === i2[a2].length : r2 === i2[a2].length - 2)) break;
          case 2:
            var M2 = w2 ? l2 : l2.slice().reverse(), P2 = w2 ? L2 : L2.slice().reverse(), I2 = (s2 = P2, M2.map(function(t4, e3) {
              return [t4, s2[e3]];
            }).filter(function(t4) {
              return null !== t4[1];
            })), T2 = I2.length &gt; 1 ? _a(I2) : I2, z2 = [];
            C2 &amp;&amp; (S2 ? v2 = I2 : z2 = v2.reverse());
            var X2 = 0, R2 = 0;
            if (function(t4, e3) {
              for (var i3 = function(t5) {
                var e4 = [], i4 = 0;
                return t5.forEach(function(t6) {
                  null !== t6 ? i4++ : i4 &gt; 0 &amp;&amp; (e4.push(i4), i4 = 0);
                }), i4 &gt; 0 &amp;&amp; e4.push(i4), e4;
              }(t4), a3 = [], s3 = 0, r3 = 0; s3 &lt; i3.length; r3 += i3[s3++]) a3[s3] = Na(e3, r3, r3 + i3[s3]);
              return a3;
            }(P2, T2).forEach(function(t4) {
              X2++;
              var e3 = function(t5) {
                for (var e4 = &quot;&quot;, i4 = 0; i4 &lt; t5.length; i4++) {
                  var a4 = t5[i4], s3 = a4.length;
                  s3 &gt; 4 ? (e4 += &quot;C&quot;.concat(a4[0], &quot;, &quot;).concat(a4[1]), e4 += &quot;, &quot;.concat(a4[2], &quot;, &quot;).concat(a4[3]), e4 += &quot;, &quot;.concat(a4[4], &quot;, &quot;).concat(a4[5])) : s3 &gt; 2 &amp;&amp; (e4 += &quot;S&quot;.concat(a4[0], &quot;, &quot;).concat(a4[1]), e4 += &quot;, &quot;.concat(a4[2], &quot;, &quot;).concat(a4[3]));
                }
                return e4;
              }(t4), i3 = R2, a3 = (R2 += t4.length) - 1;
              S2 ? x2 = k2.move(I2[i3][0], I2[i3][1]) + e3 : C2 ? x2 = k2.move(z2[i3][0], z2[i3][1]) + k2.line(I2[i3][0], I2[i3][1]) + e3 + k2.line(z2[a3][0], z2[a3][1]) : (x2 = k2.move(I2[i3][0], I2[i3][1]) + e3, b2 = x2 + k2.line(I2[a3][0], A2) + k2.line(I2[i3][0], A2) + &quot;z&quot;, v2.push(b2)), m2.push(x2);
            }), C2 &amp;&amp; X2 &gt; 1 &amp;&amp; !S2) {
              var E2 = m2.slice(X2).reverse();
              m2.splice(X2), E2.forEach(function(t4) {
                return m2.push(t4);
              });
            }
            p2 = 0;
        }
        break;
      case &quot;smooth&quot;:
        var Y2 = 0.35 * (n2 - u2);
        if (null === i2[a2][r2]) p2 = 0;
        else switch (p2) {
          case 0:
            if (f2 = u2, x2 = S2 ? k2.move(u2, d2[r2]) + k2.line(u2, g2) : k2.move(u2, g2), b2 = k2.move(u2, g2), null === i2[a2][r2 + 1] || void 0 === i2[a2][r2 + 1]) {
              m2.push(x2), v2.push(b2);
              break;
            }
            if (p2 = 1, r2 &lt; i2[a2].length - 2) {
              var H2 = k2.curve(u2 + Y2, g2, n2 - Y2, o2, n2, o2);
              x2 += H2, b2 += H2;
              break;
            }
          case 1:
            if (null === i2[a2][r2 + 1]) x2 += S2 ? k2.line(u2, c2) : k2.move(u2, g2), b2 += k2.line(u2, A2) + k2.line(f2, A2) + &quot;z&quot;, m2.push(x2), v2.push(b2), p2 = -1;
            else {
              var O2 = k2.curve(u2 + Y2, g2, n2 - Y2, o2, n2, o2);
              x2 += O2, b2 += O2, r2 &gt;= i2[a2].length - 2 &amp;&amp; (S2 &amp;&amp; (x2 += k2.curve(n2, o2, n2, o2, n2, c2) + k2.move(n2, c2)), b2 += k2.curve(n2, o2, n2, o2, n2, A2) + k2.line(f2, A2) + &quot;z&quot;, m2.push(x2), v2.push(b2), p2 = -1);
            }
        }
        u2 = n2, g2 = o2;
        break;
      default:
        var F2 = function(t4, e3, i3) {
          var a3 = [];
          switch (t4) {
            case &quot;stepline&quot;:
              a3 = k2.line(e3, null, &quot;H&quot;) + k2.line(null, i3, &quot;V&quot;);
              break;
            case &quot;linestep&quot;:
              a3 = k2.line(null, i3, &quot;V&quot;) + k2.line(e3, null, &quot;H&quot;);
              break;
            case &quot;straight&quot;:
              a3 = k2.line(e3, i3);
          }
          return a3;
        };
        if (null === i2[a2][r2]) p2 = 0;
        else switch (p2) {
          case 0:
            if (f2 = u2, x2 = S2 ? k2.move(u2, d2[r2]) + k2.line(u2, g2) : k2.move(u2, g2), b2 = k2.move(u2, g2), null === i2[a2][r2 + 1] || void 0 === i2[a2][r2 + 1]) {
              m2.push(x2), v2.push(b2);
              break;
            }
            if (p2 = 1, r2 &lt; i2[a2].length - 2) {
              var D2 = F2(y2, n2, o2);
              x2 += D2, b2 += D2;
              break;
            }
          case 1:
            if (null === i2[a2][r2 + 1]) x2 += S2 ? k2.line(u2, c2) : k2.move(u2, g2), b2 += k2.line(u2, A2) + k2.line(f2, A2) + &quot;z&quot;, m2.push(x2), v2.push(b2), p2 = -1;
            else {
              var _2 = F2(y2, n2, o2);
              x2 += _2, b2 += _2, r2 &gt;= i2[a2].length - 2 &amp;&amp; (S2 &amp;&amp; (x2 += k2.line(n2, c2)), b2 += k2.line(n2, A2) + k2.line(f2, A2) + &quot;z&quot;, m2.push(x2), v2.push(b2), p2 = -1);
            }
        }
        u2 = n2, g2 = o2;
    }
    return { linePaths: m2, areaPaths: v2, pX: u2, pY: g2, pathState: p2, segmentStartX: f2, linePath: x2, areaPath: b2 };
  } }, { key: &quot;handleNullDataPoints&quot;, value: function(t3, e2, i2, a2, s2) {
    var r2 = this.w;
    if (null === t3[i2][a2] &amp;&amp; r2.config.markers.showNullDataPoints || 1 === t3[i2].length) {
      var n2 = this.strokeWidth - r2.config.markers.strokeWidth / 2;
      n2 &gt; 0 || (n2 = 0);
      var o2 = this.markers.plotChartMarkers({ pointsPos: e2, seriesIndex: s2, j: a2 + 1, pSize: n2, alwaysDrawMarker: true });
      null !== o2 &amp;&amp; this.elPointsMain.add(o2);
    }
  } }]), t2;
}();
window.TreemapSquared = {}, window.TreemapSquared.generate = /* @__PURE__ */ function() {
  function t2(e3, i3, a3, s3) {
    this.xoffset = e3, this.yoffset = i3, this.height = s3, this.width = a3, this.shortestEdge = function() {
      return Math.min(this.height, this.width);
    }, this.getCoordinates = function(t3) {
      var e4, i4 = [], a4 = this.xoffset, s4 = this.yoffset, n3 = r2(t3) / this.height, o2 = r2(t3) / this.width;
      if (this.width &gt;= this.height) for (e4 = 0; e4 &lt; t3.length; e4++) i4.push([a4, s4, a4 + n3, s4 + t3[e4] / n3]), s4 += t3[e4] / n3;
      else for (e4 = 0; e4 &lt; t3.length; e4++) i4.push([a4, s4, a4 + t3[e4] / o2, s4 + o2]), a4 += t3[e4] / o2;
      return i4;
    }, this.cutArea = function(e4) {
      var i4;
      if (this.width &gt;= this.height) {
        var a4 = e4 / this.height, s4 = this.width - a4;
        i4 = new t2(this.xoffset + a4, this.yoffset, s4, this.height);
      } else {
        var r3 = e4 / this.width, n3 = this.height - r3;
        i4 = new t2(this.xoffset, this.yoffset + r3, this.width, n3);
      }
      return i4;
    };
  }
  function e2(e3, a3, s3, n3, o2) {
    n3 = void 0 === n3 ? 0 : n3, o2 = void 0 === o2 ? 0 : o2;
    var l2 = i2(function(t3, e4) {
      var i3, a4 = [], s4 = e4 / r2(t3);
      for (i3 = 0; i3 &lt; t3.length; i3++) a4[i3] = t3[i3] * s4;
      return a4;
    }(e3, a3 * s3), [], new t2(n3, o2, a3, s3), []);
    return function(t3) {
      var e4, i3, a4 = [];
      for (e4 = 0; e4 &lt; t3.length; e4++) for (i3 = 0; i3 &lt; t3[e4].length; i3++) a4.push(t3[e4][i3]);
      return a4;
    }(l2);
  }
  function i2(t3, e3, s3, n3) {
    var o2, l2, h2;
    if (0 !== t3.length) return o2 = s3.shortestEdge(), function(t4, e4, i3) {
      var s4;
      if (0 === t4.length) return true;
      (s4 = t4.slice()).push(e4);
      var r3 = a2(t4, i3), n4 = a2(s4, i3);
      return r3 &gt;= n4;
    }(e3, l2 = t3[0], o2) ? (e3.push(l2), i2(t3.slice(1), e3, s3, n3)) : (h2 = s3.cutArea(r2(e3), n3), n3.push(s3.getCoordinates(e3)), i2(t3, [], h2, n3)), n3;
    n3.push(s3.getCoordinates(e3));
  }
  function a2(t3, e3) {
    var i3 = Math.min.apply(Math, t3), a3 = Math.max.apply(Math, t3), s3 = r2(t3);
    return Math.max(Math.pow(e3, 2) * a3 / Math.pow(s3, 2), Math.pow(s3, 2) / (Math.pow(e3, 2) * i3));
  }
  function s2(t3) {
    return t3 &amp;&amp; t3.constructor === Array;
  }
  function r2(t3) {
    var e3, i3 = 0;
    for (e3 = 0; e3 &lt; t3.length; e3++) i3 += t3[e3];
    return i3;
  }
  function n2(t3) {
    var e3, i3 = 0;
    if (s2(t3[0])) for (e3 = 0; e3 &lt; t3.length; e3++) i3 += n2(t3[e3]);
    else i3 = r2(t3);
    return i3;
  }
  return function t3(i3, a3, r3, o2, l2) {
    o2 = void 0 === o2 ? 0 : o2, l2 = void 0 === l2 ? 0 : l2;
    var h2, c2, d2 = [], u2 = [];
    if (s2(i3[0])) {
      for (c2 = 0; c2 &lt; i3.length; c2++) d2[c2] = n2(i3[c2]);
      for (h2 = e2(d2, a3, r3, o2, l2), c2 = 0; c2 &lt; i3.length; c2++) u2.push(t3(i3[c2], h2[c2][2] - h2[c2][0], h2[c2][3] - h2[c2][1], h2[c2][0], h2[c2][1]));
    } else u2 = e2(i3, a3, r3, o2, l2);
    return u2;
  };
}();
var Ga = function() {
  function t2(e2, a2) {
    i(this, t2), this.ctx = e2, this.w = e2.w, this.strokeWidth = this.w.config.stroke.width, this.helpers = new za(e2), this.dynamicAnim = this.w.config.chart.animations.dynamicAnimation, this.labels = [];
  }
  return s(t2, [{ key: &quot;draw&quot;, value: function(t3) {
    var e2 = this, i2 = this.w, a2 = new Mi(this.ctx), s2 = new ji(this.ctx), r2 = a2.group({ class: &quot;apexcharts-treemap&quot; });
    if (i2.globals.noData) return r2;
    var n2 = [];
    return t3.forEach(function(t4) {
      var e3 = t4.map(function(t5) {
        return Math.abs(t5);
      });
      n2.push(e3);
    }), this.negRange = this.helpers.checkColorRange(), i2.config.series.forEach(function(t4, i3) {
      t4.data.forEach(function(t5) {
        Array.isArray(e2.labels[i3]) || (e2.labels[i3] = []), e2.labels[i3].push(t5.x);
      });
    }), window.TreemapSquared.generate(n2, i2.globals.gridWidth, i2.globals.gridHeight).forEach(function(n3, o2) {
      var l2 = a2.group({ class: &quot;apexcharts-series apexcharts-treemap-series&quot;, seriesName: v.escapeString(i2.globals.seriesNames[o2]), rel: o2 + 1, &quot;data:realIndex&quot;: o2 });
      if (i2.config.chart.dropShadow.enabled) {
        var h2 = i2.config.chart.dropShadow;
        new Li(e2.ctx).dropShadow(r2, h2, o2);
      }
      var c2 = a2.group({ class: &quot;apexcharts-data-labels&quot; }), d2 = { xMin: 1 / 0, yMin: 1 / 0, xMax: -1 / 0, yMax: -1 / 0 };
      n3.forEach(function(r3, n4) {
        var h3 = r3[0], c3 = r3[1], u3 = r3[2], g3 = r3[3];
        d2.xMin = Math.min(d2.xMin, h3), d2.yMin = Math.min(d2.yMin, c3), d2.xMax = Math.max(d2.xMax, u3), d2.yMax = Math.max(d2.yMax, g3);
        var p3 = e2.helpers.getShadeColor(i2.config.chart.type, o2, n4, e2.negRange), f3 = p3.color, x3 = s2.fillPath({ color: f3, seriesNumber: o2, dataPointIndex: n4 }), b3 = a2.drawRect(h3, c3, u3 - h3, g3 - c3, i2.config.plotOptions.treemap.borderRadius, &quot;#fff&quot;, 1, e2.strokeWidth, i2.config.plotOptions.treemap.useFillColorAsStroke ? f3 : i2.globals.stroke.colors[o2]);
        b3.attr({ cx: h3, cy: c3, index: o2, i: o2, j: n4, width: u3 - h3, height: g3 - c3, fill: x3 }), b3.node.classList.add(&quot;apexcharts-treemap-rect&quot;), e2.helpers.addListeners(b3);
        var m3 = { x: h3 + (u3 - h3) / 2, y: c3 + (g3 - c3) / 2, width: 0, height: 0 }, v2 = { x: h3, y: c3, width: u3 - h3, height: g3 - c3 };
        if (i2.config.chart.animations.enabled &amp;&amp; !i2.globals.dataChanged) {
          var y3 = 1;
          i2.globals.resized || (y3 = i2.config.chart.animations.speed), e2.animateTreemap(b3, m3, v2, y3);
        }
        if (i2.globals.dataChanged) {
          var w3 = 1;
          e2.dynamicAnim.enabled &amp;&amp; i2.globals.shouldAnimate &amp;&amp; (w3 = e2.dynamicAnim.speed, i2.globals.previousPaths[o2] &amp;&amp; i2.globals.previousPaths[o2][n4] &amp;&amp; i2.globals.previousPaths[o2][n4].rect &amp;&amp; (m3 = i2.globals.previousPaths[o2][n4].rect), e2.animateTreemap(b3, m3, v2, w3));
        }
        var k3 = e2.getFontSize(r3), A3 = i2.config.dataLabels.formatter(e2.labels[o2][n4], { value: i2.globals.series[o2][n4], seriesIndex: o2, dataPointIndex: n4, w: i2 });
        &quot;truncate&quot; === i2.config.plotOptions.treemap.dataLabels.format &amp;&amp; (k3 = parseInt(i2.config.dataLabels.style.fontSize, 10), A3 = e2.truncateLabels(A3, k3, h3, c3, u3, g3));
        var C3 = null;
        i2.globals.series[o2][n4] &amp;&amp; (C3 = e2.helpers.calculateDataLabels({ text: A3, x: (h3 + u3) / 2, y: (c3 + g3) / 2 + e2.strokeWidth / 2 + k3 / 3, i: o2, j: n4, colorProps: p3, fontSize: k3, series: t3 })), i2.config.dataLabels.enabled &amp;&amp; C3 &amp;&amp; e2.rotateToFitLabel(C3, k3, A3, h3, c3, u3, g3), l2.add(b3), null !== C3 &amp;&amp; l2.add(C3);
      });
      var u2 = i2.config.plotOptions.treemap.seriesTitle;
      if (i2.config.series.length &gt; 1 &amp;&amp; u2 &amp;&amp; u2.show) {
        var g2 = i2.config.series[o2].name || &quot;&quot;;
        if (g2 &amp;&amp; d2.xMin &lt; 1 / 0 &amp;&amp; d2.yMin &lt; 1 / 0) {
          var p2 = u2.offsetX, f2 = u2.offsetY, x2 = u2.borderColor, b2 = u2.borderWidth, m2 = u2.borderRadius, y2 = u2.style, w2 = y2.color || i2.config.chart.foreColor, k2 = { left: y2.padding.left, right: y2.padding.right, top: y2.padding.top, bottom: y2.padding.bottom }, A2 = a2.getTextRects(g2, y2.fontSize, y2.fontFamily), C2 = A2.width + k2.left + k2.right, S2 = A2.height + k2.top + k2.bottom, L2 = d2.xMin + (p2 || 0), M2 = d2.yMin + (f2 || 0), P2 = a2.drawRect(L2, M2, C2, S2, m2, y2.background, 1, b2, x2), I2 = a2.drawText({ x: L2 + k2.left, y: M2 + k2.top + 0.75 * A2.height, text: g2, fontSize: y2.fontSize, fontFamily: y2.fontFamily, fontWeight: y2.fontWeight, foreColor: w2, cssClass: y2.cssClass || &quot;&quot; });
          l2.add(P2), l2.add(I2);
        }
      }
      l2.add(c2), r2.add(l2);
    }), r2;
  } }, { key: &quot;getFontSize&quot;, value: function(t3) {
    var e2 = this.w;
    var i2 = function t4(e3) {
      var i3, a2 = 0;
      if (Array.isArray(e3[0])) for (i3 = 0; i3 &lt; e3.length; i3++) a2 += t4(e3[i3]);
      else for (i3 = 0; i3 &lt; e3.length; i3++) a2 += e3[i3].length;
      return a2;
    }(this.labels) / function t4(e3) {
      var i3, a2 = 0;
      if (Array.isArray(e3[0])) for (i3 = 0; i3 &lt; e3.length; i3++) a2 += t4(e3[i3]);
      else for (i3 = 0; i3 &lt; e3.length; i3++) a2 += 1;
      return a2;
    }(this.labels);
    return function(t4, a2) {
      var s2 = t4 * a2, r2 = Math.pow(s2, 0.5);
      return Math.min(r2 / i2, parseInt(e2.config.dataLabels.style.fontSize, 10));
    }(t3[2] - t3[0], t3[3] - t3[1]);
  } }, { key: &quot;rotateToFitLabel&quot;, value: function(t3, e2, i2, a2, s2, r2, n2) {
    var o2 = new Mi(this.ctx), l2 = o2.getTextRects(i2, e2);
    if (l2.width + this.w.config.stroke.width + 5 &gt; r2 - a2 &amp;&amp; l2.width &lt;= n2 - s2) {
      var h2 = o2.rotateAroundCenter(t3.node);
      t3.node.setAttribute(&quot;transform&quot;, &quot;rotate(-90 &quot;.concat(h2.x, &quot; &quot;).concat(h2.y, &quot;) translate(&quot;).concat(l2.height / 3, &quot;)&quot;));
    }
  } }, { key: &quot;truncateLabels&quot;, value: function(t3, e2, i2, a2, s2, r2) {
    var n2 = new Mi(this.ctx), o2 = n2.getTextRects(t3, e2).width + this.w.config.stroke.width + 5 &gt; s2 - i2 &amp;&amp; r2 - a2 &gt; s2 - i2 ? r2 - a2 : s2 - i2, l2 = n2.getTextBasedOnMaxWidth({ text: t3, maxWidth: o2, fontSize: e2 });
    return t3.length !== l2.length &amp;&amp; o2 / e2 &lt; 5 ? &quot;&quot; : l2;
  } }, { key: &quot;animateTreemap&quot;, value: function(t3, e2, i2, a2) {
    var s2 = new y(this.ctx);
    s2.animateRect(t3, e2, i2, a2, function() {
      s2.animationCompleted(t3);
    });
  } }]), t2;
}();
var ja = 86400;
var Va = 10 / ja;
var Ua = function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w, this.timeScaleArray = [], this.utc = this.w.config.xaxis.labels.datetimeUTC;
  }
  return s(t2, [{ key: &quot;calculateTimeScaleTicks&quot;, value: function(t3, e2) {
    var i2 = this, a2 = this.w;
    if (a2.globals.allSeriesCollapsed) return a2.globals.labels = [], a2.globals.timescaleLabels = [], [];
    var s2 = new zi(this.ctx), r2 = (e2 - t3) / 864e5;
    this.determineInterval(r2), a2.globals.disableZoomIn = false, a2.globals.disableZoomOut = false, r2 &lt; Va ? a2.globals.disableZoomIn = true : r2 &gt; 5e4 &amp;&amp; (a2.globals.disableZoomOut = true);
    var n2 = s2.getTimeUnitsfromTimestamp(t3, e2, this.utc), o2 = a2.globals.gridWidth / r2, l2 = o2 / 24, h2 = l2 / 60, c2 = h2 / 60, d2 = Math.floor(24 * r2), g2 = Math.floor(1440 * r2), p2 = Math.floor(r2 * ja), f2 = Math.floor(r2), x2 = Math.floor(r2 / 30), b2 = Math.floor(r2 / 365), m2 = { minMillisecond: n2.minMillisecond, minSecond: n2.minSecond, minMinute: n2.minMinute, minHour: n2.minHour, minDate: n2.minDate, minMonth: n2.minMonth, minYear: n2.minYear }, v2 = { firstVal: m2, currentMillisecond: m2.minMillisecond, currentSecond: m2.minSecond, currentMinute: m2.minMinute, currentHour: m2.minHour, currentMonthDate: m2.minDate, currentDate: m2.minDate, currentMonth: m2.minMonth, currentYear: m2.minYear, daysWidthOnXAxis: o2, hoursWidthOnXAxis: l2, minutesWidthOnXAxis: h2, secondsWidthOnXAxis: c2, numberOfSeconds: p2, numberOfMinutes: g2, numberOfHours: d2, numberOfDays: f2, numberOfMonths: x2, numberOfYears: b2 };
    switch (this.tickInterval) {
      case &quot;years&quot;:
        this.generateYearScale(v2);
        break;
      case &quot;months&quot;:
      case &quot;half_year&quot;:
        this.generateMonthScale(v2);
        break;
      case &quot;months_days&quot;:
      case &quot;months_fortnight&quot;:
      case &quot;days&quot;:
      case &quot;week_days&quot;:
        this.generateDayScale(v2);
        break;
      case &quot;hours&quot;:
        this.generateHourScale(v2);
        break;
      case &quot;minutes_fives&quot;:
      case &quot;minutes&quot;:
        this.generateMinuteScale(v2);
        break;
      case &quot;seconds_tens&quot;:
      case &quot;seconds_fives&quot;:
      case &quot;seconds&quot;:
        this.generateSecondScale(v2);
    }
    var y2 = this.timeScaleArray.map(function(t4) {
      var e3 = { position: t4.position, unit: t4.unit, year: t4.year, day: t4.day ? t4.day : 1, hour: t4.hour ? t4.hour : 0, month: t4.month + 1 };
      return &quot;month&quot; === t4.unit ? u(u({}, e3), {}, { day: 1, value: t4.value + 1 }) : &quot;day&quot; === t4.unit || &quot;hour&quot; === t4.unit ? u(u({}, e3), {}, { value: t4.value }) : &quot;minute&quot; === t4.unit ? u(u({}, e3), {}, { value: t4.value, minute: t4.value }) : &quot;second&quot; === t4.unit ? u(u({}, e3), {}, { value: t4.value, minute: t4.minute, second: t4.second }) : t4;
    });
    return y2.filter(function(t4) {
      var e3 = 1, s3 = Math.ceil(a2.globals.gridWidth / 120), r3 = t4.value;
      void 0 !== a2.config.xaxis.tickAmount &amp;&amp; (s3 = a2.config.xaxis.tickAmount), y2.length &gt; s3 &amp;&amp; (e3 = Math.floor(y2.length / s3));
      var n3 = false, o3 = false;
      switch (i2.tickInterval) {
        case &quot;years&quot;:
          &quot;year&quot; === t4.unit &amp;&amp; (n3 = true);
          break;
        case &quot;half_year&quot;:
          e3 = 7, &quot;year&quot; === t4.unit &amp;&amp; (n3 = true);
          break;
        case &quot;months&quot;:
          e3 = 1, &quot;year&quot; === t4.unit &amp;&amp; (n3 = true);
          break;
        case &quot;months_fortnight&quot;:
          e3 = 15, &quot;year&quot; !== t4.unit &amp;&amp; &quot;month&quot; !== t4.unit || (n3 = true), 30 === r3 &amp;&amp; (o3 = true);
          break;
        case &quot;months_days&quot;:
          e3 = 10, &quot;month&quot; === t4.unit &amp;&amp; (n3 = true), 30 === r3 &amp;&amp; (o3 = true);
          break;
        case &quot;week_days&quot;:
          e3 = 8, &quot;month&quot; === t4.unit &amp;&amp; (n3 = true);
          break;
        case &quot;days&quot;:
          e3 = 1, &quot;month&quot; === t4.unit &amp;&amp; (n3 = true);
          break;
        case &quot;hours&quot;:
          &quot;day&quot; === t4.unit &amp;&amp; (n3 = true);
          break;
        case &quot;minutes_fives&quot;:
        case &quot;seconds_fives&quot;:
          r3 % 5 != 0 &amp;&amp; (o3 = true);
          break;
        case &quot;seconds_tens&quot;:
          r3 % 10 != 0 &amp;&amp; (o3 = true);
      }
      if (&quot;hours&quot; === i2.tickInterval || &quot;minutes_fives&quot; === i2.tickInterval || &quot;seconds_tens&quot; === i2.tickInterval || &quot;seconds_fives&quot; === i2.tickInterval) {
        if (!o3) return true;
      } else if ((r3 % e3 == 0 || n3) &amp;&amp; !o3) return true;
    });
  } }, { key: &quot;recalcDimensionsBasedOnFormat&quot;, value: function(t3, e2) {
    var i2 = this.w, a2 = this.formatDates(t3), s2 = this.removeOverlappingTS(a2);
    i2.globals.timescaleLabels = s2.slice(), new pa(this.ctx).plotCoords();
  } }, { key: &quot;determineInterval&quot;, value: function(t3) {
    var e2 = 24 * t3, i2 = 60 * e2;
    switch (true) {
      case t3 / 365 &gt; 5:
        this.tickInterval = &quot;years&quot;;
        break;
      case t3 &gt; 800:
        this.tickInterval = &quot;half_year&quot;;
        break;
      case t3 &gt; 180:
        this.tickInterval = &quot;months&quot;;
        break;
      case t3 &gt; 90:
        this.tickInterval = &quot;months_fortnight&quot;;
        break;
      case t3 &gt; 60:
        this.tickInterval = &quot;months_days&quot;;
        break;
      case t3 &gt; 30:
        this.tickInterval = &quot;week_days&quot;;
        break;
      case t3 &gt; 2:
        this.tickInterval = &quot;days&quot;;
        break;
      case e2 &gt; 2.4:
        this.tickInterval = &quot;hours&quot;;
        break;
      case i2 &gt; 15:
        this.tickInterval = &quot;minutes_fives&quot;;
        break;
      case i2 &gt; 5:
        this.tickInterval = &quot;minutes&quot;;
        break;
      case i2 &gt; 1:
        this.tickInterval = &quot;seconds_tens&quot;;
        break;
      case 60 * i2 &gt; 20:
        this.tickInterval = &quot;seconds_fives&quot;;
        break;
      default:
        this.tickInterval = &quot;seconds&quot;;
    }
  } }, { key: &quot;generateYearScale&quot;, value: function(t3) {
    var e2 = t3.firstVal, i2 = t3.currentMonth, a2 = t3.currentYear, s2 = t3.daysWidthOnXAxis, r2 = t3.numberOfYears, n2 = e2.minYear, o2 = 0, l2 = new zi(this.ctx), h2 = &quot;year&quot;;
    if (e2.minDate &gt; 1 || e2.minMonth &gt; 0) {
      var c2 = l2.determineRemainingDaysOfYear(e2.minYear, e2.minMonth, e2.minDate);
      o2 = (l2.determineDaysOfYear(e2.minYear) - c2 + 1) * s2, n2 = e2.minYear + 1, this.timeScaleArray.push({ position: o2, value: n2, unit: h2, year: n2, month: v.monthMod(i2 + 1) });
    } else 1 === e2.minDate &amp;&amp; 0 === e2.minMonth &amp;&amp; this.timeScaleArray.push({ position: o2, value: n2, unit: h2, year: a2, month: v.monthMod(i2 + 1) });
    for (var d2 = n2, u2 = o2, g2 = 0; g2 &lt; r2; g2++) d2++, u2 = l2.determineDaysOfYear(d2 - 1) * s2 + u2, this.timeScaleArray.push({ position: u2, value: d2, unit: h2, year: d2, month: 1 });
  } }, { key: &quot;generateMonthScale&quot;, value: function(t3) {
    var e2 = t3.firstVal, i2 = t3.currentMonthDate, a2 = t3.currentMonth, s2 = t3.currentYear, r2 = t3.daysWidthOnXAxis, n2 = t3.numberOfMonths, o2 = a2, l2 = 0, h2 = new zi(this.ctx), c2 = &quot;month&quot;, d2 = 0;
    if (e2.minDate &gt; 1) {
      l2 = (h2.determineDaysOfMonths(a2 + 1, e2.minYear) - i2 + 1) * r2, o2 = v.monthMod(a2 + 1);
      var u2 = s2 + d2, g2 = v.monthMod(o2), p2 = o2;
      0 === o2 &amp;&amp; (c2 = &quot;year&quot;, p2 = u2, g2 = 1, u2 += d2 += 1), this.timeScaleArray.push({ position: l2, value: p2, unit: c2, year: u2, month: g2 });
    } else this.timeScaleArray.push({ position: l2, value: o2, unit: c2, year: s2, month: v.monthMod(a2) });
    for (var f2 = o2 + 1, x2 = l2, b2 = 0, m2 = 1; b2 &lt; n2; b2++, m2++) {
      0 === (f2 = v.monthMod(f2)) ? (c2 = &quot;year&quot;, d2 += 1) : c2 = &quot;month&quot;;
      var y2 = this._getYear(s2, f2, d2);
      x2 = h2.determineDaysOfMonths(f2, y2) * r2 + x2;
      var w2 = 0 === f2 ? y2 : f2;
      this.timeScaleArray.push({ position: x2, value: w2, unit: c2, year: y2, month: 0 === f2 ? 1 : f2 }), f2++;
    }
  } }, { key: &quot;generateDayScale&quot;, value: function(t3) {
    var e2 = t3.firstVal, i2 = t3.currentMonth, a2 = t3.currentYear, s2 = t3.hoursWidthOnXAxis, r2 = t3.numberOfDays, n2 = new zi(this.ctx), o2 = &quot;day&quot;, l2 = e2.minDate + 1, h2 = l2, c2 = function(t4, e3, i3) {
      return t4 &gt; n2.determineDaysOfMonths(e3 + 1, i3) ? (h2 = 1, o2 = &quot;month&quot;, u2 = e3 += 1, e3) : e3;
    }, d2 = (24 - e2.minHour) * s2, u2 = l2, g2 = c2(h2, i2, a2);
    0 === e2.minHour &amp;&amp; 1 === e2.minDate ? (d2 = 0, u2 = v.monthMod(e2.minMonth), o2 = &quot;month&quot;, h2 = e2.minDate) : 1 !== e2.minDate &amp;&amp; 0 === e2.minHour &amp;&amp; 0 === e2.minMinute &amp;&amp; (d2 = 0, l2 = e2.minDate, u2 = l2, g2 = c2(h2 = l2, i2, a2), 1 !== u2 &amp;&amp; (o2 = &quot;day&quot;)), this.timeScaleArray.push({ position: d2, value: u2, unit: o2, year: this._getYear(a2, g2, 0), month: v.monthMod(g2), day: h2 });
    for (var p2 = d2, f2 = 0; f2 &lt; r2; f2++) {
      o2 = &quot;day&quot;, g2 = c2(h2 += 1, g2, this._getYear(a2, g2, 0));
      var x2 = this._getYear(a2, g2, 0);
      p2 = 24 * s2 + p2;
      var b2 = 1 === h2 ? v.monthMod(g2) : h2;
      this.timeScaleArray.push({ position: p2, value: b2, unit: o2, year: x2, month: v.monthMod(g2), day: b2 });
    }
  } }, { key: &quot;generateHourScale&quot;, value: function(t3) {
    var e2 = t3.firstVal, i2 = t3.currentDate, a2 = t3.currentMonth, s2 = t3.currentYear, r2 = t3.minutesWidthOnXAxis, n2 = t3.numberOfHours, o2 = new zi(this.ctx), l2 = &quot;hour&quot;, h2 = function(t4, e3) {
      return t4 &gt; o2.determineDaysOfMonths(e3 + 1, s2) &amp;&amp; (f2 = 1, e3 += 1), { month: e3, date: f2 };
    }, c2 = function(t4, e3) {
      return t4 &gt; o2.determineDaysOfMonths(e3 + 1, s2) ? e3 += 1 : e3;
    }, d2 = 60 - (e2.minMinute + e2.minSecond / 60), u2 = d2 * r2, g2 = e2.minHour + 1, p2 = g2;
    60 === d2 &amp;&amp; (u2 = 0, p2 = g2 = e2.minHour);
    var f2 = i2;
    p2 &gt;= 24 &amp;&amp; (p2 = 0, l2 = &quot;day&quot;, g2 = f2 += 1);
    var x2 = h2(f2, a2).month;
    x2 = c2(f2, x2), g2 &gt; 31 &amp;&amp; (g2 = f2 = 1), this.timeScaleArray.push({ position: u2, value: g2, unit: l2, day: f2, hour: p2, year: s2, month: v.monthMod(x2) }), p2++;
    for (var b2 = u2, m2 = 0; m2 &lt; n2; m2++) {
      if (l2 = &quot;hour&quot;, p2 &gt;= 24) p2 = 0, l2 = &quot;day&quot;, x2 = h2(f2 += 1, x2).month, x2 = c2(f2, x2);
      var y2 = this._getYear(s2, x2, 0);
      b2 = 60 * r2 + b2;
      var w2 = 0 === p2 ? f2 : p2;
      this.timeScaleArray.push({ position: b2, value: w2, unit: l2, hour: p2, day: f2, year: y2, month: v.monthMod(x2) }), p2++;
    }
  } }, { key: &quot;generateMinuteScale&quot;, value: function(t3) {
    for (var e2 = t3.currentMillisecond, i2 = t3.currentSecond, a2 = t3.currentMinute, s2 = t3.currentHour, r2 = t3.currentDate, n2 = t3.currentMonth, o2 = t3.currentYear, l2 = t3.minutesWidthOnXAxis, h2 = t3.secondsWidthOnXAxis, c2 = t3.numberOfMinutes, d2 = a2 + 1, u2 = r2, g2 = n2, p2 = o2, f2 = s2, x2 = (60 - i2 - e2 / 1e3) * h2, b2 = 0; b2 &lt; c2; b2++) d2 &gt;= 60 &amp;&amp; (d2 = 0, 24 === (f2 += 1) &amp;&amp; (f2 = 0)), this.timeScaleArray.push({ position: x2, value: d2, unit: &quot;minute&quot;, hour: f2, minute: d2, day: u2, year: this._getYear(p2, g2, 0), month: v.monthMod(g2) }), x2 += l2, d2++;
  } }, { key: &quot;generateSecondScale&quot;, value: function(t3) {
    for (var e2 = t3.currentMillisecond, i2 = t3.currentSecond, a2 = t3.currentMinute, s2 = t3.currentHour, r2 = t3.currentDate, n2 = t3.currentMonth, o2 = t3.currentYear, l2 = t3.secondsWidthOnXAxis, h2 = t3.numberOfSeconds, c2 = i2 + 1, d2 = a2, u2 = r2, g2 = n2, p2 = o2, f2 = s2, x2 = (1e3 - e2) / 1e3 * l2, b2 = 0; b2 &lt; h2; b2++) c2 &gt;= 60 &amp;&amp; (c2 = 0, ++d2 &gt;= 60 &amp;&amp; (d2 = 0, 24 === ++f2 &amp;&amp; (f2 = 0))), this.timeScaleArray.push({ position: x2, value: c2, unit: &quot;second&quot;, hour: f2, minute: d2, second: c2, day: u2, year: this._getYear(p2, g2, 0), month: v.monthMod(g2) }), x2 += l2, c2++;
  } }, { key: &quot;createRawDateString&quot;, value: function(t3, e2) {
    var i2 = t3.year;
    return 0 === t3.month &amp;&amp; (t3.month = 1), i2 += &quot;-&quot; + (&quot;0&quot; + t3.month.toString()).slice(-2), &quot;day&quot; === t3.unit ? i2 += &quot;day&quot; === t3.unit ? &quot;-&quot; + (&quot;0&quot; + e2).slice(-2) : &quot;-01&quot; : i2 += &quot;-&quot; + (&quot;0&quot; + (t3.day ? t3.day : &quot;1&quot;)).slice(-2), &quot;hour&quot; === t3.unit ? i2 += &quot;hour&quot; === t3.unit ? &quot;T&quot; + (&quot;0&quot; + e2).slice(-2) : &quot;T00&quot; : i2 += &quot;T&quot; + (&quot;0&quot; + (t3.hour ? t3.hour : &quot;0&quot;)).slice(-2), &quot;minute&quot; === t3.unit ? i2 += &quot;:&quot; + (&quot;0&quot; + e2).slice(-2) : i2 += &quot;:&quot; + (t3.minute ? (&quot;0&quot; + t3.minute).slice(-2) : &quot;00&quot;), &quot;second&quot; === t3.unit ? i2 += &quot;:&quot; + (&quot;0&quot; + e2).slice(-2) : i2 += &quot;:00&quot;, this.utc &amp;&amp; (i2 += &quot;.000Z&quot;), i2;
  } }, { key: &quot;formatDates&quot;, value: function(t3) {
    var e2 = this, i2 = this.w;
    return t3.map(function(t4) {
      var a2 = t4.value.toString(), s2 = new zi(e2.ctx), r2 = e2.createRawDateString(t4, a2), n2 = s2.getDate(s2.parseDate(r2));
      if (e2.utc || (n2 = s2.getDate(s2.parseDateWithTimezone(r2))), void 0 === i2.config.xaxis.labels.format) {
        var o2 = &quot;dd MMM&quot;, l2 = i2.config.xaxis.labels.datetimeFormatter;
        &quot;year&quot; === t4.unit &amp;&amp; (o2 = l2.year), &quot;month&quot; === t4.unit &amp;&amp; (o2 = l2.month), &quot;day&quot; === t4.unit &amp;&amp; (o2 = l2.day), &quot;hour&quot; === t4.unit &amp;&amp; (o2 = l2.hour), &quot;minute&quot; === t4.unit &amp;&amp; (o2 = l2.minute), &quot;second&quot; === t4.unit &amp;&amp; (o2 = l2.second), a2 = s2.formatDate(n2, o2);
      } else a2 = s2.formatDate(n2, i2.config.xaxis.labels.format);
      return { dateString: r2, position: t4.position, value: a2, unit: t4.unit, year: t4.year, month: t4.month };
    });
  } }, { key: &quot;removeOverlappingTS&quot;, value: function(t3) {
    var e2, i2 = this, a2 = new Mi(this.ctx), s2 = false;
    t3.length &gt; 0 &amp;&amp; t3[0].value &amp;&amp; t3.every(function(e3) {
      return e3.value.length === t3[0].value.length;
    }) &amp;&amp; (s2 = true, e2 = a2.getTextRects(t3[0].value).width);
    var r2 = 0, n2 = t3.map(function(n3, o2) {
      if (o2 &gt; 0 &amp;&amp; i2.w.config.xaxis.labels.hideOverlappingLabels) {
        var l2 = s2 ? e2 : a2.getTextRects(t3[r2].value).width, h2 = t3[r2].position;
        return n3.position &gt; h2 + l2 + 10 ? (r2 = o2, n3) : null;
      }
      return n3;
    });
    return n2 = n2.filter(function(t4) {
      return null !== t4;
    });
  } }, { key: &quot;_getYear&quot;, value: function(t3, e2, i2) {
    return t3 + Math.floor(e2 / 12) + i2;
  } }]), t2;
}();
var qa = function() {
  function t2(e2, a2) {
    i(this, t2), this.ctx = a2, this.w = a2.w, this.el = e2;
  }
  return s(t2, [{ key: &quot;setupElements&quot;, value: function() {
    var t3 = this.w, e2 = t3.globals, i2 = t3.config, a2 = i2.chart.type;
    e2.axisCharts = [&quot;line&quot;, &quot;area&quot;, &quot;bar&quot;, &quot;rangeBar&quot;, &quot;rangeArea&quot;, &quot;candlestick&quot;, &quot;boxPlot&quot;, &quot;scatter&quot;, &quot;bubble&quot;, &quot;radar&quot;, &quot;heatmap&quot;, &quot;treemap&quot;].includes(a2), e2.xyCharts = [&quot;line&quot;, &quot;area&quot;, &quot;bar&quot;, &quot;rangeBar&quot;, &quot;rangeArea&quot;, &quot;candlestick&quot;, &quot;boxPlot&quot;, &quot;scatter&quot;, &quot;bubble&quot;].includes(a2), e2.isBarHorizontal = [&quot;bar&quot;, &quot;rangeBar&quot;, &quot;boxPlot&quot;].includes(a2) &amp;&amp; i2.plotOptions.bar.horizontal, e2.chartClass = &quot;.apexcharts&quot;.concat(e2.chartID), e2.dom.baseEl = this.el, e2.dom.elWrap = document.createElement(&quot;div&quot;), Mi.setAttrs(e2.dom.elWrap, { id: e2.chartClass.substring(1), class: &quot;apexcharts-canvas &quot;.concat(e2.chartClass.substring(1)) }), this.el.appendChild(e2.dom.elWrap), e2.dom.Paper = window.SVG().addTo(e2.dom.elWrap), e2.dom.Paper.attr({ class: &quot;apexcharts-svg&quot;, &quot;xmlns:data&quot;: &quot;ApexChartsNS&quot;, transform: &quot;translate(&quot;.concat(i2.chart.offsetX, &quot;, &quot;).concat(i2.chart.offsetY, &quot;)&quot;) }), e2.dom.Paper.node.style.background = &quot;dark&quot; !== i2.theme.mode || i2.chart.background ? &quot;light&quot; !== i2.theme.mode || i2.chart.background ? i2.chart.background : &quot;#fff&quot; : &quot;#424242&quot;, this.setSVGDimensions(), e2.dom.elLegendForeign = document.createElementNS(e2.SVGNS, &quot;foreignObject&quot;), Mi.setAttrs(e2.dom.elLegendForeign, { x: 0, y: 0, width: e2.svgWidth, height: e2.svgHeight }), e2.dom.elLegendWrap = document.createElement(&quot;div&quot;), e2.dom.elLegendWrap.classList.add(&quot;apexcharts-legend&quot;), e2.dom.elWrap.appendChild(e2.dom.elLegendWrap), e2.dom.Paper.node.appendChild(e2.dom.elLegendForeign), e2.dom.elGraphical = e2.dom.Paper.group().attr({ class: &quot;apexcharts-inner apexcharts-graphical&quot; }), e2.dom.elDefs = e2.dom.Paper.defs(), e2.dom.Paper.add(e2.dom.elGraphical), e2.dom.elGraphical.add(e2.dom.elDefs);
  } }, { key: &quot;plotChartType&quot;, value: function(t3, e2) {
    var i2 = this.w, a2 = this.ctx, s2 = i2.config, r2 = i2.globals, n2 = { line: { series: [], i: [] }, area: { series: [], i: [] }, scatter: { series: [], i: [] }, bubble: { series: [], i: [] }, bar: { series: [], i: [] }, candlestick: { series: [], i: [] }, boxPlot: { series: [], i: [] }, rangeBar: { series: [], i: [] }, rangeArea: { series: [], seriesRangeEnd: [], i: [] } }, o2 = s2.chart.type || &quot;line&quot;, l2 = null, h2 = 0;
    r2.series.forEach(function(e3, a3) {
      var s3 = &quot;column&quot; === t3[a3].type ? &quot;bar&quot; : t3[a3].type || (&quot;column&quot; === o2 ? &quot;bar&quot; : o2);
      n2[s3] ? (&quot;rangeArea&quot; === s3 ? (n2[s3].series.push(r2.seriesRangeStart[a3]), n2[s3].seriesRangeEnd.push(r2.seriesRangeEnd[a3])) : n2[s3].series.push(e3), n2[s3].i.push(a3), &quot;bar&quot; === s3 &amp;&amp; (i2.globals.columnSeries = n2.bar)) : [&quot;heatmap&quot;, &quot;treemap&quot;, &quot;pie&quot;, &quot;donut&quot;, &quot;polarArea&quot;, &quot;radialBar&quot;, &quot;radar&quot;].includes(s3) ? l2 = s3 : console.warn(&quot;You have specified an unrecognized series type (&quot;.concat(s3, &quot;).&quot;)), o2 !== s3 &amp;&amp; &quot;scatter&quot; !== s3 &amp;&amp; h2++;
    }), h2 &gt; 0 &amp;&amp; (l2 &amp;&amp; console.warn(&quot;Chart or series type &quot;.concat(l2, &quot; cannot appear with other chart or series types.&quot;)), n2.bar.series.length &gt; 0 &amp;&amp; s2.plotOptions.bar.horizontal &amp;&amp; (h2 -= n2.bar.series.length, n2.bar = { series: [], i: [] }, i2.globals.columnSeries = { series: [], i: [] }, console.warn(&quot;Horizontal bars are not supported in a mixed/combo chart. Please turn off `plotOptions.bar.horizontal`&quot;))), r2.comboCharts || (r2.comboCharts = h2 &gt; 0);
    var c2 = new Ba(a2, e2), d2 = new Ta(a2, e2);
    a2.pie = new Ea(a2);
    var u2 = new Ha(a2);
    a2.rangeBar = new Oa(a2, e2);
    var g2 = new Ya(a2), p2 = [];
    if (r2.comboCharts) {
      var x2, b2, m2 = new Pi(a2);
      if (n2.area.series.length &gt; 0) (x2 = p2).push.apply(x2, f(m2.drawSeriesByGroup(n2.area, r2.areaGroups, &quot;area&quot;, c2)));
      if (n2.bar.series.length &gt; 0) if (s2.chart.stacked) {
        var v2 = new Ia(a2, e2);
        p2.push(v2.draw(n2.bar.series, n2.bar.i));
      } else a2.bar = new Pa(a2, e2), p2.push(a2.bar.draw(n2.bar.series, n2.bar.i));
      if (n2.rangeArea.series.length &gt; 0 &amp;&amp; p2.push(c2.draw(n2.rangeArea.series, &quot;rangeArea&quot;, n2.rangeArea.i, n2.rangeArea.seriesRangeEnd)), n2.line.series.length &gt; 0) (b2 = p2).push.apply(b2, f(m2.drawSeriesByGroup(n2.line, r2.lineGroups, &quot;line&quot;, c2)));
      if (n2.candlestick.series.length &gt; 0 &amp;&amp; p2.push(d2.draw(n2.candlestick.series, &quot;candlestick&quot;, n2.candlestick.i)), n2.boxPlot.series.length &gt; 0 &amp;&amp; p2.push(d2.draw(n2.boxPlot.series, &quot;boxPlot&quot;, n2.boxPlot.i)), n2.rangeBar.series.length &gt; 0 &amp;&amp; p2.push(a2.rangeBar.draw(n2.rangeBar.series, n2.rangeBar.i)), n2.scatter.series.length &gt; 0) {
        var y2 = new Ba(a2, e2, true);
        p2.push(y2.draw(n2.scatter.series, &quot;scatter&quot;, n2.scatter.i));
      }
      if (n2.bubble.series.length &gt; 0) {
        var w2 = new Ba(a2, e2, true);
        p2.push(w2.draw(n2.bubble.series, &quot;bubble&quot;, n2.bubble.i));
      }
    } else switch (s2.chart.type) {
      case &quot;line&quot;:
        p2 = c2.draw(r2.series, &quot;line&quot;);
        break;
      case &quot;area&quot;:
        p2 = c2.draw(r2.series, &quot;area&quot;);
        break;
      case &quot;bar&quot;:
        if (s2.chart.stacked) p2 = new Ia(a2, e2).draw(r2.series);
        else a2.bar = new Pa(a2, e2), p2 = a2.bar.draw(r2.series);
        break;
      case &quot;candlestick&quot;:
        p2 = new Ta(a2, e2).draw(r2.series, &quot;candlestick&quot;);
        break;
      case &quot;boxPlot&quot;:
        p2 = new Ta(a2, e2).draw(r2.series, s2.chart.type);
        break;
      case &quot;rangeBar&quot;:
        p2 = a2.rangeBar.draw(r2.series);
        break;
      case &quot;rangeArea&quot;:
        p2 = c2.draw(r2.seriesRangeStart, &quot;rangeArea&quot;, void 0, r2.seriesRangeEnd);
        break;
      case &quot;heatmap&quot;:
        p2 = new Xa(a2, e2).draw(r2.series);
        break;
      case &quot;treemap&quot;:
        p2 = new Ga(a2, e2).draw(r2.series);
        break;
      case &quot;pie&quot;:
      case &quot;donut&quot;:
      case &quot;polarArea&quot;:
        p2 = a2.pie.draw(r2.series);
        break;
      case &quot;radialBar&quot;:
        p2 = u2.draw(r2.series);
        break;
      case &quot;radar&quot;:
        p2 = g2.draw(r2.series);
        break;
      default:
        p2 = c2.draw(r2.series);
    }
    return p2;
  } }, { key: &quot;setSVGDimensions&quot;, value: function() {
    var t3 = this.w, e2 = t3.globals, i2 = t3.config;
    i2.chart.width = i2.chart.width || &quot;100%&quot;, i2.chart.height = i2.chart.height || &quot;auto&quot;, e2.svgWidth = i2.chart.width, e2.svgHeight = i2.chart.height;
    var a2 = v.getDimensions(this.el), s2 = i2.chart.width.toString().split(/[0-9]+/g).pop();
    &quot;%&quot; === s2 ? v.isNumber(a2[0]) &amp;&amp; (0 === a2[0].width &amp;&amp; (a2 = v.getDimensions(this.el.parentNode)), e2.svgWidth = a2[0] * parseInt(i2.chart.width, 10) / 100) : &quot;px&quot; !== s2 &amp;&amp; &quot;&quot; !== s2 || (e2.svgWidth = parseInt(i2.chart.width, 10));
    var r2 = String(i2.chart.height).toString().split(/[0-9]+/g).pop();
    if (&quot;auto&quot; !== e2.svgHeight &amp;&amp; &quot;&quot; !== e2.svgHeight) if (&quot;%&quot; === r2) {
      var n2 = v.getDimensions(this.el.parentNode);
      e2.svgHeight = n2[1] * parseInt(i2.chart.height, 10) / 100;
    } else e2.svgHeight = parseInt(i2.chart.height, 10);
    else e2.svgHeight = e2.axisCharts ? e2.svgWidth / 1.61 : e2.svgWidth / 1.2;
    if (e2.svgWidth = Math.max(e2.svgWidth, 0), e2.svgHeight = Math.max(e2.svgHeight, 0), Mi.setAttrs(e2.dom.Paper.node, { width: e2.svgWidth, height: e2.svgHeight }), &quot;%&quot; !== r2) {
      var o2 = i2.chart.sparkline.enabled ? 0 : e2.axisCharts ? i2.chart.parentHeightOffset : 0;
      e2.dom.Paper.node.parentNode.parentNode.style.minHeight = &quot;&quot;.concat(e2.svgHeight + o2, &quot;px&quot;);
    }
    e2.dom.elWrap.style.width = &quot;&quot;.concat(e2.svgWidth, &quot;px&quot;), e2.dom.elWrap.style.height = &quot;&quot;.concat(e2.svgHeight, &quot;px&quot;);
  } }, { key: &quot;shiftGraphPosition&quot;, value: function() {
    var t3 = this.w.globals, e2 = t3.translateY, i2 = t3.translateX;
    Mi.setAttrs(t3.dom.elGraphical.node, { transform: &quot;translate(&quot;.concat(i2, &quot;, &quot;).concat(e2, &quot;)&quot;) });
  } }, { key: &quot;resizeNonAxisCharts&quot;, value: function() {
    var t3 = this.w, e2 = t3.globals, i2 = 0, a2 = t3.config.chart.sparkline.enabled ? 1 : 15;
    a2 += t3.config.grid.padding.bottom, [&quot;top&quot;, &quot;bottom&quot;].includes(t3.config.legend.position) &amp;&amp; t3.config.legend.show &amp;&amp; !t3.config.legend.floating &amp;&amp; (i2 = new xa(this.ctx).legendHelpers.getLegendDimensions().clwh + 7);
    var s2 = t3.globals.dom.baseEl.querySelector(&quot;.apexcharts-radialbar, .apexcharts-pie&quot;), r2 = 2.05 * t3.globals.radialSize;
    if (s2 &amp;&amp; !t3.config.chart.sparkline.enabled &amp;&amp; 0 !== t3.config.plotOptions.radialBar.startAngle) {
      var n2 = v.getBoundingClientRect(s2);
      r2 = n2.bottom;
      var o2 = n2.bottom - n2.top;
      r2 = Math.max(2.05 * t3.globals.radialSize, o2);
    }
    var l2 = Math.ceil(r2 + e2.translateY + i2 + a2);
    e2.dom.elLegendForeign &amp;&amp; e2.dom.elLegendForeign.setAttribute(&quot;height&quot;, l2), t3.config.chart.height &amp;&amp; String(t3.config.chart.height).includes(&quot;%&quot;) || (e2.dom.elWrap.style.height = &quot;&quot;.concat(l2, &quot;px&quot;), Mi.setAttrs(e2.dom.Paper.node, { height: l2 }), e2.dom.Paper.node.parentNode.parentNode.style.minHeight = &quot;&quot;.concat(l2, &quot;px&quot;));
  } }, { key: &quot;coreCalculations&quot;, value: function() {
    new ea(this.ctx).init();
  } }, { key: &quot;resetGlobals&quot;, value: function() {
    var t3 = this, e2 = function() {
      return t3.w.config.series.map(function() {
        return [];
      });
    }, i2 = new Bi(), a2 = this.w.globals;
    i2.initGlobalVars(a2), a2.seriesXvalues = e2(), a2.seriesYvalues = e2();
  } }, { key: &quot;isMultipleY&quot;, value: function() {
    return !!(Array.isArray(this.w.config.yaxis) &amp;&amp; this.w.config.yaxis.length &gt; 1) &amp;&amp; (this.w.globals.isMultipleYAxis = true, true);
  } }, { key: &quot;xySettings&quot;, value: function() {
    var t3 = this.w, e2 = null;
    if (t3.globals.axisCharts) {
      if (&quot;back&quot; === t3.config.xaxis.crosshairs.position &amp;&amp; new na(this.ctx).drawXCrosshairs(), &quot;back&quot; === t3.config.yaxis[0].crosshairs.position &amp;&amp; new na(this.ctx).drawYCrosshairs(), &quot;datetime&quot; === t3.config.xaxis.type &amp;&amp; void 0 === t3.config.xaxis.labels.formatter) {
        this.ctx.timeScale = new Ua(this.ctx);
        var i2 = [];
        isFinite(t3.globals.minX) &amp;&amp; isFinite(t3.globals.maxX) &amp;&amp; !t3.globals.isBarHorizontal ? i2 = this.ctx.timeScale.calculateTimeScaleTicks(t3.globals.minX, t3.globals.maxX) : t3.globals.isBarHorizontal &amp;&amp; (i2 = this.ctx.timeScale.calculateTimeScaleTicks(t3.globals.minY, t3.globals.maxY)), this.ctx.timeScale.recalcDimensionsBasedOnFormat(i2);
      }
      e2 = new Pi(this.ctx).getCalculatedRatios();
    }
    return e2;
  } }, { key: &quot;updateSourceChart&quot;, value: function(t3) {
    this.ctx.w.globals.selection = void 0, this.ctx.updateHelpers._updateOptions({ chart: { selection: { xaxis: { min: t3.w.globals.minX, max: t3.w.globals.maxX } } } }, false, false);
  } }, { key: &quot;setupBrushHandler&quot;, value: function() {
    var t3 = this, e2 = this.ctx, i2 = this.w;
    if (i2.config.chart.brush.enabled &amp;&amp; &quot;function&quot; != typeof i2.config.chart.events.selection) {
      var a2 = Array.isArray(i2.config.chart.brush.targets) ? i2.config.chart.brush.targets : [i2.config.chart.brush.target];
      a2.forEach(function(i3) {
        var a3 = e2.constructor.getChartByID(i3);
        a3.w.globals.brushSource = t3.ctx, &quot;function&quot; != typeof a3.w.config.chart.events.zoomed &amp;&amp; (a3.w.config.chart.events.zoomed = function() {
          return t3.updateSourceChart(a3);
        }), &quot;function&quot; != typeof a3.w.config.chart.events.scrolled &amp;&amp; (a3.w.config.chart.events.scrolled = function() {
          return t3.updateSourceChart(a3);
        });
      }), i2.config.chart.events.selection = function(t4, i3) {
        a2.forEach(function(t5) {
          e2.constructor.getChartByID(t5).ctx.updateHelpers._updateOptions({ xaxis: { min: i3.xaxis.min, max: i3.xaxis.max } }, false, false, false, false);
        });
      };
    }
  } }]), t2;
}();
var Za = function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w;
  }
  return s(t2, [{ key: &quot;_updateOptions&quot;, value: function(t3) {
    var e2 = this, i2 = arguments.length &gt; 1 &amp;&amp; void 0 !== arguments[1] &amp;&amp; arguments[1], a2 = !(arguments.length &gt; 2 &amp;&amp; void 0 !== arguments[2]) || arguments[2], s2 = !(arguments.length &gt; 3 &amp;&amp; void 0 !== arguments[3]) || arguments[3], r2 = arguments.length &gt; 4 &amp;&amp; void 0 !== arguments[4] &amp;&amp; arguments[4];
    return new Promise(function(n2) {
      var o2 = [e2.ctx];
      s2 &amp;&amp; (o2 = e2.ctx.getSyncedCharts()), e2.ctx.w.globals.isExecCalled &amp;&amp; (o2 = [e2.ctx], e2.ctx.w.globals.isExecCalled = false), o2.forEach(function(s3, l2) {
        var h2 = s3.w;
        if (h2.globals.shouldAnimate = a2, i2 || (h2.globals.resized = true, h2.globals.dataChanged = true, a2 &amp;&amp; s3.series.getPreviousPaths()), t3 &amp;&amp; &quot;object&quot; === b(t3) &amp;&amp; (s3.config = new Wi(t3), t3 = Pi.extendArrayProps(s3.config, t3, h2), s3.w.globals.chartID !== e2.ctx.w.globals.chartID &amp;&amp; delete t3.series, h2.config = v.extend(h2.config, t3), r2 &amp;&amp; (h2.globals.lastXAxis = t3.xaxis ? v.clone(t3.xaxis) : [], h2.globals.lastYAxis = t3.yaxis ? v.clone(t3.yaxis) : [], h2.globals.initialConfig = v.extend({}, h2.config), h2.globals.initialSeries = v.clone(h2.config.series), t3.series))) {
          for (var c2 = 0; c2 &lt; h2.globals.collapsedSeriesIndices.length; c2++) {
            var d2 = h2.config.series[h2.globals.collapsedSeriesIndices[c2]];
            h2.globals.collapsedSeries[c2].data = h2.globals.axisCharts ? d2.data.slice() : d2;
          }
          for (var u2 = 0; u2 &lt; h2.globals.ancillaryCollapsedSeriesIndices.length; u2++) {
            var g2 = h2.config.series[h2.globals.ancillaryCollapsedSeriesIndices[u2]];
            h2.globals.ancillaryCollapsedSeries[u2].data = h2.globals.axisCharts ? g2.data.slice() : g2;
          }
          s3.series.emptyCollapsedSeries(h2.config.series);
        }
        return s3.update(t3).then(function() {
          l2 === o2.length - 1 &amp;&amp; n2(s3);
        });
      });
    });
  } }, { key: &quot;_updateSeries&quot;, value: function(t3, e2) {
    var i2 = this, a2 = arguments.length &gt; 2 &amp;&amp; void 0 !== arguments[2] &amp;&amp; arguments[2];
    return new Promise(function(s2) {
      var r2, n2 = i2.w;
      return n2.globals.shouldAnimate = e2, n2.globals.dataChanged = true, e2 &amp;&amp; i2.ctx.series.getPreviousPaths(), n2.globals.axisCharts ? (0 === (r2 = t3.map(function(t4, e3) {
        return i2._extendSeries(t4, e3);
      })).length &amp;&amp; (r2 = [{ data: [] }]), n2.config.series = r2) : n2.config.series = t3.slice(), a2 &amp;&amp; (n2.globals.initialConfig.series = v.clone(n2.config.series), n2.globals.initialSeries = v.clone(n2.config.series)), i2.ctx.update().then(function() {
        s2(i2.ctx);
      });
    });
  } }, { key: &quot;_extendSeries&quot;, value: function(t3, e2) {
    var i2 = this.w, a2 = i2.config.series[e2];
    return u(u({}, i2.config.series[e2]), {}, { name: t3.name ? t3.name : null == a2 ? void 0 : a2.name, color: t3.color ? t3.color : null == a2 ? void 0 : a2.color, type: t3.type ? t3.type : null == a2 ? void 0 : a2.type, group: t3.group ? t3.group : null == a2 ? void 0 : a2.group, hidden: void 0 !== t3.hidden ? t3.hidden : null == a2 ? void 0 : a2.hidden, data: t3.data ? t3.data : null == a2 ? void 0 : a2.data, zIndex: void 0 !== t3.zIndex ? t3.zIndex : e2 });
  } }, { key: &quot;toggleDataPointSelection&quot;, value: function(t3, e2) {
    var i2 = this.w, a2 = null, s2 = &quot;.apexcharts-series[data\\:realIndex=&#x27;&quot;.concat(t3, &quot;&#x27;]&quot;);
    return i2.globals.axisCharts ? a2 = i2.globals.dom.Paper.findOne(&quot;&quot;.concat(s2, &quot; path[j=&#x27;&quot;).concat(e2, &quot;&#x27;], &quot;).concat(s2, &quot; circle[j=&#x27;&quot;).concat(e2, &quot;&#x27;], &quot;).concat(s2, &quot; rect[j=&#x27;&quot;).concat(e2, &quot;&#x27;]&quot;)) : void 0 === e2 &amp;&amp; (a2 = i2.globals.dom.Paper.findOne(&quot;&quot;.concat(s2, &quot; path[j=&#x27;&quot;).concat(t3, &quot;&#x27;]&quot;)), &quot;pie&quot; !== i2.config.chart.type &amp;&amp; &quot;polarArea&quot; !== i2.config.chart.type &amp;&amp; &quot;donut&quot; !== i2.config.chart.type || this.ctx.pie.pieClicked(t3)), a2 ? (new Mi(this.ctx).pathMouseDown(a2, null), a2.node ? a2.node : null) : (console.warn(&quot;toggleDataPointSelection: Element not found&quot;), null);
  } }, { key: &quot;forceXAxisUpdate&quot;, value: function(t3) {
    var e2 = this.w;
    if ([&quot;min&quot;, &quot;max&quot;].forEach(function(i3) {
      void 0 !== t3.xaxis[i3] &amp;&amp; (e2.config.xaxis[i3] = t3.xaxis[i3], e2.globals.lastXAxis[i3] = t3.xaxis[i3]);
    }), t3.xaxis.categories &amp;&amp; t3.xaxis.categories.length &amp;&amp; (e2.config.xaxis.categories = t3.xaxis.categories), e2.config.xaxis.convertedCatToNumeric) {
      var i2 = new Ni(t3);
      t3 = i2.convertCatToNumericXaxis(t3, this.ctx);
    }
    return t3;
  } }, { key: &quot;forceYAxisUpdate&quot;, value: function(t3) {
    return t3.chart &amp;&amp; t3.chart.stacked &amp;&amp; &quot;100%&quot; === t3.chart.stackType &amp;&amp; (Array.isArray(t3.yaxis) ? t3.yaxis.forEach(function(e2, i2) {
      t3.yaxis[i2].min = 0, t3.yaxis[i2].max = 100;
    }) : (t3.yaxis.min = 0, t3.yaxis.max = 100)), t3;
  } }, { key: &quot;revertDefaultAxisMinMax&quot;, value: function(t3) {
    var e2 = this, i2 = this.w, a2 = i2.globals.lastXAxis, s2 = i2.globals.lastYAxis;
    t3 &amp;&amp; t3.xaxis &amp;&amp; (a2 = t3.xaxis), t3 &amp;&amp; t3.yaxis &amp;&amp; (s2 = t3.yaxis), i2.config.xaxis.min = a2.min, i2.config.xaxis.max = a2.max;
    var r2 = function(t4) {
      void 0 !== s2[t4] &amp;&amp; (i2.config.yaxis[t4].min = s2[t4].min, i2.config.yaxis[t4].max = s2[t4].max);
    };
    i2.config.yaxis.map(function(t4, a3) {
      i2.globals.zoomed || void 0 !== s2[a3] ? r2(a3) : void 0 !== e2.ctx.opts.yaxis[a3] &amp;&amp; (t4.min = e2.ctx.opts.yaxis[a3].min, t4.max = e2.ctx.opts.yaxis[a3].max);
    });
  } }]), t2;
}();
!function() {
  function t2() {
    for (var t3 = arguments.length &gt; 0 &amp;&amp; arguments[0] !== h2 ? arguments[0] : [], s3 = arguments.length &gt; 1 ? arguments[1] : h2, r2 = arguments.length &gt; 2 ? arguments[2] : h2, n2 = arguments.length &gt; 3 ? arguments[3] : h2, o2 = arguments.length &gt; 4 ? arguments[4] : h2, l2 = arguments.length &gt; 5 ? arguments[5] : h2, h2 = arguments.length &gt; 6 ? arguments[6] : h2, c2 = t3.slice(s3, r2 || h2), d2 = n2.slice(o2, l2 || h2), u2 = 0, g2 = { pos: [0, 0], start: [0, 0] }, p2 = { pos: [0, 0], start: [0, 0] }; ; ) {
      if (c2[u2] = e2.call(g2, c2[u2]), d2[u2] = e2.call(p2, d2[u2]), c2[u2][0] != d2[u2][0] || &quot;M&quot; == c2[u2][0] || &quot;A&quot; == c2[u2][0] &amp;&amp; (c2[u2][4] != d2[u2][4] || c2[u2][5] != d2[u2][5]) ? (Array.prototype.splice.apply(c2, [u2, 1].concat(a2.call(g2, c2[u2]))), Array.prototype.splice.apply(d2, [u2, 1].concat(a2.call(p2, d2[u2])))) : (c2[u2] = i2.call(g2, c2[u2]), d2[u2] = i2.call(p2, d2[u2])), ++u2 == c2.length &amp;&amp; u2 == d2.length) break;
      u2 == c2.length &amp;&amp; c2.push([&quot;C&quot;, g2.pos[0], g2.pos[1], g2.pos[0], g2.pos[1], g2.pos[0], g2.pos[1]]), u2 == d2.length &amp;&amp; d2.push([&quot;C&quot;, p2.pos[0], p2.pos[1], p2.pos[0], p2.pos[1], p2.pos[0], p2.pos[1]]);
    }
    return { start: c2, dest: d2 };
  }
  function e2(t3) {
    switch (t3[0]) {
      case &quot;z&quot;:
      case &quot;Z&quot;:
        t3[0] = &quot;L&quot;, t3[1] = this.start[0], t3[2] = this.start[1];
        break;
      case &quot;H&quot;:
        t3[0] = &quot;L&quot;, t3[2] = this.pos[1];
        break;
      case &quot;V&quot;:
        t3[0] = &quot;L&quot;, t3[2] = t3[1], t3[1] = this.pos[0];
        break;
      case &quot;T&quot;:
        t3[0] = &quot;Q&quot;, t3[3] = t3[1], t3[4] = t3[2], t3[1] = this.reflection[1], t3[2] = this.reflection[0];
        break;
      case &quot;S&quot;:
        t3[0] = &quot;C&quot;, t3[6] = t3[4], t3[5] = t3[3], t3[4] = t3[2], t3[3] = t3[1], t3[2] = this.reflection[1], t3[1] = this.reflection[0];
    }
    return t3;
  }
  function i2(t3) {
    var e3 = t3.length;
    return this.pos = [t3[e3 - 2], t3[e3 - 1]], -1 != &quot;SCQT&quot;.indexOf(t3[0]) &amp;&amp; (this.reflection = [2 * this.pos[0] - t3[e3 - 4], 2 * this.pos[1] - t3[e3 - 3]]), t3;
  }
  function a2(t3) {
    var e3 = [t3];
    switch (t3[0]) {
      case &quot;M&quot;:
        return this.pos = this.start = [t3[1], t3[2]], e3;
      case &quot;L&quot;:
        t3[5] = t3[3] = t3[1], t3[6] = t3[4] = t3[2], t3[1] = this.pos[0], t3[2] = this.pos[1];
        break;
      case &quot;Q&quot;:
        t3[6] = t3[4], t3[5] = t3[3], t3[4] = 1 * t3[4] / 3 + 2 * t3[2] / 3, t3[3] = 1 * t3[3] / 3 + 2 * t3[1] / 3, t3[2] = 1 * this.pos[1] / 3 + 2 * t3[2] / 3, t3[1] = 1 * this.pos[0] / 3 + 2 * t3[1] / 3;
        break;
      case &quot;A&quot;:
        e3 = function(t4, e4) {
          var i3, a3, s3, r2, n2, o2, l2, h2, c2, d2, u2, g2, p2, f2, x2, b2, m2, v2, y2, w2, k2, A2, C2, S2, L2, M2, P2 = Math.abs(e4[1]), I2 = Math.abs(e4[2]), T2 = e4[3] % 360, z2 = e4[4], X2 = e4[5], R2 = e4[6], E2 = e4[7], Y2 = new bt(t4), H2 = new bt(R2, E2), O2 = [];
          if (0 === P2 || 0 === I2 || Y2.x === H2.x &amp;&amp; Y2.y === H2.y) return [[&quot;C&quot;, Y2.x, Y2.y, H2.x, H2.y, H2.x, H2.y]];
          i3 = new bt((Y2.x - H2.x) / 2, (Y2.y - H2.y) / 2).transform(new vt().rotate(T2)), a3 = i3.x * i3.x / (P2 * P2) + i3.y * i3.y / (I2 * I2), a3 &gt; 1 &amp;&amp; (P2 *= a3 = Math.sqrt(a3), I2 *= a3);
          s3 = new vt().rotate(T2).scale(1 / P2, 1 / I2).rotate(-T2), Y2 = Y2.transform(s3), H2 = H2.transform(s3), r2 = [H2.x - Y2.x, H2.y - Y2.y], o2 = r2[0] * r2[0] + r2[1] * r2[1], n2 = Math.sqrt(o2), r2[0] /= n2, r2[1] /= n2, l2 = o2 &lt; 4 ? Math.sqrt(1 - o2 / 4) : 0, z2 === X2 &amp;&amp; (l2 *= -1);
          h2 = new bt((H2.x + Y2.x) / 2 + l2 * -r2[1], (H2.y + Y2.y) / 2 + l2 * r2[0]), c2 = new bt(Y2.x - h2.x, Y2.y - h2.y), d2 = new bt(H2.x - h2.x, H2.y - h2.y), u2 = Math.acos(c2.x / Math.sqrt(c2.x * c2.x + c2.y * c2.y)), c2.y &lt; 0 &amp;&amp; (u2 *= -1);
          g2 = Math.acos(d2.x / Math.sqrt(d2.x * d2.x + d2.y * d2.y)), d2.y &lt; 0 &amp;&amp; (g2 *= -1);
          X2 &amp;&amp; u2 &gt; g2 &amp;&amp; (g2 += 2 * Math.PI);
          !X2 &amp;&amp; u2 &lt; g2 &amp;&amp; (g2 -= 2 * Math.PI);
          for (f2 = Math.ceil(2 * Math.abs(u2 - g2) / Math.PI), b2 = [], m2 = u2, p2 = (g2 - u2) / f2, x2 = 4 * Math.tan(p2 / 4) / 3, k2 = 0; k2 &lt;= f2; k2++) y2 = Math.cos(m2), v2 = Math.sin(m2), w2 = new bt(h2.x + y2, h2.y + v2), b2[k2] = [new bt(w2.x + x2 * v2, w2.y - x2 * y2), w2, new bt(w2.x - x2 * v2, w2.y + x2 * y2)], m2 += p2;
          for (b2[0][0] = b2[0][1].clone(), b2[b2.length - 1][2] = b2[b2.length - 1][1].clone(), s3 = new vt().rotate(T2).scale(P2, I2).rotate(-T2), k2 = 0, A2 = b2.length; k2 &lt; A2; k2++) b2[k2][0] = b2[k2][0].transform(s3), b2[k2][1] = b2[k2][1].transform(s3), b2[k2][2] = b2[k2][2].transform(s3);
          for (k2 = 1, A2 = b2.length; k2 &lt; A2; k2++) C2 = (w2 = b2[k2 - 1][2]).x, S2 = w2.y, L2 = (w2 = b2[k2][0]).x, M2 = w2.y, R2 = (w2 = b2[k2][1]).x, E2 = w2.y, O2.push([&quot;C&quot;, C2, S2, L2, M2, R2, E2]);
          return O2;
        }(this.pos, t3), t3 = e3[0];
    }
    return t3[0] = &quot;C&quot;, this.pos = [t3[5], t3[6]], this.reflection = [2 * t3[5] - t3[3], 2 * t3[6] - t3[4]], e3;
  }
  function s2() {
    var t3 = arguments.length &gt; 0 &amp;&amp; void 0 !== arguments[0] ? arguments[0] : [], e3 = arguments.length &gt; 1 ? arguments[1] : void 0;
    if (false === e3) return false;
    for (var i3 = e3, a3 = t3.length; i3 &lt; a3; ++i3) if (&quot;M&quot; == t3[i3][0]) return i3;
    return false;
  }
  Q(Ee, { morph: function(e3, i3, a3, r2, n2) {
    for (var o2 = this.parse(e3), l2 = this.parse(i3), h2 = 0, c2 = 0, d2 = false, u2 = false; false !== h2 || false !== c2; ) {
      var g2;
      d2 = s2(o2, false !== h2 &amp;&amp; h2 + 1), u2 = s2(l2, false !== c2 &amp;&amp; c2 + 1), false === h2 &amp;&amp; (h2 = 0 == (g2 = new Ee(p2.start).bbox()).height || 0 == g2.width ? o2.push(o2[0]) - 1 : o2.push([&quot;M&quot;, g2.x + g2.width / 2, g2.y + g2.height / 2]) - 1), false === c2 &amp;&amp; (c2 = 0 == (g2 = new Ee(p2.dest).bbox()).height || 0 == g2.width ? l2.push(l2[0]) - 1 : l2.push([&quot;M&quot;, g2.x + g2.width / 2, g2.y + g2.height / 2]) - 1);
      var p2 = t2(o2, h2, d2, l2, c2, u2);
      o2 = o2.slice(0, h2).concat(p2.start, false === d2 ? [] : o2.slice(d2)), l2 = l2.slice(0, c2).concat(p2.dest, false === u2 ? [] : l2.slice(u2)), h2 = false !== d2 &amp;&amp; h2 + p2.start.length, c2 = false !== u2 &amp;&amp; c2 + p2.dest.length;
    }
    this._array = o2, this.destination = new Ee(), this.destination._array = l2;
    var f2 = this.fromArray(o2.map(function(t3, e4) {
      var i4 = l2[e4].map(function(i5, s3) {
        return 0 === s3 ? i5 : r2.step(t3[s3], l2[e4][s3], a3, n2[e4], n2);
      });
      return i4;
    }));
    return f2;
  } });
}();
var $a = (t2) =&gt; (t2.changedTouches &amp;&amp; (t2 = t2.changedTouches[0]), { x: t2.clientX, y: t2.clientY });
var Ja = class {
  constructor(t2) {
    t2.remember(&quot;_draggable&quot;, this), this.el = t2, this.drag = this.drag.bind(this), this.startDrag = this.startDrag.bind(this), this.endDrag = this.endDrag.bind(this);
  }
  init(t2) {
    t2 ? (this.el.on(&quot;mousedown.drag&quot;, this.startDrag), this.el.on(&quot;touchstart.drag&quot;, this.startDrag, { passive: false })) : (this.el.off(&quot;mousedown.drag&quot;), this.el.off(&quot;touchstart.drag&quot;));
  }
  startDrag(t2) {
    const e2 = !t2.type.indexOf(&quot;mouse&quot;);
    if (e2 &amp;&amp; 1 !== t2.which &amp;&amp; 0 !== t2.buttons) return;
    if (this.el.dispatch(&quot;beforedrag&quot;, { event: t2, handler: this }).defaultPrevented) return;
    t2.preventDefault(), t2.stopPropagation(), this.init(false), this.box = this.el.bbox(), this.lastClick = this.el.point($a(t2));
    const i2 = (e2 ? &quot;mouseup&quot; : &quot;touchend&quot;) + &quot;.drag&quot;;
    zt(window, (e2 ? &quot;mousemove&quot; : &quot;touchmove&quot;) + &quot;.drag&quot;, this.drag, this, { passive: false }), zt(window, i2, this.endDrag, this, { passive: false }), this.el.fire(&quot;dragstart&quot;, { event: t2, handler: this, box: this.box });
  }
  drag(t2) {
    const { box: e2, lastClick: i2 } = this, a2 = this.el.point($a(t2)), s2 = a2.x - i2.x, r2 = a2.y - i2.y;
    if (!s2 &amp;&amp; !r2) return e2;
    const n2 = e2.x + s2, o2 = e2.y + r2;
    this.box = new kt(n2, o2, e2.w, e2.h), this.lastClick = a2, this.el.dispatch(&quot;dragmove&quot;, { event: t2, handler: this, box: this.box }).defaultPrevented || this.move(n2, o2);
  }
  move(t2, e2) {
    &quot;svg&quot; === this.el.type ? gi.prototype.move.call(this.el, t2, e2) : this.el.move(t2, e2);
  }
  endDrag(t2) {
    this.drag(t2), this.el.fire(&quot;dragend&quot;, { event: t2, handler: this, box: this.box }), Xt(window, &quot;mousemove.drag&quot;), Xt(window, &quot;touchmove.drag&quot;), Xt(window, &quot;mouseup.drag&quot;), Xt(window, &quot;touchend.drag&quot;), this.init(true);
  }
};
function Qa(t2, e2, i2, a2 = null) {
  return function(s2) {
    s2.preventDefault(), s2.stopPropagation();
    var r2 = s2.pageX || s2.touches[0].pageX, n2 = s2.pageY || s2.touches[0].pageY;
    e2.fire(t2, { x: r2, y: n2, event: s2, index: a2, points: i2 });
  };
}
function Ka([t2, e2], { a: i2, b: a2, c: s2, d: r2, e: n2, f: o2 }) {
  return [t2 * i2 + e2 * s2 + n2, t2 * a2 + e2 * r2 + o2];
}
Q(Gt, { draggable(t2 = true) {
  return (this.remember(&quot;_draggable&quot;) || new Ja(this)).init(t2), this;
} });
var ts = class {
  constructor(t2) {
    this.el = t2, t2.remember(&quot;_selectHandler&quot;, this), this.selection = new gi(), this.order = [&quot;lt&quot;, &quot;t&quot;, &quot;rt&quot;, &quot;r&quot;, &quot;rb&quot;, &quot;b&quot;, &quot;lb&quot;, &quot;l&quot;, &quot;rot&quot;], this.mutationHandler = this.mutationHandler.bind(this);
    const e2 = F();
    this.observer = new e2.MutationObserver(this.mutationHandler);
  }
  init(t2) {
    this.createHandle = t2.createHandle || this.createHandleFn, this.createRot = t2.createRot || this.createRotFn, this.updateHandle = t2.updateHandle || this.updateHandleFn, this.updateRot = t2.updateRot || this.updateRotFn, this.el.root().put(this.selection), this.updatePoints(), this.createSelection(), this.createResizeHandles(), this.updateResizeHandles(), this.createRotationHandle(), this.updateRotationHandle(), this.observer.observe(this.el.node, { attributes: true });
  }
  active(t2, e2) {
    if (!t2) return this.selection.clear().remove(), void this.observer.disconnect();
    this.init(e2);
  }
  createSelection() {
    this.selection.polygon(this.handlePoints).addClass(&quot;svg_select_shape&quot;);
  }
  updateSelection() {
    this.selection.get(0).plot(this.handlePoints);
  }
  createResizeHandles() {
    this.handlePoints.forEach((t2, e2, i2) =&gt; {
      const a2 = this.order[e2];
      this.createHandle.call(this, this.selection, t2, e2, i2, a2), this.selection.get(e2 + 1).addClass(&quot;svg_select_handle svg_select_handle_&quot; + a2).on(&quot;mousedown.selection touchstart.selection&quot;, Qa(a2, this.el, this.handlePoints, e2));
    });
  }
  createHandleFn(t2) {
    t2.polyline();
  }
  updateHandleFn(t2, e2, i2, a2) {
    const s2 = a2.at(i2 - 1), r2 = a2[(i2 + 1) % a2.length], n2 = e2, o2 = [n2[0] - s2[0], n2[1] - s2[1]], l2 = [n2[0] - r2[0], n2[1] - r2[1]], h2 = Math.sqrt(o2[0] * o2[0] + o2[1] * o2[1]), c2 = Math.sqrt(l2[0] * l2[0] + l2[1] * l2[1]), d2 = [o2[0] / h2, o2[1] / h2], u2 = [l2[0] / c2, l2[1] / c2], g2 = [n2[0] - 10 * d2[0], n2[1] - 10 * d2[1]], p2 = [n2[0] - 10 * u2[0], n2[1] - 10 * u2[1]];
    t2.plot([g2, n2, p2]);
  }
  updateResizeHandles() {
    this.handlePoints.forEach((t2, e2, i2) =&gt; {
      const a2 = this.order[e2];
      this.updateHandle.call(this, this.selection.get(e2 + 1), t2, e2, i2, a2);
    });
  }
  createRotFn(t2) {
    t2.line(), t2.circle(5);
  }
  getPoint(t2) {
    return this.handlePoints[this.order.indexOf(t2)];
  }
  getPointHandle(t2) {
    return this.selection.get(this.order.indexOf(t2) + 1);
  }
  updateRotFn(t2, e2) {
    const i2 = this.getPoint(&quot;t&quot;);
    t2.get(0).plot(i2[0], i2[1], e2[0], e2[1]), t2.get(1).center(e2[0], e2[1]);
  }
  createRotationHandle() {
    const t2 = this.selection.group().addClass(&quot;svg_select_handle_rot&quot;).on(&quot;mousedown.selection touchstart.selection&quot;, Qa(&quot;rot&quot;, this.el, this.handlePoints));
    this.createRot.call(this, t2);
  }
  updateRotationHandle() {
    const t2 = this.selection.findOne(&quot;g.svg_select_handle_rot&quot;);
    this.updateRot(t2, this.rotationPoint, this.handlePoints);
  }
  updatePoints() {
    const t2 = this.el.bbox(), e2 = this.el.parent().screenCTM().inverseO().multiplyO(this.el.screenCTM());
    this.handlePoints = this.getHandlePoints(t2).map((t3) =&gt; Ka(t3, e2)), this.rotationPoint = Ka(this.getRotationPoint(t2), e2);
  }
  getHandlePoints({ x: t2, x2: e2, y: i2, y2: a2, cx: s2, cy: r2 } = this.el.bbox()) {
    return [[t2, i2], [s2, i2], [e2, i2], [e2, r2], [e2, a2], [s2, a2], [t2, a2], [t2, r2]];
  }
  getRotationPoint({ y: t2, cx: e2 } = this.el.bbox()) {
    return [e2, t2 - 20];
  }
  mutationHandler() {
    this.updatePoints(), this.updateSelection(), this.updateResizeHandles(), this.updateRotationHandle();
  }
};
var es = (t2) =&gt; function(e2 = true, i2 = {}) {
  &quot;object&quot; == typeof e2 &amp;&amp; (i2 = e2, e2 = true);
  let a2 = this.remember(&quot;_&quot; + t2.name);
  return a2 || (e2.prototype instanceof ts ? (a2 = new e2(this), e2 = true) : a2 = new t2(this), this.remember(&quot;_&quot; + t2.name, a2)), a2.active(e2, i2), this;
};
function is(t2, e2, i2, a2 = null) {
  return function(s2) {
    s2.preventDefault(), s2.stopPropagation();
    var r2 = s2.pageX || s2.touches[0].pageX, n2 = s2.pageY || s2.touches[0].pageY;
    e2.fire(t2, { x: r2, y: n2, event: s2, index: a2, points: i2 });
  };
}
function as([t2, e2], { a: i2, b: a2, c: s2, d: r2, e: n2, f: o2 }) {
  return [t2 * i2 + e2 * s2 + n2, t2 * a2 + e2 * r2 + o2];
}
Q(Gt, { select: es(ts) }), Q([Ge, je, xe], { pointSelect: es(class {
  constructor(t2) {
    this.el = t2, t2.remember(&quot;_pointSelectHandler&quot;, this), this.selection = new gi(), this.order = [&quot;lt&quot;, &quot;t&quot;, &quot;rt&quot;, &quot;r&quot;, &quot;rb&quot;, &quot;b&quot;, &quot;lb&quot;, &quot;l&quot;, &quot;rot&quot;], this.mutationHandler = this.mutationHandler.bind(this);
    const e2 = F();
    this.observer = new e2.MutationObserver(this.mutationHandler);
  }
  init(t2) {
    this.createHandle = t2.createHandle || this.createHandleFn, this.updateHandle = t2.updateHandle || this.updateHandleFn, this.el.root().put(this.selection), this.updatePoints(), this.createSelection(), this.createPointHandles(), this.updatePointHandles(), this.observer.observe(this.el.node, { attributes: true });
  }
  active(t2, e2) {
    if (!t2) return this.selection.clear().remove(), void this.observer.disconnect();
    this.init(e2);
  }
  createSelection() {
    this.selection.polygon(this.points).addClass(&quot;svg_select_shape_pointSelect&quot;);
  }
  updateSelection() {
    this.selection.get(0).plot(this.points);
  }
  createPointHandles() {
    this.points.forEach((t2, e2, i2) =&gt; {
      this.createHandle.call(this, this.selection, t2, e2, i2), this.selection.get(e2 + 1).addClass(&quot;svg_select_handle_point&quot;).on(&quot;mousedown.selection touchstart.selection&quot;, Qa(&quot;point&quot;, this.el, this.points, e2));
    });
  }
  createHandleFn(t2) {
    t2.circle(5);
  }
  updateHandleFn(t2, e2) {
    t2.center(e2[0], e2[1]);
  }
  updatePointHandles() {
    this.points.forEach((t2, e2, i2) =&gt; {
      this.updateHandle.call(this, this.selection.get(e2 + 1), t2, e2, i2);
    });
  }
  updatePoints() {
    const t2 = this.el.parent().screenCTM().inverseO().multiplyO(this.el.screenCTM());
    this.points = this.el.array().map((e2) =&gt; Ka(e2, t2));
  }
  mutationHandler() {
    this.updatePoints(), this.updateSelection(), this.updatePointHandles();
  }
}) });
var ss = class {
  constructor(t2) {
    this.el = t2, t2.remember(&quot;_selectHandler&quot;, this), this.selection = new gi(), this.order = [&quot;lt&quot;, &quot;t&quot;, &quot;rt&quot;, &quot;r&quot;, &quot;rb&quot;, &quot;b&quot;, &quot;lb&quot;, &quot;l&quot;, &quot;rot&quot;], this.mutationHandler = this.mutationHandler.bind(this);
    const e2 = F();
    this.observer = new e2.MutationObserver(this.mutationHandler);
  }
  init(t2) {
    this.createHandle = t2.createHandle || this.createHandleFn, this.createRot = t2.createRot || this.createRotFn, this.updateHandle = t2.updateHandle || this.updateHandleFn, this.updateRot = t2.updateRot || this.updateRotFn, this.el.root().put(this.selection), this.updatePoints(), this.createSelection(), this.createResizeHandles(), this.updateResizeHandles(), this.createRotationHandle(), this.updateRotationHandle(), this.observer.observe(this.el.node, { attributes: true });
  }
  active(t2, e2) {
    if (!t2) return this.selection.clear().remove(), void this.observer.disconnect();
    this.init(e2);
  }
  createSelection() {
    this.selection.polygon(this.handlePoints).addClass(&quot;svg_select_shape&quot;);
  }
  updateSelection() {
    this.selection.get(0).plot(this.handlePoints);
  }
  createResizeHandles() {
    this.handlePoints.forEach((t2, e2, i2) =&gt; {
      const a2 = this.order[e2];
      this.createHandle.call(this, this.selection, t2, e2, i2, a2), this.selection.get(e2 + 1).addClass(&quot;svg_select_handle svg_select_handle_&quot; + a2).on(&quot;mousedown.selection touchstart.selection&quot;, is(a2, this.el, this.handlePoints, e2));
    });
  }
  createHandleFn(t2) {
    t2.polyline();
  }
  updateHandleFn(t2, e2, i2, a2) {
    const s2 = a2.at(i2 - 1), r2 = a2[(i2 + 1) % a2.length], n2 = e2, o2 = [n2[0] - s2[0], n2[1] - s2[1]], l2 = [n2[0] - r2[0], n2[1] - r2[1]], h2 = Math.sqrt(o2[0] * o2[0] + o2[1] * o2[1]), c2 = Math.sqrt(l2[0] * l2[0] + l2[1] * l2[1]), d2 = [o2[0] / h2, o2[1] / h2], u2 = [l2[0] / c2, l2[1] / c2], g2 = [n2[0] - 10 * d2[0], n2[1] - 10 * d2[1]], p2 = [n2[0] - 10 * u2[0], n2[1] - 10 * u2[1]];
    t2.plot([g2, n2, p2]);
  }
  updateResizeHandles() {
    this.handlePoints.forEach((t2, e2, i2) =&gt; {
      const a2 = this.order[e2];
      this.updateHandle.call(this, this.selection.get(e2 + 1), t2, e2, i2, a2);
    });
  }
  createRotFn(t2) {
    t2.line(), t2.circle(5);
  }
  getPoint(t2) {
    return this.handlePoints[this.order.indexOf(t2)];
  }
  getPointHandle(t2) {
    return this.selection.get(this.order.indexOf(t2) + 1);
  }
  updateRotFn(t2, e2) {
    const i2 = this.getPoint(&quot;t&quot;);
    t2.get(0).plot(i2[0], i2[1], e2[0], e2[1]), t2.get(1).center(e2[0], e2[1]);
  }
  createRotationHandle() {
    const t2 = this.selection.group().addClass(&quot;svg_select_handle_rot&quot;).on(&quot;mousedown.selection touchstart.selection&quot;, is(&quot;rot&quot;, this.el, this.handlePoints));
    this.createRot.call(this, t2);
  }
  updateRotationHandle() {
    const t2 = this.selection.findOne(&quot;g.svg_select_handle_rot&quot;);
    this.updateRot(t2, this.rotationPoint, this.handlePoints);
  }
  updatePoints() {
    const t2 = this.el.bbox(), e2 = this.el.parent().screenCTM().inverseO().multiplyO(this.el.screenCTM());
    this.handlePoints = this.getHandlePoints(t2).map((t3) =&gt; as(t3, e2)), this.rotationPoint = as(this.getRotationPoint(t2), e2);
  }
  getHandlePoints({ x: t2, x2: e2, y: i2, y2: a2, cx: s2, cy: r2 } = this.el.bbox()) {
    return [[t2, i2], [s2, i2], [e2, i2], [e2, r2], [e2, a2], [s2, a2], [t2, a2], [t2, r2]];
  }
  getRotationPoint({ y: t2, cx: e2 } = this.el.bbox()) {
    return [e2, t2 - 20];
  }
  mutationHandler() {
    this.updatePoints(), this.updateSelection(), this.updateResizeHandles(), this.updateRotationHandle();
  }
};
var rs = (t2) =&gt; function(e2 = true, i2 = {}) {
  &quot;object&quot; == typeof e2 &amp;&amp; (i2 = e2, e2 = true);
  let a2 = this.remember(&quot;_&quot; + t2.name);
  return a2 || (e2.prototype instanceof ss ? (a2 = new e2(this), e2 = true) : a2 = new t2(this), this.remember(&quot;_&quot; + t2.name, a2)), a2.active(e2, i2), this;
};
Q(Gt, { select: rs(ss) }), Q([Ge, je, xe], { pointSelect: rs(class {
  constructor(t2) {
    this.el = t2, t2.remember(&quot;_pointSelectHandler&quot;, this), this.selection = new gi(), this.order = [&quot;lt&quot;, &quot;t&quot;, &quot;rt&quot;, &quot;r&quot;, &quot;rb&quot;, &quot;b&quot;, &quot;lb&quot;, &quot;l&quot;, &quot;rot&quot;], this.mutationHandler = this.mutationHandler.bind(this);
    const e2 = F();
    this.observer = new e2.MutationObserver(this.mutationHandler);
  }
  init(t2) {
    this.createHandle = t2.createHandle || this.createHandleFn, this.updateHandle = t2.updateHandle || this.updateHandleFn, this.el.root().put(this.selection), this.updatePoints(), this.createSelection(), this.createPointHandles(), this.updatePointHandles(), this.observer.observe(this.el.node, { attributes: true });
  }
  active(t2, e2) {
    if (!t2) return this.selection.clear().remove(), void this.observer.disconnect();
    this.init(e2);
  }
  createSelection() {
    this.selection.polygon(this.points).addClass(&quot;svg_select_shape_pointSelect&quot;);
  }
  updateSelection() {
    this.selection.get(0).plot(this.points);
  }
  createPointHandles() {
    this.points.forEach((t2, e2, i2) =&gt; {
      this.createHandle.call(this, this.selection, t2, e2, i2), this.selection.get(e2 + 1).addClass(&quot;svg_select_handle_point&quot;).on(&quot;mousedown.selection touchstart.selection&quot;, is(&quot;point&quot;, this.el, this.points, e2));
    });
  }
  createHandleFn(t2) {
    t2.circle(5);
  }
  updateHandleFn(t2, e2) {
    t2.center(e2[0], e2[1]);
  }
  updatePointHandles() {
    this.points.forEach((t2, e2, i2) =&gt; {
      this.updateHandle.call(this, this.selection.get(e2 + 1), t2, e2, i2);
    });
  }
  updatePoints() {
    const t2 = this.el.parent().screenCTM().inverseO().multiplyO(this.el.screenCTM());
    this.points = this.el.array().map((e2) =&gt; as(e2, t2));
  }
  mutationHandler() {
    this.updatePoints(), this.updateSelection(), this.updatePointHandles();
  }
}) });
var ns = (t2) =&gt; (t2.changedTouches &amp;&amp; (t2 = t2.changedTouches[0]), { x: t2.clientX, y: t2.clientY });
var os = (t2) =&gt; {
  let e2 = 1 / 0, i2 = 1 / 0, a2 = -1 / 0, s2 = -1 / 0;
  for (let r2 = 0; r2 &lt; t2.length; r2++) {
    const n2 = t2[r2];
    e2 = Math.min(e2, n2[0]), i2 = Math.min(i2, n2[1]), a2 = Math.max(a2, n2[0]), s2 = Math.max(s2, n2[1]);
  }
  return new kt(e2, i2, a2 - e2, s2 - i2);
};
var ls = class {
  constructor(t2) {
    this.el = t2, t2.remember(&quot;_ResizeHandler&quot;, this), this.lastCoordinates = null, this.eventType = &quot;&quot;, this.lastEvent = null, this.handleResize = this.handleResize.bind(this), this.resize = this.resize.bind(this), this.endResize = this.endResize.bind(this), this.rotate = this.rotate.bind(this), this.movePoint = this.movePoint.bind(this);
  }
  active(t2, e2) {
    this.preserveAspectRatio = e2.preserveAspectRatio ?? false, this.aroundCenter = e2.aroundCenter ?? false, this.grid = e2.grid ?? 0, this.degree = e2.degree ?? 0, this.el.off(&quot;.resize&quot;), t2 &amp;&amp; (this.el.on([&quot;lt.resize&quot;, &quot;rt.resize&quot;, &quot;rb.resize&quot;, &quot;lb.resize&quot;, &quot;t.resize&quot;, &quot;r.resize&quot;, &quot;b.resize&quot;, &quot;l.resize&quot;, &quot;rot.resize&quot;, &quot;point.resize&quot;], this.handleResize), this.lastEvent &amp;&amp; (&quot;rot&quot; === this.eventType ? this.rotate(this.lastEvent) : &quot;point&quot; === this.eventType ? this.movePoint(this.lastEvent) : this.resize(this.lastEvent)));
  }
  handleResize(t2) {
    this.eventType = t2.type;
    const { event: e2, index: i2, points: a2 } = t2.detail, s2 = !e2.type.indexOf(&quot;mouse&quot;);
    if (s2 &amp;&amp; 1 !== (e2.which || e2.buttons)) return;
    if (this.el.dispatch(&quot;beforeresize&quot;, { event: t2, handler: this }).defaultPrevented) return;
    this.box = this.el.bbox(), this.startPoint = this.el.point(ns(e2)), this.index = i2, this.points = a2.slice();
    const r2 = (s2 ? &quot;mousemove&quot; : &quot;touchmove&quot;) + &quot;.resize&quot;, n2 = (s2 ? &quot;mouseup&quot; : &quot;touchcancel.resize touchend&quot;) + &quot;.resize&quot;;
    &quot;point&quot; === t2.type ? zt(window, r2, this.movePoint) : &quot;rot&quot; === t2.type ? zt(window, r2, this.rotate) : zt(window, r2, this.resize), zt(window, n2, this.endResize);
  }
  resize(t2) {
    this.lastEvent = t2;
    const e2 = this.snapToGrid(this.el.point(ns(t2)));
    let i2 = e2.x - this.startPoint.x, a2 = e2.y - this.startPoint.y;
    this.preserveAspectRatio &amp;&amp; this.aroundCenter &amp;&amp; (i2 *= 2, a2 *= 2);
    const s2 = this.box.x + i2, r2 = this.box.y + a2, n2 = this.box.x2 + i2, o2 = this.box.y2 + a2;
    let l2 = new kt(this.box);
    if (this.eventType.includes(&quot;l&quot;) &amp;&amp; (l2.x = Math.min(s2, this.box.x2), l2.x2 = Math.max(s2, this.box.x2)), this.eventType.includes(&quot;r&quot;) &amp;&amp; (l2.x = Math.min(n2, this.box.x), l2.x2 = Math.max(n2, this.box.x)), this.eventType.includes(&quot;t&quot;) &amp;&amp; (l2.y = Math.min(r2, this.box.y2), l2.y2 = Math.max(r2, this.box.y2)), this.eventType.includes(&quot;b&quot;) &amp;&amp; (l2.y = Math.min(o2, this.box.y), l2.y2 = Math.max(o2, this.box.y)), l2.width = l2.x2 - l2.x, l2.height = l2.y2 - l2.y, this.preserveAspectRatio) {
      const t3 = l2.width / this.box.width, e3 = l2.height / this.box.height, i3 = [&quot;lt&quot;, &quot;t&quot;, &quot;rt&quot;, &quot;r&quot;, &quot;rb&quot;, &quot;b&quot;, &quot;lb&quot;, &quot;l&quot;], a3 = (i3.indexOf(this.eventType) + 4) % i3.length, s3 = this.aroundCenter ? [this.box.cx, this.box.cy] : this.points[a3];
      let r3 = this.eventType.includes(&quot;t&quot;) || this.eventType.includes(&quot;b&quot;) ? e3 : t3;
      r3 = 2 === this.eventType.length ? Math.max(t3, e3) : r3, l2 = function(t4, e4, i4) {
        const a4 = [[t4.x, t4.y], [t4.x + t4.width, t4.y], [t4.x + t4.width, t4.y + t4.height], [t4.x, t4.y + t4.height]].map(([t5, a5]) =&gt; {
          const s4 = t5 - e4[0], r4 = (a5 - e4[1]) * i4;
          return [s4 * i4 + e4[0], r4 + e4[1]];
        });
        return os(a4);
      }(this.box, s3, r3);
    }
    this.el.dispatch(&quot;resize&quot;, { box: new kt(l2), angle: 0, eventType: this.eventType, event: t2, handler: this }).defaultPrevented || this.el.size(l2.width, l2.height).move(l2.x, l2.y);
  }
  movePoint(t2) {
    this.lastEvent = t2;
    const { x: e2, y: i2 } = this.snapToGrid(this.el.point(ns(t2))), a2 = this.el.array().slice();
    a2[this.index] = [e2, i2], this.el.dispatch(&quot;resize&quot;, { box: os(a2), angle: 0, eventType: this.eventType, event: t2, handler: this }).defaultPrevented || this.el.plot(a2);
  }
  rotate(t2) {
    this.lastEvent = t2;
    const e2 = this.startPoint, i2 = this.el.point(ns(t2)), { cx: a2, cy: s2 } = this.box, r2 = e2.x - a2, n2 = e2.y - s2, o2 = i2.x - a2, l2 = i2.y - s2, h2 = Math.sqrt(r2 * r2 + n2 * n2) * Math.sqrt(o2 * o2 + l2 * l2);
    if (0 === h2) return;
    let c2 = Math.acos((r2 * o2 + n2 * l2) / h2) / Math.PI * 180;
    if (!c2) return;
    i2.x &lt; e2.x &amp;&amp; (c2 = -c2);
    const d2 = new vt(this.el), { x: u2, y: g2 } = new bt(a2, s2).transformO(d2), { rotate: p2 } = d2.decompose(), f2 = this.snapToAngle(p2 + c2) - p2;
    this.el.dispatch(&quot;resize&quot;, { box: this.box, angle: f2, eventType: this.eventType, event: t2, handler: this }).defaultPrevented || this.el.transform(d2.rotateO(f2, u2, g2));
  }
  endResize(t2) {
    &quot;rot&quot; !== this.eventType &amp;&amp; &quot;point&quot; !== this.eventType &amp;&amp; this.resize(t2), this.lastEvent = null, this.eventType = &quot;&quot;, Xt(window, &quot;mousemove.resize touchmove.resize&quot;), Xt(window, &quot;mouseup.resize touchend.resize&quot;);
  }
  snapToGrid(t2) {
    return this.grid &amp;&amp; (t2.x = Math.round(t2.x / this.grid) * this.grid, t2.y = Math.round(t2.y / this.grid) * this.grid), t2;
  }
  snapToAngle(t2) {
    return this.degree &amp;&amp; (t2 = Math.round(t2 / this.degree) * this.degree), t2;
  }
};
Q(Gt, { resize: function(t2 = true, e2 = {}) {
  &quot;object&quot; == typeof t2 &amp;&amp; (e2 = t2, t2 = true);
  let i2 = this.remember(&quot;_ResizeHandler&quot;);
  return i2 || (t2.prototype instanceof ls ? (i2 = new t2(this), t2 = true) : i2 = new ls(this), this.remember(&quot;_resizeHandler&quot;, i2)), i2.active(t2, e2), this;
} }), void 0 === window.SVG &amp;&amp; (window.SVG = yi), void 0 === window.Apex &amp;&amp; (window.Apex = {});
var hs = function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w;
  }
  return s(t2, [{ key: &quot;initModules&quot;, value: function() {
    this.ctx.publicMethods = [&quot;updateOptions&quot;, &quot;updateSeries&quot;, &quot;appendData&quot;, &quot;appendSeries&quot;, &quot;isSeriesHidden&quot;, &quot;highlightSeries&quot;, &quot;toggleSeries&quot;, &quot;showSeries&quot;, &quot;hideSeries&quot;, &quot;setLocale&quot;, &quot;resetSeries&quot;, &quot;zoomX&quot;, &quot;toggleDataPointSelection&quot;, &quot;dataURI&quot;, &quot;exportToCSV&quot;, &quot;addXaxisAnnotation&quot;, &quot;addYaxisAnnotation&quot;, &quot;addPointAnnotation&quot;, &quot;clearAnnotations&quot;, &quot;removeAnnotation&quot;, &quot;paper&quot;, &quot;destroy&quot;], this.ctx.eventList = [&quot;click&quot;, &quot;mousedown&quot;, &quot;mousemove&quot;, &quot;mouseleave&quot;, &quot;touchstart&quot;, &quot;touchmove&quot;, &quot;touchleave&quot;, &quot;mouseup&quot;, &quot;touchend&quot;], this.ctx.animations = new y(this.ctx), this.ctx.axes = new ra(this.ctx), this.ctx.core = new qa(this.ctx.el, this.ctx), this.ctx.config = new Wi({}), this.ctx.data = new $i(this.ctx), this.ctx.grid = new Ki(this.ctx), this.ctx.graphics = new Mi(this.ctx), this.ctx.coreUtils = new Pi(this.ctx), this.ctx.crosshairs = new na(this.ctx), this.ctx.events = new aa(this.ctx), this.ctx.exports = new Ji(this.ctx), this.ctx.fill = new ji(this.ctx), this.ctx.localization = new sa(this.ctx), this.ctx.options = new Oi(), this.ctx.responsive = new oa(this.ctx), this.ctx.series = new Zi(this.ctx), this.ctx.theme = new la(this.ctx), this.ctx.formatters = new Xi(this.ctx), this.ctx.titleSubtitle = new ha(this.ctx), this.ctx.legend = new xa(this.ctx), this.ctx.toolbar = new ba(this.ctx), this.ctx.tooltip = new Sa(this.ctx), this.ctx.dimensions = new pa(this.ctx), this.ctx.updateHelpers = new Za(this.ctx), this.ctx.zoomPanSelection = new ma(this.ctx), this.ctx.w.globals.tooltip = new Sa(this.ctx);
  } }]), t2;
}();
var cs = function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w;
  }
  return s(t2, [{ key: &quot;clear&quot;, value: function(t3) {
    var e2 = t3.isUpdating;
    this.ctx.zoomPanSelection &amp;&amp; this.ctx.zoomPanSelection.destroy(), this.ctx.toolbar &amp;&amp; this.ctx.toolbar.destroy(), this.ctx.animations = null, this.ctx.axes = null, this.ctx.annotations = null, this.ctx.core = null, this.ctx.data = null, this.ctx.grid = null, this.ctx.series = null, this.ctx.responsive = null, this.ctx.theme = null, this.ctx.formatters = null, this.ctx.titleSubtitle = null, this.ctx.legend = null, this.ctx.dimensions = null, this.ctx.options = null, this.ctx.crosshairs = null, this.ctx.zoomPanSelection = null, this.ctx.updateHelpers = null, this.ctx.toolbar = null, this.ctx.localization = null, this.ctx.w.globals.tooltip = null, this.clearDomElements({ isUpdating: e2 });
  } }, { key: &quot;killSVG&quot;, value: function(t3) {
    t3.each(function() {
      this.removeClass(&quot;*&quot;), this.off();
    }, true), t3.clear();
  } }, { key: &quot;clearDomElements&quot;, value: function(t3) {
    var e2 = this, i2 = t3.isUpdating, a2 = this.w.globals.dom.Paper.node;
    a2.parentNode &amp;&amp; a2.parentNode.parentNode &amp;&amp; !i2 &amp;&amp; (a2.parentNode.parentNode.style.minHeight = &quot;unset&quot;);
    var s2 = this.w.globals.dom.baseEl;
    s2 &amp;&amp; this.ctx.eventList.forEach(function(t4) {
      s2.removeEventListener(t4, e2.ctx.events.documentEvent);
    });
    var r2 = this.w.globals.dom;
    if (null !== this.ctx.el) for (; this.ctx.el.firstChild; ) this.ctx.el.removeChild(this.ctx.el.firstChild);
    this.killSVG(r2.Paper), r2.Paper.remove(), r2.elWrap = null, r2.elGraphical = null, r2.elLegendWrap = null, r2.elLegendForeign = null, r2.baseEl = null, r2.elGridRect = null, r2.elGridRectMask = null, r2.elGridRectBarMask = null, r2.elGridRectMarkerMask = null, r2.elForecastMask = null, r2.elNonForecastMask = null, r2.elDefs = null;
  } }]), t2;
}();
var ds = /* @__PURE__ */ new WeakMap();
var us = function() {
  function t2(e2, a2) {
    i(this, t2), this.opts = a2, this.ctx = this, this.w = new Gi(a2).init(), this.el = e2, this.w.globals.cuid = v.randomId(), this.w.globals.chartID = this.w.config.chart.id ? v.escapeString(this.w.config.chart.id) : this.w.globals.cuid, new hs(this).initModules(), this.create = v.bind(this.create, this), this.windowResizeHandler = this._windowResizeHandler.bind(this), this.parentResizeHandler = this._parentResizeCallback.bind(this);
  }
  return s(t2, [{ key: &quot;render&quot;, value: function() {
    var t3 = this;
    return new Promise(function(e2, i2) {
      if (v.elementExists(t3.el)) {
        void 0 === Apex._chartInstances &amp;&amp; (Apex._chartInstances = []), t3.w.config.chart.id &amp;&amp; Apex._chartInstances.push({ id: t3.w.globals.chartID, group: t3.w.config.chart.group, chart: t3 }), t3.setLocale(t3.w.config.chart.defaultLocale);
        var a2 = t3.w.config.chart.events.beforeMount;
        &quot;function&quot; == typeof a2 &amp;&amp; a2(t3, t3.w), t3.events.fireEvent(&quot;beforeMount&quot;, [t3, t3.w]), window.addEventListener(&quot;resize&quot;, t3.windowResizeHandler), function(t4, e3) {
          var i3 = false;
          if (t4.nodeType !== Node.DOCUMENT_FRAGMENT_NODE) {
            var a3 = t4.getBoundingClientRect();
            &quot;none&quot; !== t4.style.display &amp;&amp; 0 !== a3.width || (i3 = true);
          }
          var s3 = new ResizeObserver(function(a4) {
            i3 &amp;&amp; e3.call(t4, a4), i3 = true;
          });
          t4.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? Array.from(t4.children).forEach(function(t5) {
            return s3.observe(t5);
          }) : s3.observe(t4), ds.set(e3, s3);
        }(t3.el.parentNode, t3.parentResizeHandler);
        var s2 = t3.el.getRootNode &amp;&amp; t3.el.getRootNode(), r2 = v.is(&quot;ShadowRoot&quot;, s2), n2 = t3.el.ownerDocument, o2 = r2 ? s2.getElementById(&quot;apexcharts-css&quot;) : n2.getElementById(&quot;apexcharts-css&quot;);
        if (!o2) {
          var l2;
          (o2 = document.createElement(&quot;style&quot;)).id = &quot;apexcharts-css&quot;, o2.textContent = &#x27;@keyframes opaque {\n  0% {\n    opacity: 0\n  }\n\n  to {\n    opacity: 1\n  }\n}\n\n@keyframes resizeanim {\n\n  0%,\n  to {\n    opacity: 0\n  }\n}\n\n.apexcharts-canvas {\n  position: relative;\n  direction: ltr !important;\n  user-select: none\n}\n\n.apexcharts-canvas ::-webkit-scrollbar {\n  -webkit-appearance: none;\n  width: 6px\n}\n\n.apexcharts-canvas ::-webkit-scrollbar-thumb {\n  border-radius: 4px;\n  background-color: rgba(0, 0, 0, .5);\n  box-shadow: 0 0 1px rgba(255, 255, 255, .5);\n  -webkit-box-shadow: 0 0 1px rgba(255, 255, 255, .5)\n}\n\n.apexcharts-inner {\n  position: relative\n}\n\n.apexcharts-text tspan {\n  font-family: inherit\n}\n\nrect.legend-mouseover-inactive,\n.legend-mouseover-inactive rect,\n.legend-mouseover-inactive path,\n.legend-mouseover-inactive circle,\n.legend-mouseover-inactive line,\n.legend-mouseover-inactive text.apexcharts-yaxis-title-text,\n.legend-mouseover-inactive text.apexcharts-yaxis-label {\n  transition: .15s ease all;\n  opacity: .2\n}\n\n.apexcharts-legend-text {\n  padding-left: 15px;\n  margin-left: -15px;\n}\n\n.apexcharts-series-collapsed {\n  opacity: 0\n}\n\n.apexcharts-tooltip {\n  border-radius: 5px;\n  box-shadow: 2px 2px 6px -4px #999;\n  cursor: default;\n  font-size: 14px;\n  left: 62px;\n  opacity: 0;\n  pointer-events: none;\n  position: absolute;\n  top: 20px;\n  display: flex;\n  flex-direction: column;\n  overflow: hidden;\n  white-space: nowrap;\n  z-index: 12;\n  transition: .15s ease all\n}\n\n.apexcharts-tooltip.apexcharts-active {\n  opacity: 1;\n  transition: .15s ease all\n}\n\n.apexcharts-tooltip.apexcharts-theme-light {\n  border: 1px solid #e3e3e3;\n  background: rgba(255, 255, 255, .96)\n}\n\n.apexcharts-tooltip.apexcharts-theme-dark {\n  color: #fff;\n  background: rgba(30, 30, 30, .8)\n}\n\n.apexcharts-tooltip * {\n  font-family: inherit\n}\n\n.apexcharts-tooltip-title {\n  padding: 6px;\n  font-size: 15px;\n  margin-bottom: 4px\n}\n\n.apexcharts-tooltip.apexcharts-theme-light .apexcharts-tooltip-title {\n  background: #eceff1;\n  border-bottom: 1px solid #ddd\n}\n\n.apexcharts-tooltip.apexcharts-theme-dark .apexcharts-tooltip-title {\n  background: rgba(0, 0, 0, .7);\n  border-bottom: 1px solid #333\n}\n\n.apexcharts-tooltip-text-goals-value,\n.apexcharts-tooltip-text-y-value,\n.apexcharts-tooltip-text-z-value {\n  display: inline-block;\n  margin-left: 5px;\n  font-weight: 600\n}\n\n.apexcharts-tooltip-text-goals-label:empty,\n.apexcharts-tooltip-text-goals-value:empty,\n.apexcharts-tooltip-text-y-label:empty,\n.apexcharts-tooltip-text-y-value:empty,\n.apexcharts-tooltip-text-z-value:empty,\n.apexcharts-tooltip-title:empty {\n  display: none\n}\n\n.apexcharts-tooltip-text-goals-label,\n.apexcharts-tooltip-text-goals-value {\n  padding: 6px 0 5px\n}\n\n.apexcharts-tooltip-goals-group,\n.apexcharts-tooltip-text-goals-label,\n.apexcharts-tooltip-text-goals-value {\n  display: flex\n}\n\n.apexcharts-tooltip-text-goals-label:not(:empty),\n.apexcharts-tooltip-text-goals-value:not(:empty) {\n  margin-top: -6px\n}\n\n.apexcharts-tooltip-marker {\n  display: inline-block;\n  position: relative;\n  width: 16px;\n  height: 16px;\n  font-size: 16px;\n  line-height: 16px;\n  margin-right: 4px;\n  text-align: center;\n  vertical-align: middle;\n  color: inherit;\n}\n\n.apexcharts-tooltip-marker::before {\n  content: &quot;&quot;;\n  display: inline-block;\n  width: 100%;\n  text-align: center;\n  color: currentcolor;\n  text-rendering: optimizeLegibility;\n  -webkit-font-smoothing: antialiased;\n  font-size: 26px;\n  font-family: Arial, Helvetica, sans-serif;\n  line-height: 14px;\n  font-weight: 900;\n}\n\n.apexcharts-tooltip-marker[shape=&quot;circle&quot;]::before {\n  content: &quot;\\25CF&quot;;\n}\n\n.apexcharts-tooltip-marker[shape=&quot;square&quot;]::before,\n.apexcharts-tooltip-marker[shape=&quot;rect&quot;]::before {\n  content: &quot;\\25A0&quot;;\n  transform: translate(-1px, -2px);\n}\n\n.apexcharts-tooltip-marker[shape=&quot;line&quot;]::before {\n  content: &quot;\\2500&quot;;\n}\n\n.apexcharts-tooltip-marker[shape=&quot;diamond&quot;]::before {\n  content: &quot;\\25C6&quot;;\n  font-size: 28px;\n}\n\n.apexcharts-tooltip-marker[shape=&quot;triangle&quot;]::before {\n  content: &quot;\\25B2&quot;;\n  font-size: 22px;\n}\n\n.apexcharts-tooltip-marker[shape=&quot;cross&quot;]::before {\n  content: &quot;\\2715&quot;;\n  font-size: 18px;\n}\n\n.apexcharts-tooltip-marker[shape=&quot;plus&quot;]::before {\n  content: &quot;\\2715&quot;;\n  transform: rotate(45deg) translate(-1px, -1px);\n  font-size: 18px;\n}\n\n.apexcharts-tooltip-marker[shape=&quot;star&quot;]::before {\n  content: &quot;\\2605&quot;;\n  font-size: 18px;\n}\n\n.apexcharts-tooltip-marker[shape=&quot;sparkle&quot;]::before {\n  content: &quot;\\2726&quot;;\n  font-size: 20px;\n}\n\n.apexcharts-tooltip-series-group {\n  padding: 0 10px;\n  display: none;\n  text-align: left;\n  justify-content: left;\n  align-items: center\n}\n\n.apexcharts-tooltip-series-group.apexcharts-active .apexcharts-tooltip-marker {\n  opacity: 1\n}\n\n.apexcharts-tooltip-series-group.apexcharts-active,\n.apexcharts-tooltip-series-group:last-child {\n  padding-bottom: 4px\n}\n\n.apexcharts-tooltip-y-group {\n  padding: 6px 0 5px\n}\n\n.apexcharts-custom-tooltip,\n.apexcharts-tooltip-box {\n  padding: 4px 8px\n}\n\n.apexcharts-tooltip-boxPlot {\n  display: flex;\n  flex-direction: column-reverse\n}\n\n.apexcharts-tooltip-box&gt;div {\n  margin: 4px 0\n}\n\n.apexcharts-tooltip-box span.value {\n  font-weight: 700\n}\n\n.apexcharts-tooltip-rangebar {\n  padding: 5px 8px\n}\n\n.apexcharts-tooltip-rangebar .category {\n  font-weight: 600;\n  color: #777\n}\n\n.apexcharts-tooltip-rangebar .series-name {\n  font-weight: 700;\n  display: block;\n  margin-bottom: 5px\n}\n\n.apexcharts-xaxistooltip,\n.apexcharts-yaxistooltip {\n  opacity: 0;\n  pointer-events: none;\n  color: #373d3f;\n  font-size: 13px;\n  text-align: center;\n  border-radius: 2px;\n  position: absolute;\n  z-index: 10;\n  background: #eceff1;\n  border: 1px solid #90a4ae\n}\n\n.apexcharts-xaxistooltip {\n  padding: 9px 10px;\n  transition: .15s ease all\n}\n\n.apexcharts-xaxistooltip.apexcharts-theme-dark {\n  background: rgba(0, 0, 0, .7);\n  border: 1px solid rgba(0, 0, 0, .5);\n  color: #fff\n}\n\n.apexcharts-xaxistooltip:after,\n.apexcharts-xaxistooltip:before {\n  left: 50%;\n  border: solid transparent;\n  content: &quot; &quot;;\n  height: 0;\n  width: 0;\n  position: absolute;\n  pointer-events: none\n}\n\n.apexcharts-xaxistooltip:after {\n  border-color: transparent;\n  border-width: 6px;\n  margin-left: -6px\n}\n\n.apexcharts-xaxistooltip:before {\n  border-color: transparent;\n  border-width: 7px;\n  margin-left: -7px\n}\n\n.apexcharts-xaxistooltip-bottom:after,\n.apexcharts-xaxistooltip-bottom:before {\n  bottom: 100%\n}\n\n.apexcharts-xaxistooltip-top:after,\n.apexcharts-xaxistooltip-top:before {\n  top: 100%\n}\n\n.apexcharts-xaxistooltip-bottom:after {\n  border-bottom-color: #eceff1\n}\n\n.apexcharts-xaxistooltip-bottom:before {\n  border-bottom-color: #90a4ae\n}\n\n.apexcharts-xaxistooltip-bottom.apexcharts-theme-dark:after,\n.apexcharts-xaxistooltip-bottom.apexcharts-theme-dark:before {\n  border-bottom-color: rgba(0, 0, 0, .5)\n}\n\n.apexcharts-xaxistooltip-top:after {\n  border-top-color: #eceff1\n}\n\n.apexcharts-xaxistooltip-top:before {\n  border-top-color: #90a4ae\n}\n\n.apexcharts-xaxistooltip-top.apexcharts-theme-dark:after,\n.apexcharts-xaxistooltip-top.apexcharts-theme-dark:before {\n  border-top-color: rgba(0, 0, 0, .5)\n}\n\n.apexcharts-xaxistooltip.apexcharts-active {\n  opacity: 1;\n  transition: .15s ease all\n}\n\n.apexcharts-yaxistooltip {\n  padding: 4px 10px\n}\n\n.apexcharts-yaxistooltip.apexcharts-theme-dark {\n  background: rgba(0, 0, 0, .7);\n  border: 1px solid rgba(0, 0, 0, .5);\n  color: #fff\n}\n\n.apexcharts-yaxistooltip:after,\n.apexcharts-yaxistooltip:before {\n  top: 50%;\n  border: solid transparent;\n  content: &quot; &quot;;\n  height: 0;\n  width: 0;\n  position: absolute;\n  pointer-events: none\n}\n\n.apexcharts-yaxistooltip:after {\n  border-color: transparent;\n  border-width: 6px;\n  margin-top: -6px\n}\n\n.apexcharts-yaxistooltip:before {\n  border-color: transparent;\n  border-width: 7px;\n  margin-top: -7px\n}\n\n.apexcharts-yaxistooltip-left:after,\n.apexcharts-yaxistooltip-left:before {\n  left: 100%\n}\n\n.apexcharts-yaxistooltip-right:after,\n.apexcharts-yaxistooltip-right:before {\n  right: 100%\n}\n\n.apexcharts-yaxistooltip-left:after {\n  border-left-color: #eceff1\n}\n\n.apexcharts-yaxistooltip-left:before {\n  border-left-color: #90a4ae\n}\n\n.apexcharts-yaxistooltip-left.apexcharts-theme-dark:after,\n.apexcharts-yaxistooltip-left.apexcharts-theme-dark:before {\n  border-left-color: rgba(0, 0, 0, .5)\n}\n\n.apexcharts-yaxistooltip-right:after {\n  border-right-color: #eceff1\n}\n\n.apexcharts-yaxistooltip-right:before {\n  border-right-color: #90a4ae\n}\n\n.apexcharts-yaxistooltip-right.apexcharts-theme-dark:after,\n.apexcharts-yaxistooltip-right.apexcharts-theme-dark:before {\n  border-right-color: rgba(0, 0, 0, .5)\n}\n\n.apexcharts-yaxistooltip.apexcharts-active {\n  opacity: 1\n}\n\n.apexcharts-yaxistooltip-hidden {\n  display: none\n}\n\n.apexcharts-xcrosshairs,\n.apexcharts-ycrosshairs {\n  pointer-events: none;\n  opacity: 0;\n  transition: .15s ease all\n}\n\n.apexcharts-xcrosshairs.apexcharts-active,\n.apexcharts-ycrosshairs.apexcharts-active {\n  opacity: 1;\n  transition: .15s ease all\n}\n\n.apexcharts-ycrosshairs-hidden {\n  opacity: 0\n}\n\n.apexcharts-selection-rect {\n  cursor: move\n}\n\n.svg_select_shape {\n  stroke-width: 1;\n  stroke-dasharray: 10 10;\n  stroke: black;\n  stroke-opacity: 0.1;\n  pointer-events: none;\n  fill: none;\n}\n\n.svg_select_handle {\n  stroke-width: 3;\n  stroke: black;\n  fill: none;\n}\n\n.svg_select_handle_r {\n  cursor: e-resize;\n}\n\n.svg_select_handle_l {\n  cursor: w-resize;\n}\n\n.apexcharts-svg.apexcharts-zoomable.hovering-zoom {\n  cursor: crosshair\n}\n\n.apexcharts-svg.apexcharts-zoomable.hovering-pan {\n  cursor: move\n}\n\n.apexcharts-menu-icon,\n.apexcharts-pan-icon,\n.apexcharts-reset-icon,\n.apexcharts-selection-icon,\n.apexcharts-toolbar-custom-icon,\n.apexcharts-zoom-icon,\n.apexcharts-zoomin-icon,\n.apexcharts-zoomout-icon {\n  cursor: pointer;\n  width: 20px;\n  height: 20px;\n  line-height: 24px;\n  color: #6e8192;\n  text-align: center\n}\n\n.apexcharts-menu-icon svg,\n.apexcharts-reset-icon svg,\n.apexcharts-zoom-icon svg,\n.apexcharts-zoomin-icon svg,\n.apexcharts-zoomout-icon svg {\n  fill: #6e8192\n}\n\n.apexcharts-selection-icon svg {\n  fill: #444;\n  transform: scale(.76)\n}\n\n.apexcharts-theme-dark .apexcharts-menu-icon svg,\n.apexcharts-theme-dark .apexcharts-pan-icon svg,\n.apexcharts-theme-dark .apexcharts-reset-icon svg,\n.apexcharts-theme-dark .apexcharts-selection-icon svg,\n.apexcharts-theme-dark .apexcharts-toolbar-custom-icon svg,\n.apexcharts-theme-dark .apexcharts-zoom-icon svg,\n.apexcharts-theme-dark .apexcharts-zoomin-icon svg,\n.apexcharts-theme-dark .apexcharts-zoomout-icon svg {\n  fill: #f3f4f5\n}\n\n.apexcharts-canvas .apexcharts-reset-zoom-icon.apexcharts-selected svg,\n.apexcharts-canvas .apexcharts-selection-icon.apexcharts-selected svg,\n.apexcharts-canvas .apexcharts-zoom-icon.apexcharts-selected svg {\n  fill: #008ffb\n}\n\n.apexcharts-theme-light .apexcharts-menu-icon:hover svg,\n.apexcharts-theme-light .apexcharts-reset-icon:hover svg,\n.apexcharts-theme-light .apexcharts-selection-icon:not(.apexcharts-selected):hover svg,\n.apexcharts-theme-light .apexcharts-zoom-icon:not(.apexcharts-selected):hover svg,\n.apexcharts-theme-light .apexcharts-zoomin-icon:hover svg,\n.apexcharts-theme-light .apexcharts-zoomout-icon:hover svg {\n  fill: #333\n}\n\n.apexcharts-menu-icon,\n.apexcharts-selection-icon {\n  position: relative\n}\n\n.apexcharts-reset-icon {\n  margin-left: 5px\n}\n\n.apexcharts-menu-icon,\n.apexcharts-reset-icon,\n.apexcharts-zoom-icon {\n  transform: scale(.85)\n}\n\n.apexcharts-zoomin-icon,\n.apexcharts-zoomout-icon {\n  transform: scale(.7)\n}\n\n.apexcharts-zoomout-icon {\n  margin-right: 3px\n}\n\n.apexcharts-pan-icon {\n  transform: scale(.62);\n  position: relative;\n  left: 1px;\n  top: 0\n}\n\n.apexcharts-pan-icon svg {\n  fill: #fff;\n  stroke: #6e8192;\n  stroke-width: 2\n}\n\n.apexcharts-pan-icon.apexcharts-selected svg {\n  stroke: #008ffb\n}\n\n.apexcharts-pan-icon:not(.apexcharts-selected):hover svg {\n  stroke: #333\n}\n\n.apexcharts-toolbar {\n  position: absolute;\n  z-index: 11;\n  max-width: 176px;\n  text-align: right;\n  border-radius: 3px;\n  padding: 0 6px 2px;\n  display: flex;\n  justify-content: space-between;\n  align-items: center\n}\n\n.apexcharts-menu {\n  background: #fff;\n  position: absolute;\n  top: 100%;\n  border: 1px solid #ddd;\n  border-radius: 3px;\n  padding: 3px;\n  right: 10px;\n  opacity: 0;\n  min-width: 110px;\n  transition: .15s ease all;\n  pointer-events: none\n}\n\n.apexcharts-menu.apexcharts-menu-open {\n  opacity: 1;\n  pointer-events: all;\n  transition: .15s ease all\n}\n\n.apexcharts-menu-item {\n  padding: 6px 7px;\n  font-size: 12px;\n  cursor: pointer\n}\n\n.apexcharts-theme-light .apexcharts-menu-item:hover {\n  background: #eee\n}\n\n.apexcharts-theme-dark .apexcharts-menu {\n  background: rgba(0, 0, 0, .7);\n  color: #fff\n}\n\n@media screen and (min-width:768px) {\n  .apexcharts-canvas:hover .apexcharts-toolbar {\n    opacity: 1\n  }\n}\n\n.apexcharts-canvas .apexcharts-element-hidden,\n.apexcharts-datalabel.apexcharts-element-hidden,\n.apexcharts-hide .apexcharts-series-points {\n  opacity: 0;\n}\n\n.apexcharts-hidden-element-shown {\n  opacity: 1;\n  transition: 0.25s ease all;\n}\n\n.apexcharts-datalabel,\n.apexcharts-datalabel-label,\n.apexcharts-datalabel-value,\n.apexcharts-datalabels,\n.apexcharts-pie-label {\n  cursor: default;\n  pointer-events: none\n}\n\n.apexcharts-pie-label-delay {\n  opacity: 0;\n  animation-name: opaque;\n  animation-duration: .3s;\n  animation-fill-mode: forwards;\n  animation-timing-function: ease\n}\n\n.apexcharts-radialbar-label {\n  cursor: pointer;\n}\n\n.apexcharts-annotation-rect,\n.apexcharts-area-series .apexcharts-area,\n.apexcharts-gridline,\n.apexcharts-line,\n.apexcharts-point-annotation-label,\n.apexcharts-radar-series path:not(.apexcharts-marker),\n.apexcharts-radar-series polygon,\n.apexcharts-toolbar svg,\n.apexcharts-tooltip .apexcharts-marker,\n.apexcharts-xaxis-annotation-label,\n.apexcharts-yaxis-annotation-label,\n.apexcharts-zoom-rect,\n.no-pointer-events {\n  pointer-events: none\n}\n\n.apexcharts-tooltip-active .apexcharts-marker {\n  transition: .15s ease all\n}\n\n.apexcharts-radar-series .apexcharts-yaxis {\n  pointer-events: none;\n}\n\n.resize-triggers {\n  animation: 1ms resizeanim;\n  visibility: hidden;\n  opacity: 0;\n  height: 100%;\n  width: 100%;\n  overflow: hidden\n}\n\n.contract-trigger:before,\n.resize-triggers,\n.resize-triggers&gt;div {\n  content: &quot; &quot;;\n  display: block;\n  position: absolute;\n  top: 0;\n  left: 0\n}\n\n.resize-triggers&gt;div {\n  height: 100%;\n  width: 100%;\n  background: #eee;\n  overflow: auto\n}\n\n.contract-trigger:before {\n  overflow: hidden;\n  width: 200%;\n  height: 200%\n}\n\n.apexcharts-bar-goals-markers {\n  pointer-events: none\n}\n\n.apexcharts-bar-shadows {\n  pointer-events: none\n}\n\n.apexcharts-rangebar-goals-markers {\n  pointer-events: none\n}&#x27;;
          var h2 = (null === (l2 = t3.opts.chart) || void 0 === l2 ? void 0 : l2.nonce) || t3.w.config.chart.nonce;
          h2 &amp;&amp; o2.setAttribute(&quot;nonce&quot;, h2), r2 ? s2.prepend(o2) : n2.head.appendChild(o2);
        }
        var c2 = t3.create(t3.w.config.series, {});
        if (!c2) return e2(t3);
        t3.mount(c2).then(function() {
          &quot;function&quot; == typeof t3.w.config.chart.events.mounted &amp;&amp; t3.w.config.chart.events.mounted(t3, t3.w), t3.events.fireEvent(&quot;mounted&quot;, [t3, t3.w]), e2(c2);
        }).catch(function(t4) {
          i2(t4);
        });
      } else i2(new Error(&quot;Element not found&quot;));
    });
  } }, { key: &quot;create&quot;, value: function(t3, e2) {
    var i2 = this, a2 = this.w;
    new hs(this).initModules();
    var s2 = this.w.globals;
    if (s2.noData = false, s2.animationEnded = false, !v.elementExists(this.el)) return s2.animationEnded = true, this.destroy(), null;
    (this.responsive.checkResponsiveConfig(e2), a2.config.xaxis.convertedCatToNumeric) &amp;&amp; new Ni(a2.config).convertCatToNumericXaxis(a2.config, this.ctx);
    if (this.core.setupElements(), &quot;treemap&quot; === a2.config.chart.type &amp;&amp; (a2.config.grid.show = false, a2.config.yaxis[0].show = false), 0 === s2.svgWidth) return s2.animationEnded = true, null;
    var r2 = t3;
    t3.forEach(function(t4, e3) {
      t4.hidden &amp;&amp; (r2 = i2.legend.legendHelpers.getSeriesAfterCollapsing({ realIndex: e3 }));
    });
    var n2 = Pi.checkComboSeries(r2, a2.config.chart.type);
    s2.comboCharts = n2.comboCharts, s2.comboBarCount = n2.comboBarCount;
    var o2 = r2.every(function(t4) {
      return t4.data &amp;&amp; 0 === t4.data.length;
    });
    (0 === r2.length || o2 &amp;&amp; s2.collapsedSeries.length &lt; 1) &amp;&amp; this.series.handleNoData(), this.events.setupEventHandlers(), this.data.parseData(r2), this.theme.init(), new Vi(this).setGlobalMarkerSize(), this.formatters.setLabelFormatters(), this.titleSubtitle.draw(), s2.noData &amp;&amp; s2.collapsedSeries.length !== s2.series.length &amp;&amp; !a2.config.legend.showForSingleSeries || this.legend.init(), this.series.hasAllSeriesEqualX(), s2.axisCharts &amp;&amp; (this.core.coreCalculations(), &quot;category&quot; !== a2.config.xaxis.type &amp;&amp; this.formatters.setLabelFormatters(), this.ctx.toolbar.minX = a2.globals.minX, this.ctx.toolbar.maxX = a2.globals.maxX), this.formatters.heatmapLabelFormatters(), new Pi(this).getLargestMarkerSize(), this.dimensions.plotCoords();
    var l2 = this.core.xySettings();
    this.grid.createGridMask();
    var h2 = this.core.plotChartType(r2, l2), c2 = new qi(this);
    return c2.bringForward(), a2.config.dataLabels.background.enabled &amp;&amp; c2.dataLabelsBackground(), this.core.shiftGraphPosition(), { elGraph: h2, xyRatios: l2, dimensions: { plot: { left: a2.globals.translateX, top: a2.globals.translateY, width: a2.globals.gridWidth, height: a2.globals.gridHeight } } };
  } }, { key: &quot;mount&quot;, value: function() {
    var t3 = this, e2 = arguments.length &gt; 0 &amp;&amp; void 0 !== arguments[0] ? arguments[0] : null, i2 = this, a2 = i2.w;
    return new Promise(function(s2, r2) {
      if (null === i2.el) return r2(new Error(&quot;Not enough data to display or target element not found&quot;));
      (null === e2 || a2.globals.allSeriesCollapsed) &amp;&amp; i2.series.handleNoData(), i2.grid = new Ki(i2);
      var n2, o2, l2 = i2.grid.drawGrid();
      (i2.annotations = new Fi(i2), i2.annotations.drawImageAnnos(), i2.annotations.drawTextAnnos(), &quot;back&quot; === a2.config.grid.position) &amp;&amp; (l2 &amp;&amp; a2.globals.dom.elGraphical.add(l2.el), null != l2 &amp;&amp; null !== (n2 = l2.elGridBorders) &amp;&amp; void 0 !== n2 &amp;&amp; n2.node &amp;&amp; a2.globals.dom.elGraphical.add(l2.elGridBorders));
      if (Array.isArray(e2.elGraph)) for (var h2 = 0; h2 &lt; e2.elGraph.length; h2++) a2.globals.dom.elGraphical.add(e2.elGraph[h2]);
      else a2.globals.dom.elGraphical.add(e2.elGraph);
      &quot;front&quot; === a2.config.grid.position &amp;&amp; (l2 &amp;&amp; a2.globals.dom.elGraphical.add(l2.el), null != l2 &amp;&amp; null !== (o2 = l2.elGridBorders) &amp;&amp; void 0 !== o2 &amp;&amp; o2.node &amp;&amp; a2.globals.dom.elGraphical.add(l2.elGridBorders));
      &quot;front&quot; === a2.config.xaxis.crosshairs.position &amp;&amp; i2.crosshairs.drawXCrosshairs(), &quot;front&quot; === a2.config.yaxis[0].crosshairs.position &amp;&amp; i2.crosshairs.drawYCrosshairs(), &quot;treemap&quot; !== a2.config.chart.type &amp;&amp; i2.axes.drawAxis(a2.config.chart.type, l2);
      var c2 = new Qi(t3.ctx, l2), d2 = new ia(t3.ctx, l2);
      if (null !== l2 &amp;&amp; (c2.xAxisLabelCorrections(l2.xAxisTickWidth), d2.setYAxisTextAlignments(), a2.config.yaxis.map(function(t4, e3) {
        -1 === a2.globals.ignoreYAxisIndexes.indexOf(e3) &amp;&amp; d2.yAxisTitleRotate(e3, t4.opposite);
      })), i2.annotations.drawAxesAnnotations(), !a2.globals.noData) {
        if (a2.config.tooltip.enabled &amp;&amp; !a2.globals.noData &amp;&amp; i2.w.globals.tooltip.drawTooltip(e2.xyRatios), a2.globals.axisCharts &amp;&amp; (a2.globals.isXNumeric || a2.config.xaxis.convertedCatToNumeric || a2.globals.isRangeBar)) (a2.config.chart.zoom.enabled || a2.config.chart.selection &amp;&amp; a2.config.chart.selection.enabled || a2.config.chart.pan &amp;&amp; a2.config.chart.pan.enabled) &amp;&amp; i2.zoomPanSelection.init({ xyRatios: e2.xyRatios });
        else {
          var u2 = a2.config.chart.toolbar.tools;
          [&quot;zoom&quot;, &quot;zoomin&quot;, &quot;zoomout&quot;, &quot;selection&quot;, &quot;pan&quot;, &quot;reset&quot;].forEach(function(t4) {
            u2[t4] = false;
          });
        }
        a2.config.chart.toolbar.show &amp;&amp; !a2.globals.allSeriesCollapsed &amp;&amp; i2.toolbar.createToolbar();
      }
      a2.globals.memory.methodsToExec.length &gt; 0 &amp;&amp; a2.globals.memory.methodsToExec.forEach(function(t4) {
        t4.method(t4.params, false, t4.context);
      }), a2.globals.axisCharts || a2.globals.noData || i2.core.resizeNonAxisCharts(), s2(i2);
    });
  } }, { key: &quot;destroy&quot;, value: function() {
    window.removeEventListener(&quot;resize&quot;, this.windowResizeHandler), function(t4, e2) {
      var i2 = ds.get(e2);
      i2 &amp;&amp; (i2.disconnect(), ds.delete(e2));
    }(this.el.parentNode, this.parentResizeHandler);
    var t3 = this.w.config.chart.id;
    t3 &amp;&amp; Apex._chartInstances.forEach(function(e2, i2) {
      e2.id === v.escapeString(t3) &amp;&amp; Apex._chartInstances.splice(i2, 1);
    }), new cs(this.ctx).clear({ isUpdating: false });
  } }, { key: &quot;updateOptions&quot;, value: function(t3) {
    var e2 = this, i2 = arguments.length &gt; 1 &amp;&amp; void 0 !== arguments[1] &amp;&amp; arguments[1], a2 = !(arguments.length &gt; 2 &amp;&amp; void 0 !== arguments[2]) || arguments[2], s2 = !(arguments.length &gt; 3 &amp;&amp; void 0 !== arguments[3]) || arguments[3], r2 = !(arguments.length &gt; 4 &amp;&amp; void 0 !== arguments[4]) || arguments[4], n2 = this.w;
    return n2.globals.selection = void 0, t3.series &amp;&amp; (this.series.resetSeries(false, true, false), t3.series.length &amp;&amp; t3.series[0].data &amp;&amp; (t3.series = t3.series.map(function(t4, i3) {
      return e2.updateHelpers._extendSeries(t4, i3);
    })), this.updateHelpers.revertDefaultAxisMinMax()), t3.xaxis &amp;&amp; (t3 = this.updateHelpers.forceXAxisUpdate(t3)), t3.yaxis &amp;&amp; (t3 = this.updateHelpers.forceYAxisUpdate(t3)), n2.globals.collapsedSeriesIndices.length &gt; 0 &amp;&amp; this.series.clearPreviousPaths(), t3.theme &amp;&amp; (t3 = this.theme.updateThemeOptions(t3)), this.updateHelpers._updateOptions(t3, i2, a2, s2, r2);
  } }, { key: &quot;updateSeries&quot;, value: function() {
    var t3 = arguments.length &gt; 0 &amp;&amp; void 0 !== arguments[0] ? arguments[0] : [], e2 = !(arguments.length &gt; 1 &amp;&amp; void 0 !== arguments[1]) || arguments[1], i2 = !(arguments.length &gt; 2 &amp;&amp; void 0 !== arguments[2]) || arguments[2];
    return this.series.resetSeries(false), this.updateHelpers.revertDefaultAxisMinMax(), this.updateHelpers._updateSeries(t3, e2, i2);
  } }, { key: &quot;appendSeries&quot;, value: function(t3) {
    var e2 = !(arguments.length &gt; 1 &amp;&amp; void 0 !== arguments[1]) || arguments[1], i2 = !(arguments.length &gt; 2 &amp;&amp; void 0 !== arguments[2]) || arguments[2], a2 = this.w.config.series.slice();
    return a2.push(t3), this.series.resetSeries(false), this.updateHelpers.revertDefaultAxisMinMax(), this.updateHelpers._updateSeries(a2, e2, i2);
  } }, { key: &quot;appendData&quot;, value: function(t3) {
    var e2 = !(arguments.length &gt; 1 &amp;&amp; void 0 !== arguments[1]) || arguments[1], i2 = this;
    i2.w.globals.dataChanged = true, i2.series.getPreviousPaths();
    for (var a2 = i2.w.config.series.slice(), s2 = 0; s2 &lt; a2.length; s2++) if (null !== t3[s2] &amp;&amp; void 0 !== t3[s2]) for (var r2 = 0; r2 &lt; t3[s2].data.length; r2++) a2[s2].data.push(t3[s2].data[r2]);
    return i2.w.config.series = a2, e2 &amp;&amp; (i2.w.globals.initialSeries = v.clone(i2.w.config.series)), this.update();
  } }, { key: &quot;update&quot;, value: function(t3) {
    var e2 = this;
    return new Promise(function(i2, a2) {
      new cs(e2.ctx).clear({ isUpdating: true });
      var s2 = e2.create(e2.w.config.series, t3);
      if (!s2) return i2(e2);
      e2.mount(s2).then(function() {
        &quot;function&quot; == typeof e2.w.config.chart.events.updated &amp;&amp; e2.w.config.chart.events.updated(e2, e2.w), e2.events.fireEvent(&quot;updated&quot;, [e2, e2.w]), e2.w.globals.isDirty = true, i2(e2);
      }).catch(function(t4) {
        a2(t4);
      });
    });
  } }, { key: &quot;getSyncedCharts&quot;, value: function() {
    var t3 = this.getGroupedCharts(), e2 = [this];
    return t3.length &amp;&amp; (e2 = [], t3.forEach(function(t4) {
      e2.push(t4);
    })), e2;
  } }, { key: &quot;getGroupedCharts&quot;, value: function() {
    var t3 = this;
    return Apex._chartInstances.filter(function(t4) {
      if (t4.group) return true;
    }).map(function(e2) {
      return t3.w.config.chart.group === e2.group ? e2.chart : t3;
    });
  } }, { key: &quot;toggleSeries&quot;, value: function(t3) {
    return this.series.toggleSeries(t3);
  } }, { key: &quot;highlightSeriesOnLegendHover&quot;, value: function(t3, e2) {
    return this.series.toggleSeriesOnHover(t3, e2);
  } }, { key: &quot;showSeries&quot;, value: function(t3) {
    this.series.showSeries(t3);
  } }, { key: &quot;hideSeries&quot;, value: function(t3) {
    this.series.hideSeries(t3);
  } }, { key: &quot;highlightSeries&quot;, value: function(t3) {
    this.series.highlightSeries(t3);
  } }, { key: &quot;isSeriesHidden&quot;, value: function(t3) {
    this.series.isSeriesHidden(t3);
  } }, { key: &quot;resetSeries&quot;, value: function() {
    var t3 = !(arguments.length &gt; 0 &amp;&amp; void 0 !== arguments[0]) || arguments[0], e2 = !(arguments.length &gt; 1 &amp;&amp; void 0 !== arguments[1]) || arguments[1];
    this.series.resetSeries(t3, e2);
  } }, { key: &quot;addEventListener&quot;, value: function(t3, e2) {
    this.events.addEventListener(t3, e2);
  } }, { key: &quot;removeEventListener&quot;, value: function(t3, e2) {
    this.events.removeEventListener(t3, e2);
  } }, { key: &quot;addXaxisAnnotation&quot;, value: function(t3) {
    var e2 = !(arguments.length &gt; 1 &amp;&amp; void 0 !== arguments[1]) || arguments[1], i2 = arguments.length &gt; 2 &amp;&amp; void 0 !== arguments[2] ? arguments[2] : void 0, a2 = this;
    i2 &amp;&amp; (a2 = i2), a2.annotations.addXaxisAnnotationExternal(t3, e2, a2);
  } }, { key: &quot;addYaxisAnnotation&quot;, value: function(t3) {
    var e2 = !(arguments.length &gt; 1 &amp;&amp; void 0 !== arguments[1]) || arguments[1], i2 = arguments.length &gt; 2 &amp;&amp; void 0 !== arguments[2] ? arguments[2] : void 0, a2 = this;
    i2 &amp;&amp; (a2 = i2), a2.annotations.addYaxisAnnotationExternal(t3, e2, a2);
  } }, { key: &quot;addPointAnnotation&quot;, value: function(t3) {
    var e2 = !(arguments.length &gt; 1 &amp;&amp; void 0 !== arguments[1]) || arguments[1], i2 = arguments.length &gt; 2 &amp;&amp; void 0 !== arguments[2] ? arguments[2] : void 0, a2 = this;
    i2 &amp;&amp; (a2 = i2), a2.annotations.addPointAnnotationExternal(t3, e2, a2);
  } }, { key: &quot;clearAnnotations&quot;, value: function() {
    var t3 = arguments.length &gt; 0 &amp;&amp; void 0 !== arguments[0] ? arguments[0] : void 0, e2 = this;
    t3 &amp;&amp; (e2 = t3), e2.annotations.clearAnnotations(e2);
  } }, { key: &quot;removeAnnotation&quot;, value: function(t3) {
    var e2 = arguments.length &gt; 1 &amp;&amp; void 0 !== arguments[1] ? arguments[1] : void 0, i2 = this;
    e2 &amp;&amp; (i2 = e2), i2.annotations.removeAnnotation(i2, t3);
  } }, { key: &quot;getChartArea&quot;, value: function() {
    return this.w.globals.dom.baseEl.querySelector(&quot;.apexcharts-inner&quot;);
  } }, { key: &quot;getSeriesTotalXRange&quot;, value: function(t3, e2) {
    return this.coreUtils.getSeriesTotalsXRange(t3, e2);
  } }, { key: &quot;getHighestValueInSeries&quot;, value: function() {
    var t3 = arguments.length &gt; 0 &amp;&amp; void 0 !== arguments[0] ? arguments[0] : 0;
    return new ea(this.ctx).getMinYMaxY(t3).highestY;
  } }, { key: &quot;getLowestValueInSeries&quot;, value: function() {
    var t3 = arguments.length &gt; 0 &amp;&amp; void 0 !== arguments[0] ? arguments[0] : 0;
    return new ea(this.ctx).getMinYMaxY(t3).lowestY;
  } }, { key: &quot;getSeriesTotal&quot;, value: function() {
    return this.w.globals.seriesTotals;
  } }, { key: &quot;toggleDataPointSelection&quot;, value: function(t3, e2) {
    return this.updateHelpers.toggleDataPointSelection(t3, e2);
  } }, { key: &quot;zoomX&quot;, value: function(t3, e2) {
    this.ctx.toolbar.zoomUpdateOptions(t3, e2);
  } }, { key: &quot;setLocale&quot;, value: function(t3) {
    this.localization.setCurrentLocaleValues(t3);
  } }, { key: &quot;dataURI&quot;, value: function(t3) {
    return new Ji(this.ctx).dataURI(t3);
  } }, { key: &quot;getSvgString&quot;, value: function(t3) {
    return new Ji(this.ctx).getSvgString(t3);
  } }, { key: &quot;exportToCSV&quot;, value: function() {
    var t3 = arguments.length &gt; 0 &amp;&amp; void 0 !== arguments[0] ? arguments[0] : {};
    return new Ji(this.ctx).exportToCSV(t3);
  } }, { key: &quot;paper&quot;, value: function() {
    return this.w.globals.dom.Paper;
  } }, { key: &quot;_parentResizeCallback&quot;, value: function() {
    this.w.globals.animationEnded &amp;&amp; this.w.config.chart.redrawOnParentResize &amp;&amp; this._windowResize();
  } }, { key: &quot;_windowResize&quot;, value: function() {
    var t3 = this;
    clearTimeout(this.w.globals.resizeTimer), this.w.globals.resizeTimer = window.setTimeout(function() {
      t3.w.globals.resized = true, t3.w.globals.dataChanged = false, t3.ctx.update();
    }, 150);
  } }, { key: &quot;_windowResizeHandler&quot;, value: function() {
    var t3 = this.w.config.chart.redrawOnWindowResize;
    &quot;function&quot; == typeof t3 &amp;&amp; (t3 = t3()), t3 &amp;&amp; this._windowResize();
  } }], [{ key: &quot;getChartByID&quot;, value: function(t3) {
    var e2 = v.escapeString(t3);
    if (Apex._chartInstances) {
      var i2 = Apex._chartInstances.filter(function(t4) {
        return t4.id === e2;
      })[0];
      return i2 &amp;&amp; i2.chart;
    }
  } }, { key: &quot;initOnLoad&quot;, value: function() {
    for (var e2 = document.querySelectorAll(&quot;[data-apexcharts]&quot;), i2 = 0; i2 &lt; e2.length; i2++) {
      new t2(e2[i2], JSON.parse(e2[i2].getAttribute(&quot;data-options&quot;))).render();
    }
  } }, { key: &quot;exec&quot;, value: function(t3, e2) {
    var i2 = this.getChartByID(t3);
    if (i2) {
      i2.w.globals.isExecCalled = true;
      var a2 = null;
      if (-1 !== i2.publicMethods.indexOf(e2)) {
        for (var s2 = arguments.length, r2 = new Array(s2 &gt; 2 ? s2 - 2 : 0), n2 = 2; n2 &lt; s2; n2++) r2[n2 - 2] = arguments[n2];
        a2 = i2[e2].apply(i2, r2);
      }
      return a2;
    }
  } }, { key: &quot;merge&quot;, value: function(t3, e2) {
    return v.extend(t3, e2);
  } }]), t2;
}();

// &lt;stdin&gt;
var whenVisible = (ele, cbk) =&gt; {
  let observer = new IntersectionObserver(function(entries) {
    if (entries[0].isIntersecting === true) {
      observer.unobserve(ele);
      cbk();
      return;
    }
  }, { threshold: [0] });
  observer.observe(ele);
};
core.ApexCharts = async (args, env) =&gt; {
  const options = await interpretate(args[0], env);
  const chart = new us(env.element, options);
  whenVisible(env.element, () =&gt; chart.render());
};
/*! Bundled license information:

apexcharts/dist/apexcharts.esm.js:
  (*!
   * ApexCharts v4.5.0
   * (c) 2018-2025 ApexCharts
   * Released under the MIT License.
   *)
  (*!
  * @svgdotjs/svg.select.js - An extension of svg.js which allows to select elements with mouse
  * @version 4.0.1
  * https://github.com/svgdotjs/svg.select.js
  *
  * @copyright Ulrich-Matthias SchÃƒÂ¤fer
  * @license MIT
  *
  * BUILT: Mon Jul 01 2024 15:04:42 GMT+0200 (Central European Summer Time)
  *)
  (*!
  * @svgdotjs/svg.resize.js - An extension for svg.js which allows to resize elements which are selected
  * @version 2.0.4
  * https://github.com/svgdotjs/svg.resize.js
  *
  * @copyright [object Object]
  * @license MIT
  *
  * BUILT: Fri Sep 13 2024 12:43:14 GMT+0200 (Central European Summer Time)
  *)
*/
</code><code class="codeBlockLines_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Content-styles-module"></code></pre></div></div>
<p>Let&#x27;s test it quickly</p>
<div style="filter:none" class="language-mathematica codeBlockContainer_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Container-styles-module theme-code-block"><div class="codeBlockContent_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Content-styles-module"><pre tabindex="0" class="prism-code language-mathematica codeBlock_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Content-styles-module thin-scrollbar" style="color:rgb(57, 58, 52);background-color:rgb(246, 248, 250)"><code style="white-space:pre-wrap" class="codeBlockLines_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Content-styles-module">ApexCharts[&lt;|
    &quot;series&quot; -&gt; {44, 55, 67, 83},
    &quot;labels&quot; -&gt; {&quot;Apples&quot;, &quot;Oranges&quot;, &quot;Bananas&quot;, &quot;Berries&quot;},
    &quot;chart&quot; -&gt; &lt;|
        &quot;height&quot; -&gt; 350, 
        &quot;type&quot; -&gt; &quot;radialBar&quot;
    |&gt;
|&gt;] // CreateFrontEndObject</code><code class="codeBlockLines_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Content-styles-module"></code></pre></div></div>
<div style="filter:none" class="language-mathematica codeBlockContainer_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Container-styles-module theme-code-block"><div class="codeBlockContent_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Content-styles-module"><pre tabindex="0" class="prism-code language-mathematica codeBlock_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Content-styles-module thin-scrollbar" style="color:rgb(57, 58, 52);background-color:rgb(246, 248, 250)"><code style="white-space:pre-wrap" class="codeBlockLines_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Content-styles-module">(*VB[*)(FrontEndRef[&quot;aa88c477-1913-488d-8ee4-ab5a545b82ae&quot;])(*,*)(*&quot;1:eJxTTMoPSmNkYGAoZgESHvk5KRCeEJBwK8rPK3HNS3GtSE0uLUlMykkNVgEKJyZaWCSbmJvrGloaGuuaWFik6FqkpproJiaZJpqamCZZGCWmAgCA1xWv&quot;*)(*]VB*)</code><code class="codeBlockLines_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Content-styles-module"></code></pre></div></div>
<p>To integrate it better with WL, we need to define the output form. Then it will work like any other high-order graphics symbol</p>
<div style="filter:none" class="language-mathematica codeBlockContainer_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Container-styles-module theme-code-block"><div class="h-fade-20 codeBlockContent_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Content-styles-module"><pre tabindex="0" class="prism-code language-mathematica codeBlock_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Content-styles-module thin-scrollbar" style="color:rgb(57, 58, 52);background-color:rgb(246, 248, 250)"><code style="white-space:pre-wrap" class="codeBlockLines_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Content-styles-module">ApexCharts /: MakeBoxes[a: ApexCharts[_Association], StandardForm ] := With[{},
    ViewBox[a, a]
]

(*BB[*)(* Compress to FrontEndObject if too large *)(*,*)(*&quot;1:eJxTTMoPSmNhYGAo5gcSAUX5ZZkpqSn+BSWZ+XnFaYwgCS4g4Zyfm5uaV+KUXxEMUqxsbm6exgSSBPGCSnNSg9mAjOCSosy8dLBYSFFpKpoKkDkeqYkpEFXBILO1sCgJSczMQVYCAOFrJEU=&quot;*)(*]BB*)
ApexCharts /: MakeBoxes[a: ApexCharts[_Association], form: StandardForm ] := With[{o = CreateFrontEndObject[a]},
    MakeBoxes[o, form]
] /; ByteCount[a] &gt; 1024*4 


(*BB[*)(* Form for slides and WLX cells *)(*,*)(*&quot;1:eJxTTMoPSmNhYGAo5gcSAUX5ZZkpqSn+BSWZ+XnFaYwgCS4g4Zyfm5uaV+KUXxEMUqxsbm6exgSSBPGCSnNSg9mAjOCSosy8dLBYSFFpKpoKkDkeqYkpEFXBILO1sCgJSczMQVYCAOFrJEU=&quot;*)(*]BB*)
ApexCharts /: MakeBoxes[a: ApexCharts[_Association], form: WLXForm ] := With[{o = CreateFrontEndObject[a]},
    MakeBoxes[o, form]
]</code><code class="codeBlockLines_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Content-styles-module"></code></pre></div></div>
<p>Now we can use <code>ApexCharts</code> directly if it was something like <code>Plot</code></p>
<div style="filter:none" class="language-mathematica codeBlockContainer_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Container-styles-module theme-code-block"><div class="codeBlockContent_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Content-styles-module"><pre tabindex="0" class="prism-code language-mathematica codeBlock_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Content-styles-module thin-scrollbar" style="color:rgb(57, 58, 52);background-color:rgb(246, 248, 250)"><code style="white-space:pre-wrap" class="codeBlockLines_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Content-styles-module">ApexCharts[&lt;|
    &quot;series&quot; -&gt; {44, 55, 67, 83},
    &quot;labels&quot; -&gt; {&quot;Apples&quot;, &quot;Oranges&quot;, &quot;Bananas&quot;, &quot;Berries&quot;},
    &quot;chart&quot; -&gt; &lt;|
        &quot;height&quot; -&gt; 350, 
        &quot;type&quot; -&gt; &quot;radialBar&quot;
    |&gt;
|&gt;]</code><code class="codeBlockLines_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Content-styles-module"></code></pre></div></div>
<div style="filter:none" class="language-mathematica codeBlockContainer_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Container-styles-module theme-code-block"><div class="codeBlockContent_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Content-styles-module"><pre tabindex="0" class="prism-code language-mathematica codeBlock_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Content-styles-module thin-scrollbar" style="color:rgb(57, 58, 52);background-color:rgb(246, 248, 250)"><code style="white-space:pre-wrap" class="codeBlockLines_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Content-styles-module">(*VB[*)(ApexCharts[&lt;|&quot;series&quot; -&gt; {44, 55, 67, 83}, &quot;labels&quot; -&gt; {&quot;Apples&quot;, &quot;Oranges&quot;, &quot;Bananas&quot;, &quot;Berries&quot;}, &quot;chart&quot; -&gt; &lt;|&quot;height&quot; -&gt; 350, &quot;type&quot; -&gt; &quot;radialBar&quot;|&gt;|&gt;])(*,*)(*&quot;1:eJyFjksLwjAQhFutivorvHv33PbiQRCau7BtN+1CSEISQf+9mz4OPkACw7ezzGYOtalkmiSJz1jORrXjtGPJLT7KHlzwchm9ffS8Nw1BIKPlYo5Vd4ViHSd0hF5m8+JCPtCRgU5RyiiC5UdUQY3qIzoscmsVerFhvDrQ3cQFaH4Toxv+fb+6Ymhi/dH/375H6vpAt/SrYITwtCi2DA5aAlWAewGcP0T4&quot;*)(*]VB*)</code><code class="codeBlockLines_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Content-styles-module"></code></pre></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="explorations">Explorations<a href="#explorations" class="hash-link" aria-label="Direct link to Explorations" title="Direct link to Explorations">â€‹</a></h2>
<p>ApexCharts is a rich library with more than 20+ built-in chart types.</p>
<div><br></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="bar-charts">Bar charts<a href="#bar-charts" class="hash-link" aria-label="Direct link to Bar charts" title="Direct link to Bar charts">â€‹</a></h3>
<div style="filter:none" class="language-mathematica codeBlockContainer_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Container-styles-module theme-code-block"><div class="codeBlockContent_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Content-styles-module"><pre tabindex="0" class="prism-code language-mathematica codeBlock_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Content-styles-module thin-scrollbar" style="color:rgb(57, 58, 52);background-color:rgb(246, 248, 250)"><code style="white-space:pre-wrap" class="codeBlockLines_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Content-styles-module">&lt;|
  &quot;series&quot; -&gt; {
    &lt;|&quot;name&quot; -&gt; &quot;Net Profit&quot;, &quot;data&quot; -&gt; RandomInteger[{20,100}, 10]|&gt;,
    &lt;|&quot;name&quot; -&gt; &quot;Revenue&quot;, &quot;data&quot; -&gt; RandomInteger[{20,100}, 10]|&gt;,
    &lt;|&quot;name&quot; -&gt; &quot;Free Cash Flow&quot;, &quot;data&quot; -&gt; RandomInteger[{20,100}, 10]|&gt;
  },
  &quot;chart&quot; -&gt; &lt;|&quot;type&quot; -&gt; &quot;bar&quot;, &quot;width&quot;-&gt;450|&gt;
|&gt; // ApexCharts</code><code class="codeBlockLines_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Content-styles-module"></code></pre></div></div>
<div style="filter:none" class="language-mathematica codeBlockContainer_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Container-styles-module theme-code-block"><div class="codeBlockContent_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Content-styles-module"><pre tabindex="0" class="prism-code language-mathematica codeBlock_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Content-styles-module thin-scrollbar" style="color:rgb(57, 58, 52);background-color:rgb(246, 248, 250)"><code style="white-space:pre-wrap" class="codeBlockLines_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Content-styles-module">(*VB[*)(ApexCharts[&lt;|&quot;series&quot; -&gt; {&lt;|&quot;name&quot; -&gt; &quot;Net Profit&quot;, &quot;data&quot; -&gt; {73, 32, 67, 69, 40, 77, 51, 33, 68, 52}|&gt;, &lt;|&quot;name&quot; -&gt; &quot;Revenue&quot;, &quot;data&quot; -&gt; {99, 30, 49, 29, 88, 33, 90, 53, 57, 92}|&gt;, &lt;|&quot;name&quot; -&gt; &quot;Free Cash Flow&quot;, &quot;data&quot; -&gt; {37, 43, 27, 59, 45, 87, 83, 43, 64, 80}|&gt;}, &quot;chart&quot; -&gt; &lt;|&quot;type&quot; -&gt; &quot;bar&quot;, &quot;width&quot; -&gt; 450|&gt;|&gt;])(*,*)(*&quot;1:eJyVUltqwzAQdN+QQM/g3iC1bMf+LIHQQiklPoESr7DAsYKkNO31erJqPSmYkA/nR7M7mt0diX1am5W6iqLI3Ybj1bQ1skk4Xnb0vWik9U5dMzdlzjmz0dJr04HkstW+peqeM7KanLr5v3jXzo+p5aCTW6p47Af5+NMapf0ZVS29VJNh/zcWzUUPIukhnwPKHtIZJCCzZyhRkBcgk4tcPjBDX9TtabzFEm4E3KTIEkBRDE2VkGTIMvguL7P4GIKlJYoX0jXxsjWH8U4FJqaYnxz/7fiZGQyDLMRQmacgZyej7kKw4T0a+wL/s6OKl2gt7ZleB137Rv+GPf0DoYCAKQ==&quot;*)(*]VB*)</code><code class="codeBlockLines_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Content-styles-module"></code></pre></div></div>
<p>Another example</p>
<div style="filter:none" class="language-mathematica codeBlockContainer_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Container-styles-module theme-code-block"><div class="codeBlockContent_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Content-styles-module"><pre tabindex="0" class="prism-code language-mathematica codeBlock_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Content-styles-module thin-scrollbar" style="color:rgb(57, 58, 52);background-color:rgb(246, 248, 250)"><code style="white-space:pre-wrap" class="codeBlockLines_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Content-styles-module">country = {&quot;Germany&quot;, &quot;UK&quot;, &quot;Switzerland&quot;, &quot;Russia&quot;, &quot;China&quot;};
gdp = (*SpB[*)Power[10(*|*),(*|*)-9](*]SpB*) QuantityMagnitude[CountryData[#, &quot;GDP&quot;], (*FB[*)((&quot;USDollars&quot;)(*,*)/(*,*)(&quot;Years&quot;))(*]FB*)] &amp;/@ country;

&lt;|
  &quot;series&quot; -&gt; {
    &lt;|&quot;data&quot; -&gt; gdp, &quot;name&quot; -&gt; &quot;GDP&quot;|&gt;
  },
  &quot;chart&quot; -&gt; &lt;|&quot;type&quot; -&gt; &quot;bar&quot;,  &quot;width&quot;-&gt;450|&gt;,
  &quot;plotOptions&quot; -&gt; &lt;|
    &quot;bar&quot; -&gt; &lt;|
      &quot;borderRadius&quot; -&gt; 4,
      &quot;borderRadiusApplication&quot; -&gt; &quot;end&quot;,
      &quot;horizontal&quot; -&gt; True
    |&gt;
  |&gt;,
  &quot;dataLabels&quot; -&gt; &lt;|&quot;enabled&quot; -&gt; False|&gt;,
  &quot;xaxis&quot; -&gt; &lt;|
    &quot;categories&quot; -&gt; country,
    &quot;title&quot;-&gt;&lt;|&quot;text&quot;-&gt;&quot;Billions USD/Year&quot;|&gt;
  |&gt;
|&gt; // ApexCharts</code><code class="codeBlockLines_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Content-styles-module"></code></pre></div></div>
<div style="filter:none" class="language-mathematica codeBlockContainer_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Container-styles-module theme-code-block"><div class="codeBlockContent_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Content-styles-module"><pre tabindex="0" class="prism-code language-mathematica codeBlock_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Content-styles-module thin-scrollbar" style="color:rgb(57, 58, 52);background-color:rgb(246, 248, 250)"><code style="white-space:pre-wrap" class="codeBlockLines_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Content-styles-module">(*VB[*)(FrontEndRef[&quot;dcc8c7fc-c1ed-46a5-89bb-28b6b64f544b&quot;])(*,*)(*&quot;1:eJxTTMoPSmNkYGAoZgESHvk5KRCeEJBwK8rPK3HNS3GtSE0uLUlMykkNVgEKpyQnWySbpyXrJhumpuiamCWa6lpYJiXpGlkkmSWZmaSZmpgkAQCcvhZt&quot;*)(*]VB*)</code><code class="codeBlockLines_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Content-styles-module"></code></pre></div></div>
<p>It is a bit more &quot;wordy&quot; compared to native Wolfram Language plots. However, nothing can stop you from making wrappers on Javascript or WL side.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="treemap">Treemap<a href="#treemap" class="hash-link" aria-label="Direct link to Treemap" title="Direct link to Treemap">â€‹</a></h2>
<p>Let&#x27;s check some files in your documents directory and see how much space they occupy</p>
<div style="filter:none" class="language-mathematica codeBlockContainer_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Container-styles-module theme-code-block"><div class="codeBlockContent_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Content-styles-module"><pre tabindex="0" class="prism-code language-mathematica codeBlock_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Content-styles-module thin-scrollbar" style="color:rgb(57, 58, 52);background-color:rgb(246, 248, 250)"><code style="white-space:pre-wrap" class="codeBlockLines_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Content-styles-module">Map[Function[file, 
  &lt;|&quot;x&quot; -&gt; FileNameTake[file], &quot;y&quot; -&gt; QuantityMagnitude[FileSize[file], &quot;Megabytes&quot;]|&gt;
], Take[FileNames[&quot;*.*&quot;, $UserDocumentsDirectory], -30]];

&lt;|
  &quot;chart&quot; -&gt; &lt;|&quot;height&quot; -&gt; 350, &quot;width&quot;-&gt;550, &quot;type&quot; -&gt; &quot;treemap&quot;|&gt;,
  &quot;series&quot; -&gt; {
    &lt;|
      &quot;data&quot; -&gt; %
    |&gt;
  }
|&gt; // ApexCharts</code><code class="codeBlockLines_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Content-styles-module"></code></pre></div></div>
<div style="filter:none" class="language-mathematica codeBlockContainer_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Container-styles-module theme-code-block"><div class="codeBlockContent_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Content-styles-module"><pre tabindex="0" class="prism-code language-mathematica codeBlock_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Content-styles-module thin-scrollbar" style="color:rgb(57, 58, 52);background-color:rgb(246, 248, 250)"><code style="white-space:pre-wrap" class="codeBlockLines_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Content-styles-module">(*VB[*)(FrontEndRef[&quot;ed68aa5d-5b03-4d3e-9368-9db4850e4fb4&quot;])(*,*)(*&quot;1:eJxTTMoPSmNkYGAoZgESHvk5KRCeEJBwK8rPK3HNS3GtSE0uLUlMykkNVgEKp6aYWSQmmqbomiYZGOuapBin6loam1noWqYkmViYGqSapCWZAACMnBXe&quot;*)(*]VB*)</code><code class="codeBlockLines_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Content-styles-module"></code></pre></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="basic-line-and-scatter-plot">Basic line and scatter plot<a href="#basic-line-and-scatter-plot" class="hash-link" aria-label="Direct link to Basic line and scatter plot" title="Direct link to Basic line and scatter plot">â€‹</a></h2>
<p>We generate some data and fit it</p>
<div style="filter:none" class="language-mathematica codeBlockContainer_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Container-styles-module theme-code-block"><div class="codeBlockContent_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Content-styles-module"><pre tabindex="0" class="prism-code language-mathematica codeBlock_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Content-styles-module thin-scrollbar" style="color:rgb(57, 58, 52);background-color:rgb(246, 248, 250)"><code style="white-space:pre-wrap" class="codeBlockLines_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Content-styles-module">data = (*VB[*)(Uncompress[&quot;1:eJxTTMoPShNlYGAoZgESPpnFJWlMyLwiBjBQOQBlMDBglVciIK9AQF7mQFG1yDr3h1Ut9ljlJQjoFyEgL3CgaIdc6+vAHfOwm88Bk1+HXZ4BJr8Pu/yH/UWHv2rE9B86ikM/Q9GsmSBwEod++yKu64sLbLmO49DvULQEKHt98QEc7ncoehMIcuFG7PICDtDwnYJdXsSBQPg7EIg/AvIKBOSVCMirIOQB1YiEag==&quot;])(*,*)(*&quot;1:eJxTTMoPSmNmYGAo5gUSYZmp5S6pyflFiSX5RcEcQBHP5Py8zKrUlEwOIC+NCaSQBUgEleakBrMCGT6JSak5wSAhv/y8VADckhIL&quot;*)(*]VB*);</code><code class="codeBlockLines_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Content-styles-module"></code></pre></div></div>
<div style="filter:none" class="language-mathematica codeBlockContainer_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Container-styles-module theme-code-block"><div class="codeBlockContent_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Content-styles-module"><pre tabindex="0" class="prism-code language-mathematica codeBlock_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Content-styles-module thin-scrollbar" style="color:rgb(57, 58, 52);background-color:rgb(246, 248, 250)"><code style="white-space:pre-wrap" class="codeBlockLines_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Content-styles-module">model = NonlinearModelFit[data, PDF[NormalDistribution[\[Chi], \[Sigma]]][x], {\[Chi], \[Sigma]}, x];
model[&quot;BestFit&quot;] // Framed</code><code class="codeBlockLines_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Content-styles-module"></code></pre></div></div>
<div style="filter:none" class="language-mathematica codeBlockContainer_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Container-styles-module theme-code-block"><div class="codeBlockContent_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Content-styles-module"><pre tabindex="0" class="prism-code language-mathematica codeBlock_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Content-styles-module thin-scrollbar" style="color:rgb(57, 58, 52);background-color:rgb(246, 248, 250)"><code style="white-space:pre-wrap" class="codeBlockLines_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Content-styles-module">(*BB[*)(0.2006324012781459` ((*SpB[*)Power[E(*|*),(*|*)-0.12645966144888396` ((*SpB[*)Power[(-0.07691379051183606`+x)(*|*),(*|*)2](*]SpB*))](*]SpB*)))(*,*)(*&quot;1:eJxTTMoPSmNiYGAo5gMSwSWVOakuqcn5RYkl+UUQcRYgEVSak1rMA1ZQlFngn+eZV1BaUswKFHBLzClORVUYDBYvSsxNBQuFFJWmAgAQ7xjr&quot;*)(*]BB*)</code><code class="codeBlockLines_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Content-styles-module"></code></pre></div></div>
<div style="filter:none" class="language-mathematica codeBlockContainer_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Container-styles-module theme-code-block"><div class="codeBlockContent_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Content-styles-module"><pre tabindex="0" class="prism-code language-mathematica codeBlock_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Content-styles-module thin-scrollbar" style="color:rgb(57, 58, 52);background-color:rgb(246, 248, 250)"><code style="white-space:pre-wrap" class="codeBlockLines_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Content-styles-module">&lt;|
  &quot;series&quot; -&gt; {
    &lt;|
      &quot;name&quot; -&gt; &quot;Points&quot;,
      &quot;type&quot; -&gt; &quot;scatter&quot;,
      &quot;data&quot; -&gt; Map[&lt;|&quot;x&quot;-&gt;#[[1]], &quot;y&quot;-&gt;#[[2]]|&gt;&amp;, data]
    |&gt;,
    &lt;|
      &quot;name&quot; -&gt; &quot;Line&quot;,
      &quot;type&quot; -&gt; &quot;line&quot;,
      &quot;data&quot; -&gt; Table[&lt;|&quot;x&quot;-&gt;x, &quot;y&quot;-&gt;model[x]|&gt;, {x, data[[1,1]], data[[-1,1]], 0.1}]
    |&gt;
  },
  &quot;chart&quot; -&gt; &lt;|&quot;width&quot; -&gt; 550, &quot;type&quot; -&gt; &quot;line&quot;|&gt;,
  &quot;fill&quot; -&gt; &lt;|&quot;type&quot; -&gt; &quot;solid&quot;|&gt;,
  &quot;markers&quot; -&gt; &lt;|&quot;size&quot; -&gt; {6, 0}|&gt;,
  &quot;tooltip&quot; -&gt; &lt;|&quot;shared&quot; -&gt; False, &quot;intersect&quot; -&gt; True|&gt;,
  &quot;legend&quot; -&gt; &lt;|&quot;show&quot; -&gt; False|&gt;,
  &quot;yaxis&quot; -&gt; &lt;|&quot;type&quot; -&gt; &quot;numeric&quot;, &quot;decimalsInFloat&quot;-&gt;2, &quot;min&quot; -&gt; 0, &quot;max&quot; -&gt; 0.2, &quot;tickAmount&quot; -&gt; 5|&gt;,
  &quot;xaxis&quot; -&gt; &lt;|&quot;type&quot; -&gt; &quot;numeric&quot;, &quot;min&quot; -&gt; -10, &quot;max&quot; -&gt; 10, &quot;tickAmount&quot; -&gt; 15|&gt;
|&gt; // ApexCharts</code><code class="codeBlockLines_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Content-styles-module"></code></pre></div></div>
<div style="filter:none" class="language-mathematica codeBlockContainer_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Container-styles-module theme-code-block"><div class="codeBlockContent_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Content-styles-module"><pre tabindex="0" class="prism-code language-mathematica codeBlock_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Content-styles-module thin-scrollbar" style="color:rgb(57, 58, 52);background-color:rgb(246, 248, 250)"><code style="white-space:pre-wrap" class="codeBlockLines_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Content-styles-module">(*VB[*)(FrontEndRef[&quot;23978efd-cb2e-47ed-a8ad-af66454753d9&quot;])(*,*)(*&quot;1:eJxTTMoPSmNkYGAoZgESHvk5KRCeEJBwK8rPK3HNS3GtSE0uLUlMykkNVgEKGxlbmlukpqXoJicZpeqamKem6CZaJAKJNDMzE1MTc1PjFEsAkLcWGQ==&quot;*)(*]VB*)</code><code class="codeBlockLines_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Content-styles-module"></code></pre></div></div></article></div><div class="col col--2"><div class="tableOfContents_bqdL thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#how-to-install-and-build" class="table-of-contents__link toc-highlight">How to install and build</a></li><li><a href="#explorations" class="table-of-contents__link toc-highlight">Explorations</a><ul><li><a href="#bar-charts" class="table-of-contents__link toc-highlight">Bar charts</a></li></ul></li><li><a href="#treemap" class="table-of-contents__link toc-highlight">Treemap</a></li><li><a href="#basic-line-and-scatter-plot" class="table-of-contents__link toc-highlight">Basic line and scatter plot</a></li></ul></div></div></div></main></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://github.com/JerryI/wolfram-js-frontend" target="_blank" rel="noopener noreferrer" class="footer__link-item">Github<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://github.com/JerryI/wolfram-js-frontend/discussions" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discussions<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://t.me/wljs_support" target="_blank" rel="noopener noreferrer" class="footer__link-item">Telegram<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">WLJS Notebook Project is open-source and licensed under GPL3</div></div></div></footer></div>
</body>
</html>